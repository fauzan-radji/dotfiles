module.exports=function(n){var t={};function e(a){if(t[a])return t[a].exports;var i=t[a]={i:a,l:!1,exports:{}};return n[a].call(i.exports,i,i.exports,e),i.l=!0,i.exports}return e.m=n,e.c=t,e.d=function(n,t,a){e.o(n,t)||Object.defineProperty(n,t,{enumerable:!0,get:a})},e.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},e.t=function(n,t){if(1&t&&(n=e(n)),8&t)return n;if(4&t&&"object"==typeof n&&n&&n.__esModule)return n;var a=Object.create(null);if(e.r(a),Object.defineProperty(a,"default",{enumerable:!0,value:n}),2&t&&"string"!=typeof n)for(var i in n)e.d(a,i,function(t){return n[t]}.bind(null,i));return a},e.n=function(n){var t=n&&n.__esModule?function(){return n.default}:function(){return n};return e.d(t,"a",t),t},e.o=function(n,t){return Object.prototype.hasOwnProperty.call(n,t)},e.p="",e(e.s=137)}([function(n,t){n.exports=require("vscode")},function(n,t){n.exports=require("util")},function(n,t,e){"use strict";const a=e(4);n.exports=a.extends("statement",(function(n,t,e){a.apply(this,[n||"statement",t,e])}))},function(n,t,e){"use strict";const a=e(4);n.exports=a.extends("expression",(function(n,t,e){a.apply(this,[n||"expression",t,e])}))},function(n,t,e){"use strict";const a=function(n,t,e){this.kind=n,t&&(this.leadingComments=t),e&&(this.loc=e)};a.prototype.setTrailingComments=function(n){this.trailingComments=n},a.prototype.destroy=function(n){if(!n)throw new Error("Node already initialized, you must swap with another node");return this.leadingComments&&(n.leadingComments?n.leadingComments=Array.concat(this.leadingComments,n.leadingComments):n.leadingComments=this.leadingComments),this.trailingComments&&(n.trailingComments?n.trailingComments=Array.concat(this.trailingComments,n.trailingComments):n.trailingComments=this.trailingComments),n},a.prototype.includeToken=function(n){return this.loc&&(this.loc.end&&(this.loc.end.line=n.lexer.yylloc.last_line,this.loc.end.column=n.lexer.yylloc.last_column,this.loc.end.offset=n.lexer.offset),n.ast.withSource&&(this.loc.source=n.lexer._input.substring(this.loc.start.offset,n.lexer.offset))),this},a.extends=function(n,t){return t.prototype=Object.create(this.prototype),t.extends=this.extends,t.prototype.constructor=t,t.kind=n,t},n.exports=a},function(n,t,e){"use strict";const a=e(3);n.exports=a.extends("literal",(function(n,t,e,i,r){a.apply(this,[n||"literal",i,r]),this.value=t,e&&(this.raw=e)}))},function(n,t,e){"use strict";const a=e(3);n.exports=a.extends("operation",(function(n,t,e){a.apply(this,[n||"operation",t,e])}))},function(n,t,e){"use strict";const a=e(2),i=a.extends("declaration",(function(n,t,e,i){a.apply(this,[n||"declaration",e,i]),this.name=t}));i.prototype.parseFlags=function(n){this.isAbstract=1===n[2],this.isFinal=2===n[2],"class"!==this.kind&&(-1===n[0]?this.visibility="":null===n[0]?this.visibility=null:0===n[0]?this.visibility="public":1===n[0]?this.visibility="protected":2===n[0]&&(this.visibility="private"),this.isStatic=1===n[1])},n.exports=i},function(n,t,e){"use strict";const a=e(4),i=a.extends("reference",(function(n,t,e){a.apply(this,[n||"reference",t,e])}));n.exports=i},function(n,t){n.exports=require("fs")},function(n,t,e){"use strict";const a=e(2);n.exports=a.extends("block",(function(n,t,e,i){a.apply(this,[n||"block",e,i]),this.children=t.filter(Boolean)}))},function(n,t,e){"use strict";const a=e(3);n.exports=a.extends("lookup",(function(n,t,e,i,r){a.apply(this,[n||"lookup",i,r]),this.what=t,this.offset=e}))},function(n,t,e){"use strict";const a=e(4);n.exports=a.extends("comment",(function(n,t,e,i){a.apply(this,[n,e,i]),this.value=t}))},function(n,t,e){"use strict";const a=e(2),i="constantstatement";n.exports=a.extends(i,(function(n,t,e,r){a.apply(this,[n||i,e,r]),this.constants=t}))},function(n,t,e){"use strict";const a=e(7);n.exports=a.extends("function",(function(n,t,e,i,r,s,o){a.apply(this,["function",n,s,o]),this.arguments=t,this.byref=e,this.type=i,this.nullable=r,this.body=null}))},function(n,t){n.exports=require("child_process")},function(n,t){n.exports=require("os")},function(n,t,e){"use strict";const a=e(18),i=e(27),r=e(43),s=e(44);function o(n,t){const e=Object.keys(n);let a=e.length;for(;a--;){const i=e[a],r=n[i];null===r?delete t[i]:"function"==typeof r?t[i]=r.bind(t):Array.isArray(r)?t[i]=Array.isArray(t[i])?t[i].concat(r):r:t[i]="object"==typeof r&&"object"==typeof t[i]?o(r,t[i]):r}return t}const c=function(n){if("function"==typeof this)return new this(n);if(this.tokens=r,this.lexer=new a(this),this.ast=new s,this.parser=new i(this.lexer,this.ast),n&&"object"==typeof n){if(n.parser&&(n.lexer||(n.lexer={}),n.parser.version)){if("string"==typeof n.parser.version){let t=n.parser.version.split(".");if(t=100*parseInt(t[0])+parseInt(t[1]),isNaN(t))throw new Error("Bad version number : "+n.parser.version);n.parser.version=t}else if("number"!=typeof n.parser.version)throw new Error("Expecting a number for version");if(n.parser.version<500||n.parser.version>704)throw new Error("Can only handle versions between 5.x to 7.x")}o(n,this),this.lexer.version=this.parser.version}},l=function(n){return"function"==typeof n.write?n.toString():n};c.create=function(n){return new c(n)},c.parseEval=function(n,t){return new c(t).parseEval(n)},c.prototype.parseEval=function(n){return this.lexer.mode_eval=!0,this.lexer.all_tokens=!1,n=l(n),this.parser.parse(n,"eval")},c.parseCode=function(n,t,e){"object"!=typeof t||e||(e=t,t="unknown");return new c(e).parseCode(n,t)},c.prototype.parseCode=function(n,t){return this.lexer.mode_eval=!1,this.lexer.all_tokens=!1,n=l(n),this.parser.parse(n,t)},c.tokenGetAll=function(n,t){return new c(t).tokenGetAll(n)},c.prototype.tokenGetAll=function(n){this.lexer.mode_eval=!1,this.lexer.all_tokens=!0,n=l(n);const t=this.lexer.EOF,e=this.tokens.values;this.lexer.setInput(n);let a=this.lexer.lex()||t;const i=[];for(;a!=t;){let n=this.lexer.yytext;e.hasOwnProperty(a)&&(n=[e[a],n,this.lexer.yylloc.first_line]),i.push(n),a=this.lexer.lex()||t}return i},n.exports=c,n.exports.tokens=r,n.exports.lexer=a,n.exports.AST=s,n.exports.parser=i,n.exports.combine=o,n.exports.default=c},function(n,t,e){"use strict";const a=function(n){this.engine=n,this.tok=this.engine.tokens.names,this.EOF=1,this.debug=!1,this.all_tokens=!0,this.comment_tokens=!1,this.mode_eval=!1,this.asp_tags=!1,this.short_tags=!1,this.version=704,this.yyprevcol=0,this.keywords={__class__:this.tok.T_CLASS_C,__trait__:this.tok.T_TRAIT_C,__function__:this.tok.T_FUNC_C,__method__:this.tok.T_METHOD_C,__line__:this.tok.T_LINE,__file__:this.tok.T_FILE,__dir__:this.tok.T_DIR,__namespace__:this.tok.T_NS_C,exit:this.tok.T_EXIT,die:this.tok.T_EXIT,function:this.tok.T_FUNCTION,const:this.tok.T_CONST,return:this.tok.T_RETURN,try:this.tok.T_TRY,catch:this.tok.T_CATCH,finally:this.tok.T_FINALLY,throw:this.tok.T_THROW,if:this.tok.T_IF,elseif:this.tok.T_ELSEIF,endif:this.tok.T_ENDIF,else:this.tok.T_ELSE,while:this.tok.T_WHILE,endwhile:this.tok.T_ENDWHILE,do:this.tok.T_DO,for:this.tok.T_FOR,endfor:this.tok.T_ENDFOR,foreach:this.tok.T_FOREACH,endforeach:this.tok.T_ENDFOREACH,declare:this.tok.T_DECLARE,enddeclare:this.tok.T_ENDDECLARE,instanceof:this.tok.T_INSTANCEOF,as:this.tok.T_AS,switch:this.tok.T_SWITCH,endswitch:this.tok.T_ENDSWITCH,case:this.tok.T_CASE,default:this.tok.T_DEFAULT,break:this.tok.T_BREAK,continue:this.tok.T_CONTINUE,goto:this.tok.T_GOTO,echo:this.tok.T_ECHO,print:this.tok.T_PRINT,class:this.tok.T_CLASS,interface:this.tok.T_INTERFACE,trait:this.tok.T_TRAIT,extends:this.tok.T_EXTENDS,implements:this.tok.T_IMPLEMENTS,new:this.tok.T_NEW,clone:this.tok.T_CLONE,var:this.tok.T_VAR,eval:this.tok.T_EVAL,include:this.tok.T_INCLUDE,include_once:this.tok.T_INCLUDE_ONCE,require:this.tok.T_REQUIRE,require_once:this.tok.T_REQUIRE_ONCE,namespace:this.tok.T_NAMESPACE,use:this.tok.T_USE,insteadof:this.tok.T_INSTEADOF,global:this.tok.T_GLOBAL,isset:this.tok.T_ISSET,empty:this.tok.T_EMPTY,__halt_compiler:this.tok.T_HALT_COMPILER,static:this.tok.T_STATIC,abstract:this.tok.T_ABSTRACT,final:this.tok.T_FINAL,private:this.tok.T_PRIVATE,protected:this.tok.T_PROTECTED,public:this.tok.T_PUBLIC,unset:this.tok.T_UNSET,list:this.tok.T_LIST,array:this.tok.T_ARRAY,callable:this.tok.T_CALLABLE,or:this.tok.T_LOGICAL_OR,and:this.tok.T_LOGICAL_AND,xor:this.tok.T_LOGICAL_XOR},this.castKeywords={int:this.tok.T_INT_CAST,integer:this.tok.T_INT_CAST,real:this.tok.T_DOUBLE_CAST,double:this.tok.T_DOUBLE_CAST,float:this.tok.T_DOUBLE_CAST,string:this.tok.T_STRING_CAST,binary:this.tok.T_STRING_CAST,array:this.tok.T_ARRAY_CAST,object:this.tok.T_OBJECT_CAST,bool:this.tok.T_BOOL_CAST,boolean:this.tok.T_BOOL_CAST,unset:this.tok.T_UNSET_CAST}};a.prototype.setInput=function(n){return this._input=n,this.size=n.length,this.yylineno=1,this.offset=0,this.yyprevcol=0,this.yytext="",this.yylloc={first_offset:0,first_line:1,first_column:0,prev_offset:0,prev_line:1,prev_column:0,last_line:1,last_column:0},this.tokens=[],this.version>703?this.keywords.fn=this.tok.T_FN:delete this.keywords.fn,this.done=this.offset>=this.size,!this.all_tokens&&this.mode_eval?(this.conditionStack=["INITIAL"],this.begin("ST_IN_SCRIPTING")):(this.conditionStack=[],this.begin("INITIAL")),this.heredoc_label={label:"",length:0,indentation:0,indentation_uses_spaces:!1,finished:!1,first_encaps_node:!1,toString:function(){this.label}},this},a.prototype.input=function(){const n=this._input[this.offset];return n?(this.yytext+=n,this.offset++,"\r"===n&&"\n"===this._input[this.offset]&&(this.yytext+="\n",this.offset++),"\n"===n||"\r"===n?(this.yylloc.last_line=++this.yylineno,this.yyprevcol=this.yylloc.last_column,this.yylloc.last_column=0):this.yylloc.last_column++,n):""},a.prototype.unput=function(n){if(1===n)this.offset--,"\n"===this._input[this.offset]&&"\r"===this._input[this.offset-1]&&(this.offset--,n++),"\r"===this._input[this.offset]||"\n"===this._input[this.offset]?(this.yylloc.last_line--,this.yylineno--,this.yylloc.last_column=this.yyprevcol):this.yylloc.last_column--,this.yytext=this.yytext.substring(0,this.yytext.length-n);else if(n>0)if(this.offset-=n,n<this.yytext.length){this.yytext=this.yytext.substring(0,this.yytext.length-n),this.yylloc.last_line=this.yylloc.first_line,this.yylloc.last_column=this.yyprevcol=this.yylloc.first_column;for(let n=0;n<this.yytext.length;n++){let t=this.yytext[n];"\r"===t?(t=this.yytext[++n],this.yyprevcol=this.yylloc.last_column,this.yylloc.last_line++,this.yylloc.last_column=0,"\n"!==t&&("\r"===t?this.yylloc.last_line++:this.yylloc.last_column++)):"\n"===t?(this.yyprevcol=this.yylloc.last_column,this.yylloc.last_line++,this.yylloc.last_column=0):this.yylloc.last_column++}this.yylineno=this.yylloc.last_line}else this.yytext="",this.yylloc.last_line=this.yylineno=this.yylloc.first_line,this.yylloc.last_column=this.yylloc.first_column;return this},a.prototype.tryMatch=function(n){return n===this.ahead(n.length)},a.prototype.tryMatchCaseless=function(n){return n===this.ahead(n.length).toLowerCase()},a.prototype.ahead=function(n){let t=this._input.substring(this.offset,this.offset+n);return"\r"===t[t.length-1]&&"\n"===this._input[this.offset+n+1]&&(t+="\n"),t},a.prototype.consume=function(n){for(let t=0;t<n;t++){const n=this._input[this.offset];if(!n)break;this.yytext+=n,this.offset++,"\r"===n&&"\n"===this._input[this.offset]&&(this.yytext+="\n",this.offset++,t++),"\n"===n||"\r"===n?(this.yylloc.last_line=++this.yylineno,this.yyprevcol=this.yylloc.last_column,this.yylloc.last_column=0):this.yylloc.last_column++}return this},a.prototype.getState=function(){return{yytext:this.yytext,offset:this.offset,yylineno:this.yylineno,yyprevcol:this.yyprevcol,yylloc:{first_offset:this.yylloc.first_offset,first_line:this.yylloc.first_line,first_column:this.yylloc.first_column,last_line:this.yylloc.last_line,last_column:this.yylloc.last_column},heredoc_label:this.heredoc_label}},a.prototype.setState=function(n){return this.yytext=n.yytext,this.offset=n.offset,this.yylineno=n.yylineno,this.yyprevcol=n.yyprevcol,this.yylloc=n.yylloc,n.heredoc_label&&(this.heredoc_label=n.heredoc_label),this},a.prototype.appendToken=function(n,t){return this.tokens.push([n,t]),this},a.prototype.lex=function(){this.yylloc.prev_offset=this.offset,this.yylloc.prev_line=this.yylloc.last_line,this.yylloc.prev_column=this.yylloc.last_column;let n=this.next()||this.lex();if(!this.all_tokens){for(;n===this.tok.T_WHITESPACE||!this.comment_tokens&&(n===this.tok.T_COMMENT||n===this.tok.T_DOC_COMMENT)||n===this.tok.T_OPEN_TAG;)n=this.next()||this.lex();if(n==this.tok.T_OPEN_TAG_WITH_ECHO)return this.tok.T_ECHO;if(n===this.tok.T_CLOSE_TAG)return";"}return this.yylloc.prev_offset||(this.yylloc.prev_offset=this.yylloc.first_offset,this.yylloc.prev_line=this.yylloc.first_line,this.yylloc.prev_column=this.yylloc.first_column),n},a.prototype.begin=function(n){if(this.conditionStack.push(n),this.curCondition=n,this.stateCb=this["match"+n],"function"!=typeof this.stateCb)throw new Error('Undefined condition state "'+n+'"');return this},a.prototype.popState=function(){const n=this.conditionStack.length-1>0?this.conditionStack.pop():this.conditionStack[0];if(this.curCondition=this.conditionStack[this.conditionStack.length-1],this.stateCb=this["match"+this.curCondition],"function"!=typeof this.stateCb)throw new Error('Undefined condition state "'+this.curCondition+'"');return n},a.prototype.next=function(){let n;if(this._input||(this.done=!0),this.yylloc.first_offset=this.offset,this.yylloc.first_line=this.yylloc.last_line,this.yylloc.first_column=this.yylloc.last_column,this.yytext="",this.done)return this.yylloc.prev_offset=this.yylloc.first_offset,this.yylloc.prev_line=this.yylloc.first_line,this.yylloc.prev_column=this.yylloc.first_column,this.EOF;if(this.tokens.length>0?(n=this.tokens.shift(),"object"==typeof n[1]?this.setState(n[1]):this.consume(n[1]),n=n[0]):n=this.stateCb.apply(this,[]),this.offset>=this.size&&0===this.tokens.length&&(this.done=!0),this.debug){let t=n;t="number"==typeof t?this.engine.tokens.values[t]:'"'+t+'"';const e=new Error(t+"\tfrom "+this.yylloc.first_line+","+this.yylloc.first_column+"\t - to "+this.yylloc.last_line+","+this.yylloc.last_column+'\t"'+this.yytext+'"');console.error(e.stack)}return n},[e(19),e(20),e(21),e(22),e(23),e(24),e(25),e(26)].forEach((function(n){for(const t in n)a.prototype[t]=n[t]})),n.exports=a},function(n,t,e){"use strict";n.exports={T_COMMENT:function(){for(;this.offset<this.size;){const n=this.input();if("\n"===n||"\r"===n)return this.tok.T_COMMENT;if("?"===n&&!this.aspTagMode&&">"===this._input[this.offset])return this.unput(1),this.tok.T_COMMENT;if("%"===n&&this.aspTagMode&&">"===this._input[this.offset])return this.unput(1),this.tok.T_COMMENT}return this.tok.T_COMMENT},T_DOC_COMMENT:function(){let n=this.input(),t=this.tok.T_COMMENT;if("*"===n){if(n=this.input(),this.is_WHITESPACE()&&(t=this.tok.T_DOC_COMMENT),"/"===n)return t;this.unput(1)}for(;this.offset<this.size;)if(n=this.input(),"*"===n&&"/"===this._input[this.offset]){this.input();break}return t}}},function(n,t,e){"use strict";n.exports={nextINITIAL:function(){return this.conditionStack.length>1&&"INITIAL"===this.conditionStack[this.conditionStack.length-1]?this.popState():this.begin("ST_IN_SCRIPTING"),this},matchINITIAL:function(){for(;this.offset<this.size;){let n=this.input();if("<"==n)if(n=this.ahead(1),"?"==n){if(this.tryMatch("?=")){this.unput(1).appendToken(this.tok.T_OPEN_TAG_WITH_ECHO,3).nextINITIAL();break}if(this.tryMatchCaseless("?php")&&(n=this._input[this.offset+4]," "===n||"\t"===n||"\n"===n||"\r"===n)){this.unput(1).appendToken(this.tok.T_OPEN_TAG,6).nextINITIAL();break}if(this.short_tags){this.unput(1).appendToken(this.tok.T_OPEN_TAG,2).nextINITIAL();break}}else if(this.asp_tags&&"%"==n){if(this.tryMatch("%=")){this.aspTagMode=!0,this.unput(1).appendToken(this.tok.T_OPEN_TAG_WITH_ECHO,3).nextINITIAL();break}this.aspTagMode=!0,this.unput(1).appendToken(this.tok.T_OPEN_TAG,2).nextINITIAL();break}}return this.yytext.length>0&&this.tok.T_INLINE_HTML}}},function(n,t,e){"use strict";let a=10,i="2147483648";"x64"==process.arch&&(a=19,i="9223372036854775808"),n.exports={consume_NUM:function(){let n=this.yytext[0],t="."===n;if("0"===n)if(n=this.input(),"x"===n||"X"===n){if(n=this.input(),"_"!==n&&this.is_HEX())return this.consume_HNUM();this.unput(n?2:1)}else if("b"===n||"B"===n){if(n=this.input(),"_"!==n&&"0"===n||"1"===n)return this.consume_BNUM();this.unput(n?2:1)}else this.is_NUM()||n&&this.unput(1);for(;this.offset<this.size;){const e=n;if(n=this.input(),"_"===n){if("_"===e){this.unput(2);break}if("."===e){this.unput(1);break}if("e"===e||"E"===e){this.unput(2);break}}else{if("."===n){if(t){this.unput(1);break}if("_"===e){this.unput(2);break}t=!0;continue}if("e"===n||"E"===n){if("_"===e){this.unput(1);break}let t=2;if(n=this.input(),"+"!==n&&"-"!==n||(t=3,n=this.input()),this.is_NUM_START())return this.consume_LNUM(),this.tok.T_DNUMBER;this.unput(n?t:t-1);break}}if(!this.is_NUM()){n&&this.unput(1);break}}return t?this.tok.T_DNUMBER:this.yytext.length<a-1||this.yytext.length<a||this.yytext.length==a&&this.yytext<i?this.tok.T_LNUMBER:this.tok.T_DNUMBER},consume_HNUM:function(){for(;this.offset<this.size;){const n=this.input();if(!this.is_HEX()){n&&this.unput(1);break}}return this.tok.T_LNUMBER},consume_LNUM:function(){for(;this.offset<this.size;){const n=this.input();if(!this.is_NUM()){n&&this.unput(1);break}}return this.tok.T_LNUMBER},consume_BNUM:function(){let n;for(;this.offset<this.size;)if(n=this.input(),"0"!==n&&"1"!==n&&"_"!==n){n&&this.unput(1);break}return this.tok.T_LNUMBER}}},function(n,t,e){"use strict";n.exports={matchST_LOOKING_FOR_PROPERTY:function(){let n=this.input();if("-"===n){if(n=this.input(),">"===n)return this.tok.T_OBJECT_OPERATOR;n&&this.unput(1)}else{if(this.is_WHITESPACE())return this.tok.T_WHITESPACE;if(this.is_LABEL_START())return this.consume_LABEL(),this.popState(),this.tok.T_STRING}return this.popState(),n&&this.unput(1),!1},matchST_LOOKING_FOR_VARNAME:function(){let n=this.input();if(this.popState(),this.begin("ST_IN_SCRIPTING"),this.is_LABEL_START()){if(this.consume_LABEL(),n=this.input(),"["===n||"}"===n)return this.unput(1),this.tok.T_STRING_VARNAME;this.unput(this.yytext.length)}else n&&this.unput(1);return!1},matchST_VAR_OFFSET:function(){const n=this.input();if(this.is_NUM_START())return this.consume_NUM(),this.tok.T_NUM_STRING;if("]"===n)return this.popState(),"]";if("$"===n){if(this.input(),this.is_LABEL_START())return this.consume_LABEL(),this.tok.T_VARIABLE;throw new Error("Unexpected terminal")}if(this.is_LABEL_START())return this.consume_LABEL(),this.tok.T_STRING;if(this.is_WHITESPACE()||"\\"===n||"'"===n||"#"===n)return this.tok.T_ENCAPSED_AND_WHITESPACE;if("["===n||"{"===n||"}"===n||'"'===n||"`"===n||this.is_TOKEN())return n;throw new Error("Unexpected terminal")}}},function(n,t,e){"use strict";n.exports={matchST_IN_SCRIPTING:function(){let n=this.input();switch(n){case" ":case"\t":case"\n":case"\r":case"\r\n":return this.T_WHITESPACE();case"#":return this.T_COMMENT();case"/":return"/"===this._input[this.offset]?this.T_COMMENT():"*"===this._input[this.offset]?(this.input(),this.T_DOC_COMMENT()):this.consume_TOKEN();case"'":return this.T_CONSTANT_ENCAPSED_STRING();case'"':return this.ST_DOUBLE_QUOTES();case"`":return this.begin("ST_BACKQUOTE"),"`";case"?":if(!this.aspTagMode&&this.tryMatch(">")){this.input();const n=this._input[this.offset];return"\n"!==n&&"\r"!==n||this.input(),this.conditionStack.length>1&&this.begin("INITIAL"),this.tok.T_CLOSE_TAG}return this.consume_TOKEN();case"%":return this.aspTagMode&&">"===this._input[this.offset]?(this.input(),n=this._input[this.offset],"\n"!==n&&"\r"!==n||this.input(),this.aspTagMode=!1,this.conditionStack.length>1&&this.begin("INITIAL"),this.tok.T_CLOSE_TAG):this.consume_TOKEN();case"{":return this.begin("ST_IN_SCRIPTING"),"{";case"}":return this.conditionStack.length>2&&this.popState(),"}";default:if("."===n){if(n=this.input(),this.is_NUM_START())return this.consume_NUM();n&&this.unput(1)}if(this.is_NUM_START())return this.consume_NUM();if(this.is_LABEL_START())return this.consume_LABEL().T_STRING();if(this.is_TOKEN())return this.consume_TOKEN()}throw new Error('Bad terminal sequence "'+n+'" at line '+this.yylineno+" (offset "+this.offset+")")},T_WHITESPACE:function(){for(;this.offset<this.size;){const n=this.input();if(" "!==n&&"\t"!==n&&"\n"!==n&&"\r"!==n){n&&this.unput(1);break}}return this.tok.T_WHITESPACE}}},function(n,t,e){"use strict";const a=["\n","\r"],i=["\n","\r",";"],r=i.concat(["\t"," ",",","]",")","/","=","!"]);n.exports={T_CONSTANT_ENCAPSED_STRING:function(){let n;for(;this.offset<this.size;)if(n=this.input(),"\\"==n)this.input();else if("'"==n)break;return this.tok.T_CONSTANT_ENCAPSED_STRING},is_HEREDOC:function(){const n=this.offset;if("<"===this._input[this.offset-1]&&"<"===this._input[this.offset]&&"<"===this._input[this.offset+1]){if(this.offset+=3,this.is_TABSPACE())for(;this.offset<this.size&&(this.offset++,this.is_TABSPACE()););let t=this._input[this.offset-1];if("'"===t||'"'===t?this.offset++:t=null,this.is_LABEL_START()){let e=this.offset-1;for(;this.offset<this.size&&(this.offset++,this.is_LABEL()););const i=this._input.substring(e,this.offset-1);if((!t||t===this._input[this.offset-1])&&(t&&this.offset++,a.includes(this._input[this.offset-1])))return this.heredoc_label.label=i,this.heredoc_label.length=i.length,this.heredoc_label.finished=!1,e=this.offset-n,this.offset=n,this.consume(e),"'"===t?this.begin("ST_NOWDOC"):this.begin("ST_HEREDOC"),this.prematch_ENDOFDOC(),this.tok.T_START_HEREDOC}}return this.offset=n,!1},ST_DOUBLE_QUOTES:function(){let n;for(;this.offset<this.size;)if(n=this.input(),"\\"==n)this.input();else{if('"'==n)break;if("$"==n){if(n=this.input(),"{"==n||this.is_LABEL_START()){this.unput(2);break}n&&this.unput(1)}else if("{"==n){if(n=this.input(),"$"==n){this.unput(2);break}n&&this.unput(1)}}if('"'==n)return this.tok.T_CONSTANT_ENCAPSED_STRING;{let n=1;return"b"!==this.yytext[0]&&"B"!==this.yytext[0]||(n=2),this.yytext.length>2&&this.appendToken(this.tok.T_ENCAPSED_AND_WHITESPACE,this.yytext.length-n),this.unput(this.yytext.length-n),this.begin("ST_DOUBLE_QUOTES"),this.yytext}},isDOC_MATCH:function(n,t){const e=this._input[n-2];if(!a.includes(e))return!1;let s=!1,o=!1,c=0,l=this._input[n-1];if(this.version>=703){for(;"\t"===l||" "===l;)" "===l?s=!0:"\t"===l&&(o=!0),l=this._input[n+c],c++;if(n+=c,a.includes(this._input[n-1]))return!1}if(this._input.substring(n-1,n-1+this.heredoc_label.length)===this.heredoc_label.label){const e=this._input[n-1+this.heredoc_label.length];if((this.version>=703?r:i).includes(e)){if(t){if(this.consume(c),s&&o)throw new Error("Parse error:  mixing spaces and tabs in ending marker at line "+this.yylineno+" (offset "+this.offset+")")}else this.heredoc_label.indentation=c,this.heredoc_label.indentation_uses_spaces=s,this.heredoc_label.first_encaps_node=!0;return!0}}return!1},prematch_ENDOFDOC:function(){this.heredoc_label.indentation_uses_spaces=!1,this.heredoc_label.indentation=0,this.heredoc_label.first_encaps_node=!0;let n=this.offset+1;for(;n<this._input.length;){if(this.isDOC_MATCH(n,!1))return;if(!a.includes(this._input[n-1]))for(;!a.includes(this._input[n++])&&n<this._input.length;);n++}},matchST_NOWDOC:function(){if(this.isDOC_MATCH(this.offset,!0))return this.consume(this.heredoc_label.length),this.popState(),this.tok.T_END_HEREDOC;let n=this._input[this.offset-1];for(;this.offset<this.size;)if(a.includes(n)){if(n=this.input(),this.isDOC_MATCH(this.offset,!0))return this.unput(1).popState(),this.appendToken(this.tok.T_END_HEREDOC,this.heredoc_label.length),this.tok.T_ENCAPSED_AND_WHITESPACE}else n=this.input();return this.tok.T_ENCAPSED_AND_WHITESPACE},matchST_HEREDOC:function(){let n=this.input();if(this.isDOC_MATCH(this.offset,!0))return this.consume(this.heredoc_label.length-1),this.popState(),this.tok.T_END_HEREDOC;for(;this.offset<this.size;)if("\\"===n&&(n=this.input(),a.includes(n)||(n=this.input())),a.includes(n)){if(n=this.input(),this.isDOC_MATCH(this.offset,!0))return this.unput(1).popState(),this.appendToken(this.tok.T_END_HEREDOC,this.heredoc_label.length),this.tok.T_ENCAPSED_AND_WHITESPACE}else if("$"===n){if(n=this.input(),"{"===n)return this.begin("ST_LOOKING_FOR_VARNAME"),this.yytext.length>2?(this.appendToken(this.tok.T_DOLLAR_OPEN_CURLY_BRACES,2),this.unput(2),this.tok.T_ENCAPSED_AND_WHITESPACE):this.tok.T_DOLLAR_OPEN_CURLY_BRACES;if(this.is_LABEL_START()){const n=this.offset,t=this.consume_VARIABLE();return this.yytext.length>this.offset-n+2?(this.appendToken(t,this.offset-n+2),this.unput(this.offset-n+2),this.tok.T_ENCAPSED_AND_WHITESPACE):t}}else if("{"===n){if(n=this.input(),"$"===n)return this.begin("ST_IN_SCRIPTING"),this.yytext.length>2?(this.appendToken(this.tok.T_CURLY_OPEN,1),this.unput(2),this.tok.T_ENCAPSED_AND_WHITESPACE):(this.unput(1),this.tok.T_CURLY_OPEN)}else n=this.input();return this.tok.T_ENCAPSED_AND_WHITESPACE},consume_VARIABLE:function(){this.consume_LABEL();const n=this.input();if("["==n)return this.unput(1),this.begin("ST_VAR_OFFSET"),this.tok.T_VARIABLE;if("-"===n){if(">"===this.input())return this.input(),this.is_LABEL_START()&&this.begin("ST_LOOKING_FOR_PROPERTY"),this.unput(3),this.tok.T_VARIABLE;this.unput(2)}else n&&this.unput(1);return this.tok.T_VARIABLE},matchST_BACKQUOTE:function(){let n=this.input();if("$"===n){if(n=this.input(),"{"===n)return this.begin("ST_LOOKING_FOR_VARNAME"),this.tok.T_DOLLAR_OPEN_CURLY_BRACES;if(this.is_LABEL_START()){return this.consume_VARIABLE()}}else if("{"===n){if("$"===this._input[this.offset])return this.begin("ST_IN_SCRIPTING"),this.tok.T_CURLY_OPEN}else if("`"===n)return this.popState(),"`";for(;this.offset<this.size;){if("\\"===n)this.input();else{if("`"===n){this.unput(1),this.popState(),this.appendToken("`",1);break}if("$"===n){if(n=this.input(),"{"===n)return this.begin("ST_LOOKING_FOR_VARNAME"),this.yytext.length>2?(this.appendToken(this.tok.T_DOLLAR_OPEN_CURLY_BRACES,2),this.unput(2),this.tok.T_ENCAPSED_AND_WHITESPACE):this.tok.T_DOLLAR_OPEN_CURLY_BRACES;if(this.is_LABEL_START()){const n=this.offset,t=this.consume_VARIABLE();return this.yytext.length>this.offset-n+2?(this.appendToken(t,this.offset-n+2),this.unput(this.offset-n+2),this.tok.T_ENCAPSED_AND_WHITESPACE):t}continue}if("{"===n){if(n=this.input(),"$"===n)return this.begin("ST_IN_SCRIPTING"),this.yytext.length>2?(this.appendToken(this.tok.T_CURLY_OPEN,1),this.unput(2),this.tok.T_ENCAPSED_AND_WHITESPACE):(this.unput(1),this.tok.T_CURLY_OPEN);continue}}n=this.input()}return this.tok.T_ENCAPSED_AND_WHITESPACE},matchST_DOUBLE_QUOTES:function(){let n=this.input();if("$"===n){if(n=this.input(),"{"===n)return this.begin("ST_LOOKING_FOR_VARNAME"),this.tok.T_DOLLAR_OPEN_CURLY_BRACES;if(this.is_LABEL_START()){return this.consume_VARIABLE()}}else if("{"===n){if("$"===this._input[this.offset])return this.begin("ST_IN_SCRIPTING"),this.tok.T_CURLY_OPEN}else if('"'===n)return this.popState(),'"';for(;this.offset<this.size;){if("\\"===n)this.input();else{if('"'===n){this.unput(1),this.popState(),this.appendToken('"',1);break}if("$"===n){if(n=this.input(),"{"===n)return this.begin("ST_LOOKING_FOR_VARNAME"),this.yytext.length>2?(this.appendToken(this.tok.T_DOLLAR_OPEN_CURLY_BRACES,2),this.unput(2),this.tok.T_ENCAPSED_AND_WHITESPACE):this.tok.T_DOLLAR_OPEN_CURLY_BRACES;if(this.is_LABEL_START()){const n=this.offset,t=this.consume_VARIABLE();return this.yytext.length>this.offset-n+2?(this.appendToken(t,this.offset-n+2),this.unput(this.offset-n+2),this.tok.T_ENCAPSED_AND_WHITESPACE):t}n&&this.unput(1)}else if("{"===n){if(n=this.input(),"$"===n)return this.begin("ST_IN_SCRIPTING"),this.yytext.length>2?(this.appendToken(this.tok.T_CURLY_OPEN,1),this.unput(2),this.tok.T_ENCAPSED_AND_WHITESPACE):(this.unput(1),this.tok.T_CURLY_OPEN);n&&this.unput(1)}}n=this.input()}return this.tok.T_ENCAPSED_AND_WHITESPACE}}},function(n,t,e){"use strict";n.exports={T_STRING:function(){const n=this.yytext.toLowerCase();let t=this.keywords[n];if("number"!=typeof t)if("yield"===n)this.version>=700&&this.tryMatch(" from")?(this.consume(5),t=this.tok.T_YIELD_FROM):t=this.tok.T_YIELD;else if(t=this.tok.T_STRING,"b"===n||"B"===n){const n=this.input(1);if('"'===n)return this.ST_DOUBLE_QUOTES();if("'"===n)return this.T_CONSTANT_ENCAPSED_STRING();n&&this.unput(1)}return t},consume_TOKEN:function(){const n=this._input[this.offset-1],t=this.tokenTerminals[n];return t?t.apply(this,[]):this.yytext},tokenTerminals:{$:function(){return this.offset++,this.is_LABEL_START()?(this.offset--,this.consume_LABEL(),this.tok.T_VARIABLE):(this.offset--,"$")},"-":function(){const n=this._input[this.offset];return">"===n?(this.begin("ST_LOOKING_FOR_PROPERTY").input(),this.tok.T_OBJECT_OPERATOR):"-"===n?(this.input(),this.tok.T_DEC):"="===n?(this.input(),this.tok.T_MINUS_EQUAL):"-"},"\\":function(){return this.tok.T_NS_SEPARATOR},"/":function(){return"="===this._input[this.offset]?(this.input(),this.tok.T_DIV_EQUAL):"/"},":":function(){return":"===this._input[this.offset]?(this.input(),this.tok.T_DOUBLE_COLON):":"},"(":function(){const n=this.offset;if(this.input(),this.is_TABSPACE()&&this.consume_TABSPACE().input(),this.is_LABEL_START()){const n=this.yytext.length;this.consume_LABEL();const t=this.yytext.substring(n-1).toLowerCase(),e=this.castKeywords[t];if("number"==typeof e&&(this.input(),this.is_TABSPACE()&&this.consume_TABSPACE().input(),")"===this._input[this.offset-1]))return e}return this.unput(this.offset-n),"("},"=":function(){const n=this._input[this.offset];return">"===n?(this.input(),this.tok.T_DOUBLE_ARROW):"="===n?"="===this._input[this.offset+1]?(this.consume(2),this.tok.T_IS_IDENTICAL):(this.input(),this.tok.T_IS_EQUAL):"="},"+":function(){const n=this._input[this.offset];return"+"===n?(this.input(),this.tok.T_INC):"="===n?(this.input(),this.tok.T_PLUS_EQUAL):"+"},"!":function(){return"="===this._input[this.offset]?"="===this._input[this.offset+1]?(this.consume(2),this.tok.T_IS_NOT_IDENTICAL):(this.input(),this.tok.T_IS_NOT_EQUAL):"!"},"?":function(){return this.version>=700&&"?"===this._input[this.offset]?this.version>=704&&"="===this._input[this.offset+1]?(this.consume(2),this.tok.T_COALESCE_EQUAL):(this.input(),this.tok.T_COALESCE):"?"},"<":function(){let n=this._input[this.offset];return"<"===n?(n=this._input[this.offset+1],"="===n?(this.consume(2),this.tok.T_SL_EQUAL):"<"===n&&this.is_HEREDOC()?this.tok.T_START_HEREDOC:(this.input(),this.tok.T_SL)):"="===n?(this.input(),this.version>=700&&">"===this._input[this.offset]?(this.input(),this.tok.T_SPACESHIP):this.tok.T_IS_SMALLER_OR_EQUAL):">"===n?(this.input(),this.tok.T_IS_NOT_EQUAL):"<"},">":function(){let n=this._input[this.offset];return"="===n?(this.input(),this.tok.T_IS_GREATER_OR_EQUAL):">"===n?(n=this._input[this.offset+1],"="===n?(this.consume(2),this.tok.T_SR_EQUAL):(this.input(),this.tok.T_SR)):">"},"*":function(){const n=this._input[this.offset];return"="===n?(this.input(),this.tok.T_MUL_EQUAL):"*"===n?(this.input(),"="===this._input[this.offset]?(this.input(),this.tok.T_POW_EQUAL):this.tok.T_POW):"*"},".":function(){const n=this._input[this.offset];return"="===n?(this.input(),this.tok.T_CONCAT_EQUAL):"."===n&&"."===this._input[this.offset+1]?(this.consume(2),this.tok.T_ELLIPSIS):"."},"%":function(){return"="===this._input[this.offset]?(this.input(),this.tok.T_MOD_EQUAL):"%"},"&":function(){const n=this._input[this.offset];return"="===n?(this.input(),this.tok.T_AND_EQUAL):"&"===n?(this.input(),this.tok.T_BOOLEAN_AND):"&"},"|":function(){const n=this._input[this.offset];return"="===n?(this.input(),this.tok.T_OR_EQUAL):"|"===n?(this.input(),this.tok.T_BOOLEAN_OR):"|"},"^":function(){return"="===this._input[this.offset]?(this.input(),this.tok.T_XOR_EQUAL):"^"}}}},function(n,t,e){"use strict";n.exports={is_NUM:function(){const n=this._input.charCodeAt(this.offset-1);return n>47&&n<58||95===n},is_NUM_START:function(){const n=this._input.charCodeAt(this.offset-1);return n>47&&n<58},is_LABEL:function(){const n=this._input.charCodeAt(this.offset-1);return n>96&&n<123||n>64&&n<91||95===n||n>47&&n<58||n>126},is_LABEL_START:function(){const n=this._input.charCodeAt(this.offset-1);return n>64&&n<91||(n>96&&n<123||(95===n||n>126))},consume_LABEL:function(){for(;this.offset<this.size;){const n=this.input();if(!this.is_LABEL()){n&&this.unput(1);break}}return this},is_TOKEN:function(){const n=this._input[this.offset-1];return-1!==";:,.\\[]()|^&+-/*=%!~$<>?@".indexOf(n)},is_WHITESPACE:function(){const n=this._input[this.offset-1];return" "===n||"\t"===n||"\n"===n||"\r"===n},is_TABSPACE:function(){const n=this._input[this.offset-1];return" "===n||"\t"===n},consume_TABSPACE:function(){for(;this.offset<this.size;){const n=this.input();if(!this.is_TABSPACE()){n&&this.unput(1);break}}return this},is_HEX:function(){const n=this._input.charCodeAt(this.offset-1);return n>47&&n<58||(n>64&&n<71||(n>96&&n<103||95===n))}}},function(n,t,e){"use strict";function a(n){return"."!=n&&","!=n&&!isNaN(parseFloat(n))&&isFinite(n)}const i=function(n,t){this.lexer=n,this.ast=t,this.tok=n.tok,this.EOF=n.EOF,this.token=null,this.prev=null,this.debug=!1,this.version=704,this.extractDoc=!1,this.extractTokens=!1,this.suppressErrors=!1;const e=function(n){return[n,null]};this.entries={IDENTIFIER:new Map([this.tok.T_ABSTRACT,this.tok.T_ARRAY,this.tok.T_AS,this.tok.T_BREAK,this.tok.T_CALLABLE,this.tok.T_CASE,this.tok.T_CATCH,this.tok.T_CLASS,this.tok.T_CLASS_C,this.tok.T_CLONE,this.tok.T_CONST,this.tok.T_CONTINUE,this.tok.T_DECLARE,this.tok.T_DEFAULT,this.tok.T_DIR,this.tok.T_DO,this.tok.T_ECHO,this.tok.T_ELSE,this.tok.T_ELSEIF,this.tok.T_EMPTY,this.tok.T_ENDDECLARE,this.tok.T_ENDFOR,this.tok.T_ENDFOREACH,this.tok.T_ENDIF,this.tok.T_ENDSWITCH,this.tok.T_ENDWHILE,this.tok.T_EVAL,this.tok.T_EXIT,this.tok.T_EXTENDS,this.tok.T_FILE,this.tok.T_FINAL,this.tok.T_FINALLY,this.tok.T_FN,this.tok.T_FOR,this.tok.T_FOREACH,this.tok.T_FUNC_C,this.tok.T_FUNCTION,this.tok.T_GLOBAL,this.tok.T_GOTO,this.tok.T_IF,this.tok.T_IMPLEMENTS,this.tok.T_INCLUDE,this.tok.T_INCLUDE_ONCE,this.tok.T_INSTANCEOF,this.tok.T_INSTEADOF,this.tok.T_INTERFACE,this.tok.T_ISSET,this.tok.T_LINE,this.tok.T_LIST,this.tok.T_LOGICAL_AND,this.tok.T_LOGICAL_OR,this.tok.T_LOGICAL_XOR,this.tok.T_METHOD_C,this.tok.T_NAMESPACE,this.tok.T_NEW,this.tok.T_NS_C,this.tok.T_PRINT,this.tok.T_PRIVATE,this.tok.T_PROTECTED,this.tok.T_PUBLIC,this.tok.T_REQUIRE,this.tok.T_REQUIRE_ONCE,this.tok.T_RETURN,this.tok.T_STATIC,this.tok.T_SWITCH,this.tok.T_THROW,this.tok.T_TRAIT,this.tok.T_TRY,this.tok.T_UNSET,this.tok.T_USE,this.tok.T_VAR,this.tok.T_WHILE,this.tok.T_YIELD].map(e)),VARIABLE:new Map([this.tok.T_VARIABLE,"$","&",this.tok.T_NS_SEPARATOR,this.tok.T_STRING,this.tok.T_NAMESPACE,this.tok.T_STATIC].map(e)),SCALAR:new Map([this.tok.T_CONSTANT_ENCAPSED_STRING,this.tok.T_START_HEREDOC,this.tok.T_LNUMBER,this.tok.T_DNUMBER,this.tok.T_ARRAY,"[",this.tok.T_CLASS_C,this.tok.T_TRAIT_C,this.tok.T_FUNC_C,this.tok.T_METHOD_C,this.tok.T_LINE,this.tok.T_FILE,this.tok.T_DIR,this.tok.T_NS_C,'"','b"','B"',"-",this.tok.T_NS_SEPARATOR].map(e)),T_MAGIC_CONST:new Map([this.tok.T_CLASS_C,this.tok.T_TRAIT_C,this.tok.T_FUNC_C,this.tok.T_METHOD_C,this.tok.T_LINE,this.tok.T_FILE,this.tok.T_DIR,this.tok.T_NS_C].map(e)),T_MEMBER_FLAGS:new Map([this.tok.T_PUBLIC,this.tok.T_PRIVATE,this.tok.T_PROTECTED,this.tok.T_STATIC,this.tok.T_ABSTRACT,this.tok.T_FINAL].map(e)),EOS:new Map([";",this.EOF,this.tok.T_INLINE_HTML].map(e)),EXPR:new Map(["@","-","+","!","~","(","`",this.tok.T_LIST,this.tok.T_CLONE,this.tok.T_INC,this.tok.T_DEC,this.tok.T_NEW,this.tok.T_ISSET,this.tok.T_EMPTY,this.tok.T_INCLUDE,this.tok.T_INCLUDE_ONCE,this.tok.T_REQUIRE,this.tok.T_REQUIRE_ONCE,this.tok.T_EVAL,this.tok.T_INT_CAST,this.tok.T_DOUBLE_CAST,this.tok.T_STRING_CAST,this.tok.T_ARRAY_CAST,this.tok.T_OBJECT_CAST,this.tok.T_BOOL_CAST,this.tok.T_UNSET_CAST,this.tok.T_EXIT,this.tok.T_PRINT,this.tok.T_YIELD,this.tok.T_STATIC,this.tok.T_FUNCTION,this.tok.T_FN,this.tok.T_VARIABLE,"$",this.tok.T_NS_SEPARATOR,this.tok.T_STRING,this.tok.T_STRING,this.tok.T_CONSTANT_ENCAPSED_STRING,this.tok.T_START_HEREDOC,this.tok.T_LNUMBER,this.tok.T_DNUMBER,this.tok.T_ARRAY,"[",this.tok.T_CLASS_C,this.tok.T_TRAIT_C,this.tok.T_FUNC_C,this.tok.T_METHOD_C,this.tok.T_LINE,this.tok.T_FILE,this.tok.T_DIR,this.tok.T_NS_C,'"','b"','B"',"-",this.tok.T_NS_SEPARATOR].map(e))}};i.prototype.getTokenName=function(n){return a(n)?n==this.EOF?"the end of file (EOF)":this.lexer.engine.tokens.values[n]:"'"+n+"'"},i.prototype.parse=function(n,t){this._errors=[],this.filename=t||"eval",this.currentNamespace=[""],this.extractDoc?this._docs=[]:this._docs=null,this.extractTokens?this._tokens=[]:this._tokens=null,this._docIndex=0,this._lastNode=null,this.lexer.setInput(n),this.lexer.all_tokens=this.extractTokens,this.lexer.comment_tokens=this.extractDoc,this.length=this.lexer._input.length,this.innerList=!1,this.innerListForm=!1;const e=this.node("program"),a=[];for(this.next();this.token!=this.EOF;)a.push(this.read_start());0===a.length&&this.extractDoc&&this._docs.length>this._docIndex&&a.push(this.node("noop")()),this.prev=[this.lexer.yylloc.last_line,this.lexer.yylloc.last_column,this.lexer.offset];const i=e(a,this._errors,this._docs,this._tokens);if(this.debug){const n=this.ast.checkNodes();if(n.length>0)throw n.forEach((function(n){n.position&&console.log("Node at line "+n.position.line+", column "+n.position.column),console.log(n.stack.join("\n"))})),new Error("Some nodes are not closed")}return i},i.prototype.raiseError=function(n,t,e,a){if(n+=" on line "+this.lexer.yylloc.first_line,!this.suppressErrors){const t=new SyntaxError(n,this.filename,this.lexer.yylloc.first_line);throw t.lineNumber=this.lexer.yylloc.first_line,t.fileName=this.filename,t.columnNumber=this.lexer.yylloc.first_column,t}const i=this.ast.prepare("error",null,this)(n,a,this.lexer.yylloc.first_line,e);return this._errors.push(i),i},i.prototype.error=function(n){let t="Parse Error : syntax error",e=this.getTokenName(this.token),i="";if(this.token!==this.EOF){if(a(this.token)){let n=this.text();n.length>10&&(n=n.substring(0,7)+"..."),e="'"+n+"' ("+e+")"}t+=", unexpected "+e}return n&&!Array.isArray(n)&&((a(n)||1===n.length)&&(i=", expecting "+this.getTokenName(n)),t+=i),this.raiseError(t,i,n,e)},i.prototype.node=function(n){if(this.extractDoc){let t=null;this._docIndex<this._docs.length&&(t=this._docs.slice(this._docIndex),this._docIndex=this._docs.length,this.debug&&(console.log(new Error("Append docs on "+n)),console.log(t)));const e=this.ast.prepare(n,t,this);return e.postBuild=function(n){if(this._docIndex<this._docs.length)if(this._lastNode){const n=this.prev[2];let t=this._docIndex;for(;t<this._docs.length&&!(this._docs[t].offset>n);t++);t>this._docIndex&&(this._lastNode.setTrailingComments(this._docs.slice(this._docIndex,t)),this._docIndex=t)}else this.token===this.EOF&&(n.setTrailingComments(this._docs.slice(this._docIndex)),this._docIndex=this._docs.length);this._lastNode=n}.bind(this),e}return this.ast.prepare(n,null,this)},i.prototype.expectEndOfStatement=function(n){if(";"===this.token)n&&";"===this.lexer.yytext&&n.includeToken(this);else if(this.token!==this.tok.T_INLINE_HTML&&this.token!==this.EOF)return this.error(";"),!1;return this.next(),!0};const r=["parser.next","parser.node","parser.showlog"];i.prototype.showlog=function(){const n=(new Error).stack.split("\n");let t;for(let e=2;e<n.length;e++){t=n[e].trim();let a=!1;for(let n=0;n<r.length;n++)if(t.substring(3,3+r[n].length)===r[n]){a=!0;break}if(!a)break}return console.log("Line "+this.lexer.yylloc.first_line+" : "+this.getTokenName(this.token)+">"+this.lexer.yytext+"< @--\x3e"+t),this},i.prototype.expect=function(n){if(Array.isArray(n)){if(-1===n.indexOf(this.token))return this.error(n),!1}else if(this.token!=n)return this.error(n),!1;return!0},i.prototype.text=function(){return this.lexer.yytext},i.prototype.next=function(){if(";"===this.token&&";"!==this.lexer.yytext||(this.prev=[this.lexer.yylloc.last_line,this.lexer.yylloc.last_column,this.lexer.offset]),this.lex(),this.debug&&this.showlog(),this.extractDoc)for(;this.token===this.tok.T_COMMENT||this.token===this.tok.T_DOC_COMMENT;)this.token===this.tok.T_COMMENT?this._docs.push(this.read_comment()):this._docs.push(this.read_doc_comment());return this},i.prototype.lex=function(){if(this.extractTokens)do{if(this.token=this.lexer.lex()||this.EOF,this.token===this.EOF)return this;let n=this.lexer.yytext;if(n=this.lexer.engine.tokens.values.hasOwnProperty(this.token)?[this.lexer.engine.tokens.values[this.token],n,this.lexer.yylloc.first_line,this.lexer.yylloc.first_offset,this.lexer.offset]:[null,n,this.lexer.yylloc.first_line,this.lexer.yylloc.first_offset,this.lexer.offset],this._tokens.push(n),this.token===this.tok.T_CLOSE_TAG)return this.token=";",this;if(this.token===this.tok.T_OPEN_TAG_WITH_ECHO)return this.token=this.tok.T_ECHO,this}while(this.token===this.tok.T_WHITESPACE||!this.extractDoc&&(this.token===this.tok.T_COMMENT||this.token===this.tok.T_DOC_COMMENT)||this.token===this.tok.T_OPEN_TAG);else this.token=this.lexer.lex()||this.EOF;return this},i.prototype.is=function(n){return Array.isArray(n)?-1!==n.indexOf(this.token):this.entries[n].has(this.token)},[e(28),e(29),e(30),e(31),e(32),e(33),e(34),e(35),e(36),e(37),e(38),e(39),e(40),e(41),e(42)].forEach((function(n){for(const t in n){if(i.prototype.hasOwnProperty(t))throw new Error("Function "+t+" is already defined - collision");i.prototype[t]=n[t]}})),n.exports=i},function(n,t,e){"use strict";n.exports={read_array:function(){let n=null,t=!1;const e=this.node("array");this.token===this.tok.T_ARRAY?(this.next().expect("("),n=")"):(t=!0,n="]");let a=[];return this.next().token!==n&&(a=this.read_array_pair_list(t)),this.expect(n),this.next(),e(t,a)},read_array_pair_list:function(n){const t=this;return this.read_list((function(){return t.read_array_pair(n)}),",",!0)},read_array_pair:function(n){if(!n&&")"===this.token||n&&"]"===this.token)return;if(","===this.token)return this.node("noop")();const t=this.node("entry");let e=null,a=null,i=!1,r=!1;if("&"===this.token)this.next(),i=!0,a=this.read_variable(!0,!1);else if(this.token===this.tok.T_ELLIPSIS&&this.version>=704)this.next(),"&"===this.token&&this.error(),r=!0,a=this.read_expr();else{const n=this.read_expr();this.token===this.tok.T_DOUBLE_ARROW?(this.next(),e=n,"&"===this.token?(this.next(),i=!0,a=this.read_variable(!0,!1)):a=this.read_expr()):a=n}return t(e,a,i,r)}}},function(n,t,e){"use strict";n.exports={read_class_declaration_statement:function(){const n=this.node("class"),t=this.read_class_modifiers();if(this.token!==this.tok.T_CLASS)return this.error(this.tok.T_CLASS),this.next(),null;this.next().expect(this.tok.T_STRING);let e=this.node("identifier");const a=this.text();this.next(),e=e(a);const i=this.read_extends_from(),r=this.read_implements_list();this.expect("{");return n(e,i,r,this.next().read_class_body(),t)},read_class_modifiers:function(){return[0,0,this.read_class_modifier()]},read_class_modifier:function(){return this.token===this.tok.T_ABSTRACT?(this.next(),1):this.token===this.tok.T_FINAL?(this.next(),2):0},read_class_body:function(){let n=[];for(;this.token!==this.EOF&&"}"!==this.token;){if(this.token===this.tok.T_COMMENT){n.push(this.read_comment());continue}if(this.token===this.tok.T_DOC_COMMENT){n.push(this.read_doc_comment());continue}if(this.token===this.tok.T_USE){n=n.concat(this.read_trait_use_statement());continue}const t=this.read_member_flags(!1);if(this.token!==this.tok.T_CONST)if(this.token===this.tok.T_VAR&&(this.next().expect(this.tok.T_VARIABLE),t[0]=null,t[1]=0),this.token===this.tok.T_FUNCTION)n.push(this.read_function(!1,t));else if(this.token===this.tok.T_VARIABLE||this.version>=704&&("?"===this.token||this.token===this.tok.T_CALLABLE||this.token===this.tok.T_ARRAY||this.token===this.tok.T_NS_SEPARATOR||this.token===this.tok.T_STRING||this.token===this.tok.T_NAMESPACE)){const e=this.read_variable_list(t);this.expect(";"),this.next(),n=n.concat(e)}else this.error([this.tok.T_CONST,this.tok.T_VARIABLE,this.tok.T_FUNCTION]),this.next();else{const e=this.read_constant_list(t);this.expect(";")&&this.next(),n=n.concat(e)}}return this.expect("}"),this.next(),n},read_variable_list:function(n){const t=this.node("propertystatement"),e=this.read_list((function(){const n=this.node("property"),[t,e]=this.read_optional_type();this.expect(this.tok.T_VARIABLE);let a=this.node("identifier");const i=this.text().substring(1);return this.next(),a=a(i),";"===this.token||","===this.token?n(a,null,t,e):"="===this.token?n(a,this.next().read_expr(),t,e):(this.expect([",",";","="]),n(a,null,t,e))}),",");return t(null,e,n)},read_constant_list:function(n){this.expect(this.tok.T_CONST)&&this.next();const t=this.node("classconstant"),e=this.read_list((function(){const n=this.node("constant");let t=null,e=null;if(this.token===this.tok.T_STRING||this.version>=700&&this.is("IDENTIFIER")){t=this.node("identifier");const n=this.text();this.next(),t=t(n)}else this.expect("IDENTIFIER");return this.expect("=")&&(e=this.next().read_expr()),n(t,e)}),",");return t(null,e,n)},read_member_flags:function(n){const t=[-1,-1,-1];if(this.is("T_MEMBER_FLAGS")){let e=0,a=0;do{switch(this.token){case this.tok.T_PUBLIC:e=0,a=0;break;case this.tok.T_PROTECTED:e=0,a=1;break;case this.tok.T_PRIVATE:e=0,a=2;break;case this.tok.T_STATIC:e=1,a=1;break;case this.tok.T_ABSTRACT:e=2,a=1;break;case this.tok.T_FINAL:e=2,a=2}n&&(0==e&&2==a?(this.expect([this.tok.T_PUBLIC,this.tok.T_PROTECTED]),a=-1):2==e&&1==a&&(this.error(),a=-1)),-1!==t[e]?this.error():-1!==a&&(t[e]=a)}while(this.next().is("T_MEMBER_FLAGS"))}return-1==t[1]&&(t[1]=0),-1==t[2]&&(t[2]=0),t},read_optional_type:function(){let n=!1;"?"===this.token&&(n=!0,this.next());let t=this.read_type();if(n&&!t&&this.raiseError("Expecting a type definition combined with nullable operator"),!n&&!t)return[!1,null];if("|"===this.token){t=[t];do{this.next();const n=this.read_type();if(!n){this.raiseError("Expecting a type definition");break}t.push(n)}while("|"===this.token)}return[n,t]},read_interface_declaration_statement:function(){const n=this.node("interface");if(this.token!==this.tok.T_INTERFACE)return this.error(this.tok.T_INTERFACE),this.next(),null;this.next().expect(this.tok.T_STRING);let t=this.node("identifier");const e=this.text();this.next(),t=t(e);const a=this.read_interface_extends_list();this.expect("{");return n(t,a,this.next().read_interface_body())},read_interface_body:function(){let n=[];for(;this.token!==this.EOF&&"}"!==this.token;){if(this.token===this.tok.T_COMMENT){n.push(this.read_comment());continue}if(this.token===this.tok.T_DOC_COMMENT){n.push(this.read_doc_comment());continue}const t=this.read_member_flags(!0);if(this.token==this.tok.T_CONST){const e=this.read_constant_list(t);this.expect(";")&&this.next(),n=n.concat(e)}else if(this.token===this.tok.T_FUNCTION){const e=this.read_function_declaration(2,t);e.parseFlags(t),n.push(e),this.expect(";")&&this.next()}else this.error([this.tok.T_CONST,this.tok.T_FUNCTION]),this.next()}return this.expect("}")&&this.next(),n},read_trait_declaration_statement:function(){const n=this.node("trait");if(this.token!==this.tok.T_TRAIT)return this.error(this.tok.T_TRAIT),this.next(),null;this.next().expect(this.tok.T_STRING);let t=this.node("identifier");const e=this.text();this.next(),t=t(e),this.expect("{");return n(t,this.next().read_class_body())},read_trait_use_statement:function(){const n=this.node("traituse");this.expect(this.tok.T_USE)&&this.next();const t=[this.read_namespace_name()];let e=null;for(;","===this.token;)t.push(this.next().read_namespace_name());if("{"===this.token){for(e=[];this.next().token!==this.EOF&&"}"!==this.token;)e.push(this.read_trait_use_alias()),this.expect(";");this.expect("}")&&this.next()}else this.expect(";")&&this.next();return n(t,e)},read_trait_use_alias:function(){const n=this.node();let t,e=null;if(this.is("IDENTIFIER")){t=this.node("identifier");const n=this.text();this.next(),t=t(n)}else if(t=this.read_namespace_name(),this.token===this.tok.T_DOUBLE_COLON)if(this.next(),this.token===this.tok.T_STRING||this.version>=700&&this.is("IDENTIFIER")){e=t,t=this.node("identifier");const n=this.text();this.next(),t=t(n)}else this.expect(this.tok.T_STRING);else t=t.name;if(this.token===this.tok.T_INSTEADOF)return n("traitprecedence",e,t,this.next().read_name_list());if(this.token===this.tok.T_AS){let a=null,i=null;if(this.next().is("T_MEMBER_FLAGS")&&(a=this.read_member_flags()),this.token===this.tok.T_STRING||this.version>=700&&this.is("IDENTIFIER")){i=this.node("identifier");const n=this.text();this.next(),i=i(n)}else!1===a&&this.expect(this.tok.T_STRING);return n("traitalias",e,t,i,a)}return this.expect([this.tok.T_AS,this.tok.T_INSTEADOF]),n("traitalias",e,t,null,null)}}},function(n,t,e){"use strict";n.exports={read_comment:function(){const n=this.text();let t=this.ast.prepare("/*"===n.substring(0,2)?"commentblock":"commentline",null,this);const e=this.lexer.yylloc.first_offset,a=this.prev;return this.prev=[this.lexer.yylloc.last_line,this.lexer.yylloc.last_column,this.lexer.offset],this.lex(),t=t(n),t.offset=e,this.prev=a,t},read_doc_comment:function(){let n=this.ast.prepare("commentblock",null,this);const t=this.lexer.yylloc.first_offset,e=this.text(),a=this.prev;return this.prev=[this.lexer.yylloc.last_line,this.lexer.yylloc.last_column,this.lexer.offset],this.lex(),n=n(e),n.offset=t,this.prev=a,n}}},function(n,t,e){"use strict";n.exports={read_expr:function(n){const t=this.node();if("@"===this.token)return n||(n=this.next().read_expr()),t("silent",n);if(n||(n=this.read_expr_item()),"|"===this.token)return t("bin","|",n,this.next().read_expr());if("&"===this.token)return t("bin","&",n,this.next().read_expr());if("^"===this.token)return t("bin","^",n,this.next().read_expr());if("."===this.token)return t("bin",".",n,this.next().read_expr());if("+"===this.token)return t("bin","+",n,this.next().read_expr());if("-"===this.token)return t("bin","-",n,this.next().read_expr());if("*"===this.token)return t("bin","*",n,this.next().read_expr());if("/"===this.token)return t("bin","/",n,this.next().read_expr());if("%"===this.token)return t("bin","%",n,this.next().read_expr());if(this.token===this.tok.T_POW)return t("bin","**",n,this.next().read_expr());if(this.token===this.tok.T_SL)return t("bin","<<",n,this.next().read_expr());if(this.token===this.tok.T_SR)return t("bin",">>",n,this.next().read_expr());if(this.token===this.tok.T_BOOLEAN_OR)return t("bin","||",n,this.next().read_expr());if(this.token===this.tok.T_LOGICAL_OR)return t("bin","or",n,this.next().read_expr());if(this.token===this.tok.T_BOOLEAN_AND)return t("bin","&&",n,this.next().read_expr());if(this.token===this.tok.T_LOGICAL_AND)return t("bin","and",n,this.next().read_expr());if(this.token===this.tok.T_LOGICAL_XOR)return t("bin","xor",n,this.next().read_expr());if(this.token===this.tok.T_IS_IDENTICAL)return t("bin","===",n,this.next().read_expr());if(this.token===this.tok.T_IS_NOT_IDENTICAL)return t("bin","!==",n,this.next().read_expr());if(this.token===this.tok.T_IS_EQUAL)return t("bin","==",n,this.next().read_expr());if(this.token===this.tok.T_IS_NOT_EQUAL)return t("bin","!=",n,this.next().read_expr());if("<"===this.token)return t("bin","<",n,this.next().read_expr());if(">"===this.token)return t("bin",">",n,this.next().read_expr());if(this.token===this.tok.T_IS_SMALLER_OR_EQUAL)return t("bin","<=",n,this.next().read_expr());if(this.token===this.tok.T_IS_GREATER_OR_EQUAL)return t("bin",">=",n,this.next().read_expr());if(this.token===this.tok.T_SPACESHIP)return t("bin","<=>",n,this.next().read_expr());if(this.token===this.tok.T_INSTANCEOF&&(n=t("bin","instanceof",n,this.next().read_class_name_reference()),";"!==this.token&&this.token!==this.tok.T_INLINE_HTML&&this.token!==this.EOF&&(n=this.read_expr(n))),this.token===this.tok.T_COALESCE)return t("bin","??",n,this.next().read_expr());if("?"===this.token){let e=null;return":"!==this.next().token&&(e=this.read_expr()),this.expect(":")&&this.next(),t("retif",n,e,this.read_expr())}return t.destroy(n),n},read_expr_cast:function(n){return this.node("cast")(n,this.text(),this.next().read_expr())},read_isset_variable:function(){return this.read_expr()},read_isset_variables:function(){return this.read_function_list(this.read_isset_variable,",")},read_internal_functions_in_yacc:function(){let n=null;switch(this.token){case this.tok.T_ISSET:{n=this.node("isset"),this.next().expect("(")&&this.next();const t=this.read_isset_variables();this.expect(")")&&this.next(),n=n(t)}break;case this.tok.T_EMPTY:{n=this.node("empty"),this.next().expect("(")&&this.next();const t=this.read_expr();this.expect(")")&&this.next(),n=n(t)}break;case this.tok.T_INCLUDE:n=this.node("include")(!1,!1,this.next().read_expr());break;case this.tok.T_INCLUDE_ONCE:n=this.node("include")(!0,!1,this.next().read_expr());break;case this.tok.T_EVAL:{n=this.node("eval"),this.next().expect("(")&&this.next();const t=this.read_expr();this.expect(")")&&this.next(),n=n(t)}break;case this.tok.T_REQUIRE:n=this.node("include")(!1,!0,this.next().read_expr());break;case this.tok.T_REQUIRE_ONCE:n=this.node("include")(!0,!0,this.next().read_expr())}return n},read_optional_expr:function(n){return this.token!==n?this.read_expr():null},read_exit_expr:function(){let n=null;return"("===this.token&&(this.next(),n=this.read_optional_expr(")"),this.expect(")")&&this.next()),n},read_expr_item:function(){let n,t;if("+"===this.token)return this.node("unary")("+",this.next().read_expr());if("-"===this.token)return this.node("unary")("-",this.next().read_expr());if("!"===this.token)return this.node("unary")("!",this.next().read_expr());if("~"===this.token)return this.node("unary")("~",this.next().read_expr());if("("===this.token)return t=this.next().read_expr(),t.parenthesizedExpression=!0,this.expect(")")&&this.next(),this.handleDereferencable(t);if("`"===this.token)return this.read_encapsed_string("`");if(this.token===this.tok.T_LIST){let t=null;const e=this.innerList;n=this.node("list"),e||(t=this.node("assign")),this.next().expect("(")&&this.next(),this.innerList||(this.innerList=!0);const a=this.read_array_pair_list(!1);this.expect(")")&&this.next();let i=!1;for(let n=0;n<a.length;n++)if(null!==a[n]&&"noop"!==a[n].kind){i=!0;break}return i||this.raiseError("Fatal Error :  Cannot use empty list on line "+this.lexer.yylloc.first_line),e?n(a,!1):(this.innerList=!1,this.expect("=")?t(n(a,!1),this.next().read_expr(),"="):n(a,!1))}if(this.token===this.tok.T_CLONE)return this.node("clone")(this.next().read_expr());switch(this.token){case this.tok.T_INC:return this.node("pre")("+",this.next().read_variable(!1,!1));case this.tok.T_DEC:return this.node("pre")("-",this.next().read_variable(!1,!1));case this.tok.T_NEW:return this.read_new_expr();case this.tok.T_ISSET:case this.tok.T_EMPTY:case this.tok.T_INCLUDE:case this.tok.T_INCLUDE_ONCE:case this.tok.T_EVAL:case this.tok.T_REQUIRE:case this.tok.T_REQUIRE_ONCE:return this.read_internal_functions_in_yacc();case this.tok.T_INT_CAST:return this.read_expr_cast("int");case this.tok.T_DOUBLE_CAST:return this.read_expr_cast("float");case this.tok.T_STRING_CAST:return this.read_expr_cast(-1!==this.text().indexOf("binary")?"binary":"string");case this.tok.T_ARRAY_CAST:return this.read_expr_cast("array");case this.tok.T_OBJECT_CAST:return this.read_expr_cast("object");case this.tok.T_BOOL_CAST:return this.read_expr_cast("bool");case this.tok.T_UNSET_CAST:return this.read_expr_cast("unset");case this.tok.T_EXIT:{const t="die"===this.lexer.yytext.toLowerCase();n=this.node("exit"),this.next();return n(this.read_exit_expr(),t)}case this.tok.T_PRINT:return this.node("print")(this.next().read_expr());case this.tok.T_YIELD:{let t=null,e=null;return n=this.node("yield"),this.next().is("EXPR")&&(t=this.read_expr(),this.token===this.tok.T_DOUBLE_ARROW&&(e=t,t=this.next().read_expr())),n(t,e)}case this.tok.T_YIELD_FROM:return n=this.node("yieldfrom"),t=this.next().read_expr(),n(t);case this.tok.T_FN:case this.tok.T_FUNCTION:return this.read_inline_function();case this.tok.T_STATIC:{const n=[this.token,this.lexer.getState()];if(this.next(),this.token===this.tok.T_FUNCTION||this.version>=704&&this.token===this.tok.T_FN)return this.read_inline_function([0,1,0]);this.lexer.tokens.push(n),this.next()}}if(this.is("VARIABLE")){n=this.node(),t=this.read_variable(!1,!1);const e="identifier"===t.kind||"staticlookup"===t.kind&&"identifier"===t.offset.kind;switch(this.token){case"=":return e&&this.error("VARIABLE"),"&"==this.next().token?this.read_assignref(n,t):n("assign",t,this.read_expr(),"=");case this.tok.T_PLUS_EQUAL:return e&&this.error("VARIABLE"),n("assign",t,this.next().read_expr(),"+=");case this.tok.T_MINUS_EQUAL:return e&&this.error("VARIABLE"),n("assign",t,this.next().read_expr(),"-=");case this.tok.T_MUL_EQUAL:return e&&this.error("VARIABLE"),n("assign",t,this.next().read_expr(),"*=");case this.tok.T_POW_EQUAL:return e&&this.error("VARIABLE"),n("assign",t,this.next().read_expr(),"**=");case this.tok.T_DIV_EQUAL:return e&&this.error("VARIABLE"),n("assign",t,this.next().read_expr(),"/=");case this.tok.T_CONCAT_EQUAL:return e&&this.error("VARIABLE"),n("assign",t,this.next().read_expr(),".=");case this.tok.T_MOD_EQUAL:return e&&this.error("VARIABLE"),n("assign",t,this.next().read_expr(),"%=");case this.tok.T_AND_EQUAL:return e&&this.error("VARIABLE"),n("assign",t,this.next().read_expr(),"&=");case this.tok.T_OR_EQUAL:return e&&this.error("VARIABLE"),n("assign",t,this.next().read_expr(),"|=");case this.tok.T_XOR_EQUAL:return e&&this.error("VARIABLE"),n("assign",t,this.next().read_expr(),"^=");case this.tok.T_SL_EQUAL:return e&&this.error("VARIABLE"),n("assign",t,this.next().read_expr(),"<<=");case this.tok.T_SR_EQUAL:return e&&this.error("VARIABLE"),n("assign",t,this.next().read_expr(),">>=");case this.tok.T_COALESCE_EQUAL:return e&&this.error("VARIABLE"),n("assign",t,this.next().read_expr(),"??=");case this.tok.T_INC:return e&&this.error("VARIABLE"),this.next(),n("post","+",t);case this.tok.T_DEC:return e&&this.error("VARIABLE"),this.next(),n("post","-",t);default:n.destroy(t)}}else{if(this.is("SCALAR")){if(n=this.node(),t=this.read_scalar(),"array"===t.kind&&t.shortForm&&"="===this.token){const e=this.node("list")(t.items,!0);t.loc&&(e.loc=t.loc);return n("assign",e,this.next().read_expr(),"=")}return n.destroy(t),this.handleDereferencable(t)}this.error("EXPR"),this.next()}return t},read_assignref:function(n,t){let e;return this.next(),this.token===this.tok.T_NEW?(this.version>=700&&this.error(),e=this.read_new_expr()):e=this.read_variable(!1,!1),n("assignref",t,e)},read_inline_function:function(n){if(this.token===this.tok.T_FUNCTION)return this.read_function(!0,n);!this.version>=704&&this.raiseError("Arrow Functions are not allowed");const t=this.node("arrowfunc");this.expect(this.tok.T_FN)&&this.next();const e=this.is_reference();this.expect("(")&&this.next();const a=this.read_parameter_list();this.expect(")")&&this.next();let i=!1,r=null;":"===this.token&&("?"===this.next().token&&(i=!0,this.next()),r=this.read_type()),this.expect(this.tok.T_DOUBLE_ARROW)&&this.next();return t(a,e,this.read_expr(),r,i,!!n)},read_new_expr:function(){const n=this.node("new");this.expect(this.tok.T_NEW)&&this.next();let t=[];if(this.token===this.tok.T_CLASS){const e=this.node("class");"("===this.next().token&&(t=this.read_argument_list());const a=this.read_extends_from(),i=this.read_implements_list();let r=null;return this.expect("{")&&(r=this.next().read_class_body()),n(e(null,a,i,r,[0,0,0]),t)}const e=this.read_new_class_name();return"("===this.token&&(t=this.read_argument_list()),n(e,t)},read_new_class_name:function(){if(this.token===this.tok.T_NS_SEPARATOR||this.token===this.tok.T_STRING||this.token===this.tok.T_NAMESPACE){let n=this.read_namespace_name(!0);return this.token===this.tok.T_DOUBLE_COLON&&(n=this.read_static_getter(n)),n}if(this.is("VARIABLE"))return this.read_variable(!0,!1);this.expect([this.tok.T_STRING,"VARIABLE"])},handleDereferencable:function(n){for(;this.token!==this.EOF;)if(this.token===this.tok.T_OBJECT_OPERATOR||this.token===this.tok.T_DOUBLE_COLON)n=this.recursive_variable_chain_scan(n,!1,!1,!0);else if(this.token===this.tok.T_CURLY_OPEN||"["===this.token)n=this.read_dereferencable(n);else{if("("!==this.token)return n;n=this.node("call")(n,this.read_argument_list())}return n}}},function(n,t,e){"use strict";n.exports={is_reference:function(){return"&"==this.token&&(this.next(),!0)},is_variadic:function(){return this.token===this.tok.T_ELLIPSIS&&(this.next(),!0)},read_function:function(n,t){const e=this.read_function_declaration(n?1:t?2:0,t&&1===t[1]);return t&&1==t[2]?(e.parseFlags(t),this.expect(";")&&this.next()):(this.expect("{")&&(e.body=this.read_code_block(!1),e.loc&&e.body.loc&&(e.loc.end=e.body.loc.end)),!n&&t&&e.parseFlags(t)),e},read_function_declaration:function(n,t){let e="function";1===n?e="closure":2===n&&(e="method");const a=this.node(e);this.expect(this.tok.T_FUNCTION)&&this.next();const i=this.is_reference();let r=!1,s=[],o=null,c=!1;if(1!==n){const t=this.node("identifier");2===n?this.version>=700?this.token===this.tok.T_STRING||this.is("IDENTIFIER")?(r=this.text(),this.next()):this.version<704&&this.error("IDENTIFIER"):this.token===this.tok.T_STRING?(r=this.text(),this.next()):this.error("IDENTIFIER"):this.version>=700?this.token===this.tok.T_STRING?(r=this.text(),this.next()):this.version>=704?this.expect("(")||this.next():(this.error(this.tok.T_STRING),this.next()):(this.expect(this.tok.T_STRING)&&(r=this.text()),this.next()),r=t(r)}this.expect("(")&&this.next();const l=this.read_parameter_list();return this.expect(")")&&this.next(),1===n&&(s=this.read_lexical_vars()),":"===this.token&&("?"===this.next().token&&(c=!0,this.next()),o=this.read_type()),1===n?a(l,i,s,o,c,t):a(r,l,i,o,c)},read_lexical_vars:function(){let n=[];return this.token===this.tok.T_USE&&(this.next(),this.expect("(")&&this.next(),n=this.read_lexical_var_list(),this.expect(")")&&this.next()),n},read_lexical_var_list:function(){return this.read_list(this.read_lexical_var,",")},read_lexical_var:function(){if("&"===this.token)return this.read_byref(this.read_lexical_var.bind(this));const n=this.node("variable");this.expect(this.tok.T_VARIABLE);const t=this.text().substring(1);return this.next(),n(t,!1)},read_parameter_list:function(){const n=[];if(")"!=this.token)for(;this.token!=this.EOF;){if(n.push(this.read_parameter()),","!=this.token){if(")"==this.token)break;this.error([",",")"]);break}this.next()}return n},read_parameter:function(){const n=this.node("parameter");let t=null,e=null,a=null,i=!1;"?"===this.token&&(this.next(),i=!0),a=this.read_type(),i&&!a&&this.raiseError("Expecting a type definition combined with nullable operator");const r=this.is_reference(),s=this.is_variadic();if(this.expect(this.tok.T_VARIABLE)){t=this.node("identifier");const n=this.text().substring(1);this.next(),t=t(n)}return"="==this.token&&(e=this.next().read_expr()),n(t,a,e,r,s,i)},read_argument_list:function(){let n=[];return this.expect("(")&&this.next(),")"!==this.token&&(n=this.read_non_empty_argument_list()),this.expect(")")&&this.next(),n},read_non_empty_argument_list:function(){let n=!1;return this.read_function_list(function(){const t=this.read_argument();return t&&(n&&this.raiseError("Unexpected argument after a variadic argument"),"variadic"===t.kind&&(n=!0)),t}.bind(this),",")},read_argument:function(){return this.token===this.tok.T_ELLIPSIS?this.node("variadic")(this.next().read_expr()):this.read_expr()},read_type:function(){const n=this.node();if(this.token===this.tok.T_ARRAY||this.token===this.tok.T_CALLABLE){const t=this.text();return this.next(),n("typereference",t.toLowerCase(),t)}if(this.token===this.tok.T_STRING){const t=this.text(),e=[this.token,this.lexer.getState()];return this.next(),this.token!==this.tok.T_NS_SEPARATOR&&this.ast.typereference.types.indexOf(t.toLowerCase())>-1?n("typereference",t.toLowerCase(),t):(this.lexer.tokens.push(e),this.next(),n.destroy(),this.read_namespace_name())}return this.token===this.tok.T_NAMESPACE||this.token===this.tok.T_NS_SEPARATOR?(n.destroy(),this.read_namespace_name()):(n.destroy(),null)}}},function(n,t,e){"use strict";n.exports={read_if:function(){const n=this.node("if"),t=this.next().read_if_expr();let e=null,a=null,i=!1;if(":"===this.token){i=!0,this.next(),e=this.node("block");const n=[];for(;this.token!==this.EOF&&this.token!==this.tok.T_ENDIF;){if(this.token===this.tok.T_ELSEIF){a=this.read_elseif_short();break}if(this.token===this.tok.T_ELSE){a=this.read_else_short();break}n.push(this.read_inner_statement())}e=e(null,n),this.expect(this.tok.T_ENDIF)&&this.next(),this.expectEndOfStatement()}else e=this.read_statement(),this.token===this.tok.T_ELSEIF?a=this.read_if():this.token===this.tok.T_ELSE&&(a=this.next().read_statement());return n(t,e,a,i)},read_if_expr:function(){this.expect("(")&&this.next();const n=this.read_expr();return this.expect(")")&&this.next(),n},read_elseif_short:function(){let n=null;const t=this.node("if"),e=this.next().read_if_expr();this.expect(":")&&this.next();const a=this.node("block"),i=[];for(;this.token!=this.EOF&&this.token!==this.tok.T_ENDIF;){if(this.token===this.tok.T_ELSEIF){n=this.read_elseif_short();break}if(this.token===this.tok.T_ELSE){n=this.read_else_short();break}i.push(this.read_inner_statement())}return t(e,a(null,i),n,!0)},read_else_short:function(){this.next().expect(":")&&this.next();const n=this.node("block"),t=[];for(;this.token!=this.EOF&&this.token!==this.tok.T_ENDIF;)t.push(this.read_inner_statement());return n(null,t)}}},function(n,t,e){"use strict";n.exports={read_while:function(){const n=this.node("while");this.expect(this.tok.T_WHILE)&&this.next();let t=null,e=null,a=!1;return this.expect("(")&&this.next(),t=this.read_expr(),this.expect(")")&&this.next(),":"===this.token?(a=!0,e=this.read_short_form(this.tok.T_ENDWHILE)):e=this.read_statement(),n(t,e,a)},read_do:function(){const n=this.node("do");this.expect(this.tok.T_DO)&&this.next();let t=null,e=null;return e=this.read_statement(),this.expect(this.tok.T_WHILE)&&(this.next().expect("(")&&this.next(),t=this.read_expr(),this.expect(")")&&this.next(),this.expect(";")&&this.next()),n(t,e)},read_for:function(){const n=this.node("for");this.expect(this.tok.T_FOR)&&this.next();let t=[],e=[],a=[],i=null,r=!1;return this.expect("(")&&this.next(),";"!==this.token?(t=this.read_list(this.read_expr,","),this.expect(";")&&this.next()):this.next(),";"!==this.token?(e=this.read_list(this.read_expr,","),this.expect(";")&&this.next()):this.next(),")"!==this.token?(a=this.read_list(this.read_expr,","),this.expect(")")&&this.next()):this.next(),":"===this.token?(r=!0,i=this.read_short_form(this.tok.T_ENDFOR)):i=this.read_statement(),n(t,e,a,i,r)},read_foreach:function(){const n=this.node("foreach");this.expect(this.tok.T_FOREACH)&&this.next();let t=null,e=null,a=null,i=null,r=!1;return this.expect("(")&&this.next(),t=this.read_expr(),this.expect(this.tok.T_AS)&&(this.next(),a=this.read_foreach_variable(),this.token===this.tok.T_DOUBLE_ARROW&&(e=a,a=this.next().read_foreach_variable())),e&&"list"===e.kind&&this.raiseError("Fatal Error : Cannot use list as key element"),this.expect(")")&&this.next(),":"===this.token?(r=!0,i=this.read_short_form(this.tok.T_ENDFOREACH)):i=this.read_statement(),n(t,e,a,i,r)},read_foreach_variable:function(){if(this.token===this.tok.T_LIST||"["===this.token){const n="["===this.token,t=this.node("list");this.next(),!n&&this.expect("(")&&this.next();const e=this.read_array_pair_list(n);return this.expect(n?"]":")")&&this.next(),t(e,n)}return this.read_variable(!1,!1)}}},function(n,t,e){"use strict";n.exports={read_start:function(){return this.token==this.tok.T_NAMESPACE?this.read_namespace():this.read_top_statement()}}},function(n,t,e){"use strict";n.exports={read_namespace:function(){const n=this.node("namespace");let t,e;return this.expect(this.tok.T_NAMESPACE)&&this.next(),e="{"==this.token?{name:[""]}:this.read_namespace_name(),this.currentNamespace=e,";"==this.token?(this.currentNamespace=e,t=this.next().read_top_statements(),this.expect(this.EOF),n(e.name,t,!1)):"{"==this.token?(this.currentNamespace=e,t=this.next().read_top_statements(),this.expect("}")&&this.next(),0===t.length&&this.extractDoc&&this._docs.length>this._docIndex&&t.push(this.node("noop")()),n(e.name,t,!0)):"("===this.token?(e.resolution=this.ast.reference.RELATIVE_NAME,e.name=e.name.substring(1),n.destroy(),this.node("call")(e,this.read_argument_list())):(this.error(["{",";"]),this.currentNamespace=e,t=this.read_top_statements(),this.expect(this.EOF),n(e,t,!1))},read_namespace_name:function(n){const t=this.node();let e=!1;this.token===this.tok.T_NAMESPACE&&(this.next().expect(this.tok.T_NS_SEPARATOR)&&this.next(),e=!0);const a=this.read_list(this.tok.T_STRING,this.tok.T_NS_SEPARATOR,!0);if(!e&&1===a.length&&(n||"("!==this.token)){if("parent"===a[0].toLowerCase())return t("parentreference",a[0]);if("self"===a[0].toLowerCase())return t("selfreference",a[0])}return t("name",a,e)},read_use_statement:function(){let n=this.node("usegroup"),t=[],e=null;this.expect(this.tok.T_USE)&&this.next();const a=this.read_use_type();return t.push(this.read_use_declaration(!1)),","===this.token?t=t.concat(this.next().read_use_declarations(!1)):"{"===this.token&&(e=t[0].name,t=this.next().read_use_declarations(null===a),this.expect("}")&&this.next()),n=n(e,a,t),this.expect(";")&&this.next(),n},read_class_name_reference:function(){return this.read_variable(!0,!1)},read_use_declaration:function(n){const t=this.node("useitem");let e=null;n&&(e=this.read_use_type());const a=this.read_namespace_name(),i=this.read_use_alias();return t(a.name,i,e)},read_use_declarations:function(n){const t=[this.read_use_declaration(n)];for(;","===this.token;){if(this.next(),n){if(this.token!==this.tok.T_FUNCTION&&this.token!==this.tok.T_CONST&&this.token!==this.tok.T_STRING)break}else if(this.token!==this.tok.T_STRING&&this.token!==this.tok.T_NS_SEPARATOR)break;t.push(this.read_use_declaration(n))}return t},read_use_alias:function(){let n=null;if(this.token===this.tok.T_AS&&this.next().expect(this.tok.T_STRING)){const t=this.node("identifier"),e=this.text();this.next(),n=t(e)}return n},read_use_type:function(){return this.token===this.tok.T_FUNCTION?(this.next(),this.ast.useitem.TYPE_FUNCTION):this.token===this.tok.T_CONST?(this.next(),this.ast.useitem.TYPE_CONST):null}}},function(n,t,e){"use strict";const a={"\\":"\\",$:"$",n:"\n",r:"\r",t:"\t",f:String.fromCharCode(12),v:String.fromCharCode(11),e:String.fromCharCode(27)};n.exports={resolve_special_chars:function(n,t){return t?n.replace(/\\"/,'"').replace(/\\([\\$nrtfve]|[xX][0-9a-fA-F]{1,2}|[0-7]{1,3}|u{([0-9a-fA-F]+)})/g,(n,t,e)=>a[t]?a[t]:"x"===t[0]||"X"===t[0]?String.fromCodePoint(parseInt(t.substr(1),16)):"u"===t[0]?String.fromCodePoint(parseInt(e,16)):String.fromCodePoint(parseInt(t,8))):n.replace(/\\\\/g,"\\").replace(/\\'/g,"'")},remove_heredoc_leading_whitespace_chars:function(n,t,e,a){if(0===t)return n;this.check_heredoc_indentation_level(n,t,e,a);const i=e?" ":"\t",r=new RegExp(`\\n${i}{${t}}`,"g"),s=new RegExp(`^${i}{${t}}`);return a&&(n=n.replace(s,"")),n.replace(r,"\n")},check_heredoc_indentation_level:function(n,t,e,a){const i=n.length;let r=0,s=0,o=!0;const c=e?" ":"\t";let l=!1;if(!a){if(r=n.indexOf("\n"),-1===r)return;r++}for(;r<i;)o?n[r]===c?s++:l=!0:o=!1,"\n"!==n[r]&&l&&s<t?this.raiseError(`Invalid body indentation level (expecting an indentation at least ${t})`):l=!1,"\n"===n[r]&&(o=!0,s=0),r++},read_dereferencable_scalar:function(){let n=null;switch(this.token){case this.tok.T_CONSTANT_ENCAPSED_STRING:{let t=this.node("string");const e=this.text();let a=0;"b"!==e[0]&&"B"!==e[0]||(a=1);const i='"'===e[a];this.next();t=t(i,this.resolve_special_chars(e.substring(a+1,e.length-1),i),1===a,e),n=this.token===this.tok.T_DOUBLE_COLON?this.read_static_getter(t):t}break;case this.tok.T_ARRAY:case"[":n=this.read_array()}return n},read_scalar:function(){if(this.is("T_MAGIC_CONST"))return this.get_magic_constant();{let n,t;switch(this.token){case this.tok.T_LNUMBER:case this.tok.T_DNUMBER:{const t=this.node("number");return n=this.text(),this.next(),t(n,null)}case this.tok.T_START_HEREDOC:if("ST_NOWDOC"===this.lexer.curCondition){const e=this.lexer.yylloc.first_offset;t=this.node("nowdoc"),n=this.next().text(),this.lexer.heredoc_label.indentation>0&&(n=n.substring(0,n.length-this.lexer.heredoc_label.indentation));const a=n[n.length-1];"\n"===a?n="\r"===n[n.length-2]?n.substring(0,n.length-2):n.substring(0,n.length-1):"\r"===a&&(n=n.substring(0,n.length-1)),this.expect(this.tok.T_ENCAPSED_AND_WHITESPACE)&&this.next(),this.expect(this.tok.T_END_HEREDOC)&&this.next();const i=this.lexer._input.substring(e,this.lexer.yylloc.first_offset);return t=t(this.remove_heredoc_leading_whitespace_chars(n,this.lexer.heredoc_label.indentation,this.lexer.heredoc_label.indentation_uses_spaces,this.lexer.heredoc_label.first_encaps_node),i,this.lexer.heredoc_label.label),t}return this.read_encapsed_string(this.tok.T_END_HEREDOC);case'"':return this.read_encapsed_string('"');case'b"':case'B"':return this.read_encapsed_string('"',!0);case this.tok.T_CONSTANT_ENCAPSED_STRING:case this.tok.T_ARRAY:case"[":return this.read_dereferencable_scalar();default:{const n=this.error("SCALAR");return this.next(),n}}}},read_dereferencable:function(n){let t,e;const a=this.node("offsetlookup");return"["===this.token?(e=this.next().read_expr(),this.expect("]")&&this.next(),t=a(n,e)):this.token===this.tok.T_DOLLAR_OPEN_CURLY_BRACES&&(e=this.read_encapsed_string_item(!1),t=a(n,e)),t},read_encapsed_string_item:function(n){const t=this.node("encapsedpart");let e,a,i,r=null,s=!1,o=this.node();if(this.token===this.tok.T_ENCAPSED_AND_WHITESPACE){const t=this.text();this.next(),o=o("string",!1,this.version>=703&&!this.lexer.heredoc_label.finished?this.remove_heredoc_leading_whitespace_chars(this.resolve_special_chars(t,n),this.lexer.heredoc_label.indentation,this.lexer.heredoc_label.indentation_uses_spaces,this.lexer.heredoc_label.first_encaps_node):t,!1,t)}else if(this.token===this.tok.T_DOLLAR_OPEN_CURLY_BRACES){if(r="simple",s=!0,i=null,this.next().token===this.tok.T_STRING_VARNAME){i=this.node("variable");const n=this.text();this.next(),"["===this.token?(i=i(n,!1),a=this.node("offsetlookup"),e=this.next().read_expr(),this.expect("]")&&this.next(),o=a(i,e)):o=i(n,!1)}else o=o("variable",this.read_expr(),!1);this.expect("}")&&this.next()}else if(this.token===this.tok.T_CURLY_OPEN)r="complex",o.destroy(),o=this.next().read_variable(!1,!1),this.expect("}")&&this.next();else if(this.token===this.tok.T_VARIABLE){if(r="simple",o.destroy(),o=this.read_simple_variable(),"["===this.token&&(a=this.node("offsetlookup"),e=this.next().read_encaps_var_offset(),this.expect("]")&&this.next(),o=a(o,e)),this.token===this.tok.T_OBJECT_OPERATOR){a=this.node("propertylookup"),this.next().expect(this.tok.T_STRING);const n=this.node("identifier");i=this.text(),this.next(),o=a(o,n(i))}}else{this.expect(this.tok.T_ENCAPSED_AND_WHITESPACE);const n=this.text();this.next(),o.destroy(),o=o("string",!1,n,!1,n)}return this.lexer.heredoc_label.first_encaps_node=!1,t(o,r,s)},read_encapsed_string:function(n,t=!1){const e=this.lexer.yylloc.first_offset;let a=this.node("encapsed");this.next();const i=this.lexer.yylloc.prev_offset-(t?1:0),r=[];let s=null;for(s="`"===n?this.ast.encapsed.TYPE_SHELL:'"'===n?this.ast.encapsed.TYPE_STRING:this.ast.encapsed.TYPE_HEREDOC;this.token!==n&&this.token!==this.EOF;)r.push(this.read_encapsed_string_item(!0));if(r.length>0&&"encapsedpart"===r[r.length-1].kind&&"string"===r[r.length-1].expression.kind){const n=r[r.length-1].expression,t=n.value[n.value.length-1];"\n"===t?"\r"===n.value[n.value.length-2]?n.value=n.value.substring(0,n.value.length-2):n.value=n.value.substring(0,n.value.length-1):"\r"===t&&(n.value=n.value.substring(0,n.value.length-1))}this.expect(n)&&this.next();return a=a(r,this.lexer._input.substring("heredoc"===s?e:i-1,this.lexer.yylloc.first_offset),s),n===this.tok.T_END_HEREDOC&&(a.label=this.lexer.heredoc_label.label,this.lexer.heredoc_label.finished=!0),a},get_magic_constant:function(){const n=this.node("magic"),t=this.text();return this.next(),n(t.toUpperCase(),t)}}},function(n,t,e){"use strict";n.exports={read_top_statements:function(){let n=[];for(;this.token!==this.EOF&&"}"!==this.token;){const t=this.read_top_statement();t&&(Array.isArray(t)?n=n.concat(t):n.push(t))}return n},read_top_statement:function(){switch(this.token){case this.tok.T_FUNCTION:return this.read_function(!1,!1);case this.tok.T_ABSTRACT:case this.tok.T_FINAL:case this.tok.T_CLASS:return this.read_class_declaration_statement();case this.tok.T_INTERFACE:return this.read_interface_declaration_statement();case this.tok.T_TRAIT:return this.read_trait_declaration_statement();case this.tok.T_USE:return this.read_use_statement();case this.tok.T_CONST:{const n=this.node("constantstatement"),t=this.next().read_const_list();return this.expectEndOfStatement(),n(null,t)}case this.tok.T_NAMESPACE:return this.read_namespace();case this.tok.T_HALT_COMPILER:{const n=this.node("halt");return this.next().expect("(")&&this.next(),this.expect(")")&&this.next(),this.expect(";"),this.lexer.done=!0,n(this.lexer._input.substring(this.lexer.offset))}default:return this.read_statement()}},read_inner_statements:function(){let n=[];for(;this.token!=this.EOF&&"}"!==this.token;){const t=this.read_inner_statement();t&&(Array.isArray(t)?n=n.concat(t):n.push(t))}return n},read_const_list:function(){return this.read_list((function(){this.expect(this.tok.T_STRING);const n=this.node("constant");let t=this.node("identifier");const e=this.text();return this.next(),t=t(e),this.expect("=")?n(t,this.next().read_expr()):n(t,null)}),",",!1)},read_declare_list:function(){const n=[];for(;this.token!=this.EOF&&")"!==this.token;){this.expect(this.tok.T_STRING);const t=this.node("declaredirective");let e=this.node("identifier");const a=this.text();this.next(),e=e(a);let i=null;if(this.expect("=")&&(i=this.next().read_expr()),n.push(t(e,i)),","!==this.token)break;this.next()}return n},read_inner_statement:function(){switch(this.token){case this.tok.T_FUNCTION:return this.read_function(!1,!1);case this.tok.T_ABSTRACT:case this.tok.T_FINAL:case this.tok.T_CLASS:return this.read_class_declaration_statement();case this.tok.T_INTERFACE:return this.read_interface_declaration_statement();case this.tok.T_TRAIT:return this.read_trait_declaration_statement();case this.tok.T_HALT_COMPILER:{this.raiseError("__HALT_COMPILER() can only be used from the outermost scope");let n=this.node("halt");return this.next().expect("(")&&this.next(),this.expect(")")&&this.next(),n=n(this.lexer._input.substring(this.lexer.offset)),this.expect(";")&&this.next(),n}default:return this.read_statement()}},read_statement:function(){switch(this.token){case"{":return this.read_code_block(!1);case this.tok.T_IF:return this.read_if();case this.tok.T_SWITCH:return this.read_switch();case this.tok.T_FOR:return this.read_for();case this.tok.T_FOREACH:return this.read_foreach();case this.tok.T_WHILE:return this.read_while();case this.tok.T_DO:return this.read_do();case this.tok.T_COMMENT:return this.read_comment();case this.tok.T_DOC_COMMENT:return this.read_doc_comment();case this.tok.T_RETURN:{const n=this.node("return");this.next();const t=this.read_optional_expr(";");return this.expectEndOfStatement(),n(t)}case this.tok.T_BREAK:case this.tok.T_CONTINUE:{const n=this.node(this.token===this.tok.T_CONTINUE?"continue":"break");this.next();const t=this.read_optional_expr(";");return this.expectEndOfStatement(),n(t)}case this.tok.T_GLOBAL:{const n=this.node("global"),t=this.next().read_list(this.read_simple_variable,",");return this.expectEndOfStatement(),n(t)}case this.tok.T_STATIC:{const n=[this.token,this.lexer.getState()],t=this.node();if(this.next().token===this.tok.T_DOUBLE_COLON){this.lexer.tokens.push(n);const e=this.next().read_expr();return this.expectEndOfStatement(e),t("expressionstatement",e)}if(this.token===this.tok.T_FUNCTION)return this.read_function(!0,[0,1,0]);const e=this.read_variable_declarations();return this.expectEndOfStatement(),t("static",e)}case this.tok.T_ECHO:{const n=this.node("echo"),t=this.text(),e="<?="===t||"<%="===t,a=this.next().read_function_list(this.read_expr,",");return this.expectEndOfStatement(),n(a,e)}case this.tok.T_INLINE_HTML:{const n=this.text();let t=this.lexer.yylloc.first_offset>0?this.lexer._input[this.lexer.yylloc.first_offset-1]:null;const e="\r"===t||"\n"===t;e&&"\n"===t&&this.lexer.yylloc.first_offset>1&&"\r"===this.lexer._input[this.lexer.yylloc.first_offset-2]&&(t="\r\n");const a=this.node("inline");return this.next(),a(n,e?t+n:n)}case this.tok.T_UNSET:{const n=this.node("unset");this.next().expect("(")&&this.next();const t=this.read_function_list(this.read_variable,",");return this.expect(")")&&this.next(),this.expect(";")&&this.next(),n(t)}case this.tok.T_DECLARE:{const n=this.node("declare"),t=[];let e;this.next().expect("(")&&this.next();const a=this.read_declare_list();if(this.expect(")")&&this.next(),":"===this.token){for(this.next();this.token!=this.EOF&&this.token!==this.tok.T_ENDDECLARE;)t.push(this.read_top_statement());0===t.length&&this.extractDoc&&this._docs.length>this._docIndex&&t.push(this.node("noop")()),this.expect(this.tok.T_ENDDECLARE)&&this.next(),this.expectEndOfStatement(),e=this.ast.declare.MODE_SHORT}else if("{"===this.token){for(this.next();this.token!=this.EOF&&"}"!==this.token;)t.push(this.read_top_statement());0===t.length&&this.extractDoc&&this._docs.length>this._docIndex&&t.push(this.node("noop")()),this.expect("}")&&this.next(),e=this.ast.declare.MODE_BLOCK}else this.expect(";")&&this.next(),e=this.ast.declare.MODE_NONE;return n(a,t,e)}case this.tok.T_TRY:return this.read_try();case this.tok.T_THROW:{const n=this.node("throw"),t=this.next().read_expr();return this.expectEndOfStatement(),n(t)}case";":return this.next(),null;case this.tok.T_STRING:{const n=this.node(),t=[this.token,this.lexer.getState()],e=this.text();let a=this.node("identifier");if(":"===this.next().token)return a=a(e),this.next(),n("label",a);a.destroy(),n.destroy(),this.lexer.tokens.push(t);const i=this.node("expressionstatement"),r=this.next().read_expr();return this.expectEndOfStatement(r),i(r)}case this.tok.T_GOTO:{const n=this.node("goto");let t=null;if(this.next().expect(this.tok.T_STRING)){t=this.node("identifier");const n=this.text();this.next(),t=t(n),this.expectEndOfStatement()}return n(t)}default:{const n=this.node("expressionstatement"),t=this.read_expr();return this.expectEndOfStatement(t),n(t)}}},read_code_block:function(n){const t=this.node("block");this.expect("{")&&this.next();const e=n?this.read_top_statements():this.read_inner_statements();return 0===e.length&&this.extractDoc&&this._docs.length>this._docIndex&&e.push(this.node("noop")()),this.expect("}")&&this.next(),t(null,e)}}},function(n,t,e){"use strict";n.exports={read_switch:function(){const n=this.node("switch");this.expect(this.tok.T_SWITCH)&&this.next(),this.expect("(")&&this.next();const t=this.read_expr();this.expect(")")&&this.next();const e=":"===this.token;return n(t,this.read_switch_case_list(),e)},read_switch_case_list:function(){let n=null;const t=this.node("block"),e=[];for("{"===this.token?n="}":":"===this.token?n=this.tok.T_ENDSWITCH:this.expect(["{",":"]),this.next(),";"===this.token&&this.next();this.token!==this.EOF&&this.token!==n;)e.push(this.read_case_list(n));return 0===e.length&&this.extractDoc&&this._docs.length>this._docIndex&&e.push(this.node("noop")()),this.expect(n)&&this.next(),n===this.tok.T_ENDSWITCH&&this.expectEndOfStatement(),t(null,e)},read_case_list:function(n){const t=this.node("case");let e=null;this.token===this.tok.T_CASE?e=this.next().read_expr():this.token===this.tok.T_DEFAULT?this.next():this.expect([this.tok.T_CASE,this.tok.T_DEFAULT]),this.expect([":",";"])&&this.next();const a=this.node("block"),i=[];for(;this.token!==this.EOF&&this.token!==n&&this.token!==this.tok.T_CASE&&this.token!==this.tok.T_DEFAULT;)i.push(this.read_inner_statement());return t(e,a(null,i))}}},function(n,t,e){"use strict";n.exports={read_try:function(){this.expect(this.tok.T_TRY);const n=this.node("try");let t=null;const e=[],a=this.next().read_statement();for(;this.token===this.tok.T_CATCH;){const n=this.node("catch");this.next().expect("(")&&this.next();const t=this.read_list(this.read_namespace_name,"|",!1),a=this.read_variable(!0,!1);this.expect(")"),e.push(n(this.next().read_statement(),t,a))}return this.token===this.tok.T_FINALLY&&(t=this.next().read_statement()),n(a,e,t)}}},function(n,t,e){"use strict";n.exports={read_short_form:function(n){const t=this.node("block"),e=[];for(this.expect(":")&&this.next();this.token!=this.EOF&&this.token!==n;)e.push(this.read_inner_statement());return 0===e.length&&this.extractDoc&&this._docs.length>this._docIndex&&e.push(this.node("noop")()),this.expect(n)&&this.next(),this.expectEndOfStatement(),t(null,e)},read_function_list:function(n,t){const e=[];do{if(this.token==t&&this.version>=703&&e.length>0){e.push(this.node("noop")());break}if(e.push(n.apply(this,[])),this.token!=t)break;if(")"==this.next().token&&this.version>=703)break}while(this.token!=this.EOF);return e},read_list:function(n,t,e){const a=[];if(this.token==t&&(e&&a.push("function"==typeof n?this.node("noop")():null),this.next()),"function"==typeof n)do{const e=n.apply(this,[]);if(e&&a.push(e),this.token!=t)break}while(this.next().token!=this.EOF);else{if(!this.expect(n))return[];for(a.push(this.text());this.next().token!=this.EOF&&this.token==t&&this.next().token==n;)a.push(this.text())}return a},read_name_list:function(){return this.read_list(this.read_namespace_name,",",!1)},read_byref:function(n){let t=this.node("byref");this.next(),t=t(null);const e=n();return e&&(this.ast.swapLocations(e,t,e,this),e.byref=!0),e},read_variable_declarations:function(){return this.read_list((function(){const n=this.node("staticvariable");let t=this.node("variable");if(this.expect(this.tok.T_VARIABLE)){const n=this.text().substring(1);this.next(),t=t(n,!1)}else t=t("#ERR",!1);return"="===this.token?n(t,this.next().read_expr()):t}),",")},read_extends_from:function(){return this.token===this.tok.T_EXTENDS?this.next().read_namespace_name():null},read_interface_extends_list:function(){return this.token===this.tok.T_EXTENDS?this.next().read_name_list():null},read_implements_list:function(){return this.token===this.tok.T_IMPLEMENTS?this.next().read_name_list():null}}},function(n,t,e){"use strict";n.exports={read_variable:function(n,t){let e;if("&"===this.token)return this.read_byref(this.read_variable.bind(this,n,t));if(this.is([this.tok.T_VARIABLE,"$"]))e=this.read_reference_variable(t);else if(this.is([this.tok.T_NS_SEPARATOR,this.tok.T_STRING,this.tok.T_NAMESPACE])){e=this.node();const n=this.read_namespace_name();if(this.token!=this.tok.T_DOUBLE_COLON&&"("!=this.token&&-1===["parentreference","selfreference"].indexOf(n.kind)){const t=n.name.toLowerCase();"true"===t?e=n.destroy(e("boolean",!0,n.name)):"false"===t?e=n.destroy(e("boolean",!1,n.name)):"null"===t?e=n.destroy(e("nullkeyword",n.name)):(e.destroy(n),e=n)}else e.destroy(n),e=n}else if(this.token===this.tok.T_STATIC){e=this.node("staticreference");const n=this.text();this.next(),e=e(n)}else this.expect("VARIABLE");return this.token===this.tok.T_DOUBLE_COLON&&(e=this.read_static_getter(e,t)),this.recursive_variable_chain_scan(e,n,t)},read_static_getter:function(n,t){const e=this.node("staticlookup");let a,i;return this.next().is([this.tok.T_VARIABLE,"$"])?a=this.read_reference_variable(t):this.token===this.tok.T_STRING||this.token===this.tok.T_CLASS||this.version>=700&&this.is("IDENTIFIER")?(a=this.node("identifier"),i=this.text(),this.next(),a=a(i)):"{"===this.token?(a=this.node("literal"),i=this.next().read_expr(),this.expect("}")&&this.next(),a=a("literal",i,null),this.expect("(")):(this.error([this.tok.T_VARIABLE,this.tok.T_STRING]),a=this.node("identifier"),i=this.text(),this.next(),a=a(i)),e(n,a)},read_what:function(n=!1){let t=null,e=null;switch(this.next().token){case this.tok.T_STRING:t=this.node("identifier"),e=this.text(),this.next(),t=t(e),n&&this.token===this.tok.T_OBJECT_OPERATOR&&this.error();break;case this.tok.T_VARIABLE:t=this.node("variable"),e=this.text().substring(1),this.next(),t=t(e,!1);break;case"$":t=this.node(),this.next().expect(["$","{",this.tok.T_VARIABLE]),"{"===this.token?(e=this.next().read_expr(),this.expect("}")&&this.next(),t=t("variable",e,!0)):(e=this.read_expr(),t=t("variable",e,!1));break;case"{":t=this.node("encapsedpart"),e=this.next().read_expr(),this.expect("}")&&this.next(),t=t(e,"complex",!1);break;default:this.error([this.tok.T_STRING,this.tok.T_VARIABLE,"$","{"]),t=this.node("identifier"),e=this.text(),this.next(),t=t(e)}return t},recursive_variable_chain_scan:function(n,t,e){let a,i;n:for(;this.token!=this.EOF;)switch(this.token){case"(":if(t)return n;n=this.node("call")(n,this.read_argument_list());break;case"[":case"{":{const t="["===this.token;if(a=this.node("offsetlookup"),this.next(),i=!1,e)i=this.read_encaps_var_offset(),this.expect(t?"]":"}")&&this.next();else{(t?"]"!==this.token:"}"!==this.token)?(i=this.read_expr(),this.expect(t?"]":"}")&&this.next()):this.next()}n=a(n,i);break}case this.tok.T_DOUBLE_COLON:"staticlookup"===n.kind&&"identifier"===n.offset.kind&&this.error(),a=this.node("staticlookup"),n=a(n,this.read_what(!0));break;case this.tok.T_OBJECT_OPERATOR:a=this.node("propertylookup"),n=a(n,this.read_what());break;default:break n}return n},read_encaps_var_offset:function(){let n=this.node();if(this.token===this.tok.T_STRING){const t=this.text();this.next(),n=n("identifier",t)}else if(this.token===this.tok.T_NUM_STRING){const t=this.text();this.next(),n=n("number",t,null)}else if("-"===this.token){this.next();const t=-1*this.text();this.expect(this.tok.T_NUM_STRING)&&this.next(),n=n("number",t,null)}else if(this.token===this.tok.T_VARIABLE){const t=this.text().substring(1);this.next(),n=n("variable",t,!1)}else{this.expect([this.tok.T_STRING,this.tok.T_NUM_STRING,"-",this.tok.T_VARIABLE]);const t=this.text();this.next(),n=n("identifier",t)}return n},read_reference_variable:function(n){let t,e=this.read_simple_variable();for(;this.token!=this.EOF;){const a=this.node();if("{"!=this.token||n){a.destroy();break}t=this.next().read_expr(),this.expect("}")&&this.next(),e=a("offsetlookup",e,t)}return e},read_simple_variable:function(){let n,t=this.node("variable");if(this.expect([this.tok.T_VARIABLE,"$"])&&this.token===this.tok.T_VARIABLE)n=this.text().substring(1),this.next(),t=t(n,!1);else switch("$"===this.token&&this.next(),this.token){case"{":{const n=this.next().read_expr();this.expect("}")&&this.next(),t=t(n,!0);break}case"$":t=t(this.read_simple_variable(),!1);break;case this.tok.T_VARIABLE:{n=this.text().substring(1);const e=this.node("variable");this.next(),t=t(e(n,!1),!1);break}default:this.error(["{","$",this.tok.T_VARIABLE]),n=this.text(),this.next(),t=t(n,!1)}return t}}},function(n,t,e){"use strict";n.exports={values:{101:"T_HALT_COMPILER",102:"T_USE",103:"T_ENCAPSED_AND_WHITESPACE",104:"T_OBJECT_OPERATOR",105:"T_STRING",106:"T_DOLLAR_OPEN_CURLY_BRACES",107:"T_STRING_VARNAME",108:"T_CURLY_OPEN",109:"T_NUM_STRING",110:"T_ISSET",111:"T_EMPTY",112:"T_INCLUDE",113:"T_INCLUDE_ONCE",114:"T_EVAL",115:"T_REQUIRE",116:"T_REQUIRE_ONCE",117:"T_NAMESPACE",118:"T_NS_SEPARATOR",119:"T_AS",120:"T_IF",121:"T_ENDIF",122:"T_WHILE",123:"T_DO",124:"T_FOR",125:"T_SWITCH",126:"T_BREAK",127:"T_CONTINUE",128:"T_RETURN",129:"T_GLOBAL",130:"T_STATIC",131:"T_ECHO",132:"T_INLINE_HTML",133:"T_UNSET",134:"T_FOREACH",135:"T_DECLARE",136:"T_TRY",137:"T_THROW",138:"T_GOTO",139:"T_FINALLY",140:"T_CATCH",141:"T_ENDDECLARE",142:"T_LIST",143:"T_CLONE",144:"T_PLUS_EQUAL",145:"T_MINUS_EQUAL",146:"T_MUL_EQUAL",147:"T_DIV_EQUAL",148:"T_CONCAT_EQUAL",149:"T_MOD_EQUAL",150:"T_AND_EQUAL",151:"T_OR_EQUAL",152:"T_XOR_EQUAL",153:"T_SL_EQUAL",154:"T_SR_EQUAL",155:"T_INC",156:"T_DEC",157:"T_BOOLEAN_OR",158:"T_BOOLEAN_AND",159:"T_LOGICAL_OR",160:"T_LOGICAL_AND",161:"T_LOGICAL_XOR",162:"T_SL",163:"T_SR",164:"T_IS_IDENTICAL",165:"T_IS_NOT_IDENTICAL",166:"T_IS_EQUAL",167:"T_IS_NOT_EQUAL",168:"T_IS_SMALLER_OR_EQUAL",169:"T_IS_GREATER_OR_EQUAL",170:"T_INSTANCEOF",171:"T_INT_CAST",172:"T_DOUBLE_CAST",173:"T_STRING_CAST",174:"T_ARRAY_CAST",175:"T_OBJECT_CAST",176:"T_BOOL_CAST",177:"T_UNSET_CAST",178:"T_EXIT",179:"T_PRINT",180:"T_YIELD",181:"T_YIELD_FROM",182:"T_FUNCTION",183:"T_DOUBLE_ARROW",184:"T_DOUBLE_COLON",185:"T_ARRAY",186:"T_CALLABLE",187:"T_CLASS",188:"T_ABSTRACT",189:"T_TRAIT",190:"T_FINAL",191:"T_EXTENDS",192:"T_INTERFACE",193:"T_IMPLEMENTS",194:"T_VAR",195:"T_PUBLIC",196:"T_PROTECTED",197:"T_PRIVATE",198:"T_CONST",199:"T_NEW",200:"T_INSTEADOF",201:"T_ELSEIF",202:"T_ELSE",203:"T_ENDSWITCH",204:"T_CASE",205:"T_DEFAULT",206:"T_ENDFOR",207:"T_ENDFOREACH",208:"T_ENDWHILE",209:"T_CONSTANT_ENCAPSED_STRING",210:"T_LNUMBER",211:"T_DNUMBER",212:"T_LINE",213:"T_FILE",214:"T_DIR",215:"T_TRAIT_C",216:"T_METHOD_C",217:"T_FUNC_C",218:"T_NS_C",219:"T_START_HEREDOC",220:"T_END_HEREDOC",221:"T_CLASS_C",222:"T_VARIABLE",223:"T_OPEN_TAG",224:"T_OPEN_TAG_WITH_ECHO",225:"T_CLOSE_TAG",226:"T_WHITESPACE",227:"T_COMMENT",228:"T_DOC_COMMENT",229:"T_ELLIPSIS",230:"T_COALESCE",231:"T_POW",232:"T_POW_EQUAL",233:"T_SPACESHIP",234:"T_COALESCE_EQUAL",235:"T_FN"},names:{T_HALT_COMPILER:101,T_USE:102,T_ENCAPSED_AND_WHITESPACE:103,T_OBJECT_OPERATOR:104,T_STRING:105,T_DOLLAR_OPEN_CURLY_BRACES:106,T_STRING_VARNAME:107,T_CURLY_OPEN:108,T_NUM_STRING:109,T_ISSET:110,T_EMPTY:111,T_INCLUDE:112,T_INCLUDE_ONCE:113,T_EVAL:114,T_REQUIRE:115,T_REQUIRE_ONCE:116,T_NAMESPACE:117,T_NS_SEPARATOR:118,T_AS:119,T_IF:120,T_ENDIF:121,T_WHILE:122,T_DO:123,T_FOR:124,T_SWITCH:125,T_BREAK:126,T_CONTINUE:127,T_RETURN:128,T_GLOBAL:129,T_STATIC:130,T_ECHO:131,T_INLINE_HTML:132,T_UNSET:133,T_FOREACH:134,T_DECLARE:135,T_TRY:136,T_THROW:137,T_GOTO:138,T_FINALLY:139,T_CATCH:140,T_ENDDECLARE:141,T_LIST:142,T_CLONE:143,T_PLUS_EQUAL:144,T_MINUS_EQUAL:145,T_MUL_EQUAL:146,T_DIV_EQUAL:147,T_CONCAT_EQUAL:148,T_MOD_EQUAL:149,T_AND_EQUAL:150,T_OR_EQUAL:151,T_XOR_EQUAL:152,T_SL_EQUAL:153,T_SR_EQUAL:154,T_INC:155,T_DEC:156,T_BOOLEAN_OR:157,T_BOOLEAN_AND:158,T_LOGICAL_OR:159,T_LOGICAL_AND:160,T_LOGICAL_XOR:161,T_SL:162,T_SR:163,T_IS_IDENTICAL:164,T_IS_NOT_IDENTICAL:165,T_IS_EQUAL:166,T_IS_NOT_EQUAL:167,T_IS_SMALLER_OR_EQUAL:168,T_IS_GREATER_OR_EQUAL:169,T_INSTANCEOF:170,T_INT_CAST:171,T_DOUBLE_CAST:172,T_STRING_CAST:173,T_ARRAY_CAST:174,T_OBJECT_CAST:175,T_BOOL_CAST:176,T_UNSET_CAST:177,T_EXIT:178,T_PRINT:179,T_YIELD:180,T_YIELD_FROM:181,T_FUNCTION:182,T_DOUBLE_ARROW:183,T_DOUBLE_COLON:184,T_ARRAY:185,T_CALLABLE:186,T_CLASS:187,T_ABSTRACT:188,T_TRAIT:189,T_FINAL:190,T_EXTENDS:191,T_INTERFACE:192,T_IMPLEMENTS:193,T_VAR:194,T_PUBLIC:195,T_PROTECTED:196,T_PRIVATE:197,T_CONST:198,T_NEW:199,T_INSTEADOF:200,T_ELSEIF:201,T_ELSE:202,T_ENDSWITCH:203,T_CASE:204,T_DEFAULT:205,T_ENDFOR:206,T_ENDFOREACH:207,T_ENDWHILE:208,T_CONSTANT_ENCAPSED_STRING:209,T_LNUMBER:210,T_DNUMBER:211,T_LINE:212,T_FILE:213,T_DIR:214,T_TRAIT_C:215,T_METHOD_C:216,T_FUNC_C:217,T_NS_C:218,T_START_HEREDOC:219,T_END_HEREDOC:220,T_CLASS_C:221,T_VARIABLE:222,T_OPEN_TAG:223,T_OPEN_TAG_WITH_ECHO:224,T_CLOSE_TAG:225,T_WHITESPACE:226,T_COMMENT:227,T_DOC_COMMENT:228,T_ELLIPSIS:229,T_COALESCE:230,T_POW:231,T_POW_EQUAL:232,T_SPACESHIP:233,T_COALESCE_EQUAL:234,T_FN:235}}},function(n,t,e){"use strict";const a=e(45),i=e(46),r=function(n,t){this.withPositions=n,this.withSource=t};r.prototype.position=function(n){return new i(n.lexer.yylloc.first_line,n.lexer.yylloc.first_column,n.lexer.yylloc.first_offset)},r.precedence={},[["or"],["xor"],["and"],["="],["?"],["??"],["||"],["&&"],["|"],["^"],["&"],["==","!=","===","!==","<=>"],["<","<=",">",">="],["<<",">>"],["+","-","."],["*","/","%"],["!"],["instanceof"],["cast","silent"],["**"]].forEach((function(n,t){n.forEach((function(n){r.precedence[n]=t+1}))})),r.prototype.isRightAssociative=function(n){return"**"===n||"??"===n},r.prototype.swapLocations=function(n,t,e,a){this.withPositions&&(n.loc.start=t.loc.start,n.loc.end=e.loc.end,this.withSource&&(n.loc.source=a.lexer._input.substring(n.loc.start.offset,n.loc.end.offset)))},r.prototype.resolveLocations=function(n,t,e,a){this.withPositions&&(n.loc.start.offset>t.loc.start.offset&&(n.loc.start=t.loc.start),n.loc.end.offset<e.loc.end.offset&&(n.loc.end=e.loc.end),this.withSource&&(n.loc.source=a.lexer._input.substring(n.loc.start.offset,n.loc.end.offset)))},r.prototype.resolvePrecedence=function(n,t){let e,a,i;return"call"===n.kind?this.resolveLocations(n,n.what,n,t):"propertylookup"===n.kind||"staticlookup"===n.kind||"offsetlookup"===n.kind&&n.offset?this.resolveLocations(n,n.what,n.offset,t):"bin"===n.kind?n.right&&!n.right.parenthesizedExpression&&("bin"===n.right.kind?(a=r.precedence[n.type],i=r.precedence[n.right.type],a&&i&&i<=a&&!this.isRightAssociative(n.type)&&(e=n.right,n.right=n.right.left,this.swapLocations(n,n.left,n.right,t),e.left=this.resolvePrecedence(n,t),this.swapLocations(e,e.left,e.right,t),n=e)):"retif"===n.right.kind&&(a=r.precedence[n.type],i=r.precedence["?"],a&&i&&i<=a&&(e=n.right,n.right=n.right.test,this.swapLocations(n,n.left,n.right,t),e.test=this.resolvePrecedence(n,t),this.swapLocations(e,e.test,e.falseExpr,t),n=e))):"silent"!==n.kind&&"cast"!==n.kind||!n.expr||n.expr.parenthesizedExpression?"unary"===n.kind?n.what&&!n.what.parenthesizedExpression&&("bin"===n.what.kind?(e=n.what,n.what=n.what.left,this.swapLocations(n,n,n.what,t),e.left=this.resolvePrecedence(n,t),this.swapLocations(e,e.left,e.right,t),n=e):"retif"===n.what.kind&&(e=n.what,n.what=n.what.test,this.swapLocations(n,n,n.what,t),e.test=this.resolvePrecedence(n,t),this.swapLocations(e,e.test,e.falseExpr,t),n=e)):"retif"===n.kind?n.falseExpr&&"retif"===n.falseExpr.kind&&!n.falseExpr.parenthesizedExpression&&(e=n.falseExpr,n.falseExpr=e.test,this.swapLocations(n,n.test,n.falseExpr,t),e.test=this.resolvePrecedence(n,t),this.swapLocations(e,e.test,e.falseExpr,t),n=e):"assign"===n.kind?n.right&&"bin"===n.right.kind&&!n.right.parenthesizedExpression&&(a=r.precedence["="],i=r.precedence[n.right.type],a&&i&&i<a&&(e=n.right,n.right=n.right.left,e.left=n,this.swapLocations(e,e.left,n.right,t),n=e)):"expressionstatement"===n.kind&&this.swapLocations(n,n.expression,n,t):"bin"===n.expr.kind?(e=n.expr,n.expr=n.expr.left,this.swapLocations(n,n,n.expr,t),e.left=this.resolvePrecedence(n,t),this.swapLocations(e,e.left,e.right,t),n=e):"retif"===n.expr.kind&&(e=n.expr,n.expr=n.expr.test,this.swapLocations(n,n,n.expr,t),e.test=this.resolvePrecedence(n,t),this.swapLocations(e,e.test,e.falseExpr,t),n=e),n},r.prototype.prepare=function(n,t,e){let s=null;(this.withPositions||this.withSource)&&(s=this.position(e));const o=this,c=function(){let l=null;const u=Array.prototype.slice.call(arguments);if(u.push(t),o.withPositions||o.withSource){let n=null;o.withSource&&(n=e.lexer._input.substring(s.offset,e.prev[2])),l=new a(n,s,new i(e.prev[0],e.prev[1],e.prev[2])),u.push(l)}n||(n=u.shift());const p=o[n];if("function"!=typeof p)throw new Error('Undefined node "'+n+'"');const h=Object.create(p.prototype);return p.apply(h,u),c.instance=h,c.trailingComments&&(h.trailingComments=c.trailingComments),"function"==typeof c.postBuild&&c.postBuild(h),e.debug&&delete r.stack[c.stackUid],o.resolvePrecedence(h,e)};return e.debug&&(r.stack||(r.stack={},r.stackUid=1),r.stack[++r.stackUid]={position:s,stack:(new Error).stack.split("\n").slice(3,5)},c.stackUid=r.stackUid),c.setTrailingComments=function(n){c.instance?c.instance.setTrailingComments(n):c.trailingComments=n},c.destroy=function(n){t&&(n?n.leadingComments?n.leadingComments=t.concat(n.leadingComments):n.leadingComments=t:e._docIndex=e._docs.length-t.length),e.debug&&delete r.stack[c.stackUid]},c},r.prototype.checkNodes=function(){const n=[];for(const t in r.stack)r.stack.hasOwnProperty(t)&&n.push(r.stack[t]);return r.stack={},n},[e(47),e(48),e(49),e(50),e(51),e(10),e(52),e(53),e(54),e(55),e(56),e(57),e(58),e(59),e(60),e(61),e(62),e(12),e(63),e(64),e(65),e(13),e(66),e(7),e(67),e(68),e(69),e(70),e(71),e(72),e(73),e(74),e(75),e(76),e(77),e(3),e(78),e(79),e(80),e(14),e(81),e(82),e(83),e(84),e(85),e(86),e(87),e(88),e(89),e(90),e(91),e(5),e(11),e(92),e(93),e(94),e(95),e(96),e(4),e(97),e(98),e(99),e(100),e(101),e(6),e(102),e(103),e(104),e(105),e(106),e(107),e(108),e(109),e(110),e(8),e(111),e(112),e(113),e(114),e(2),e(115),e(116),e(117),e(118),e(119),e(120),e(121),e(122),e(123),e(124),e(125),e(126),e(127),e(128),e(129),e(130),e(131),e(132),e(133),e(134),e(135),e(136)].forEach((function(n){r.prototype[n.kind]=n})),n.exports=r},function(n,t,e){"use strict";n.exports=function(n,t,e){this.source=n,this.start=t,this.end=e}},function(n,t,e){"use strict";n.exports=function(n,t,e){this.line=n,this.column=t,this.offset=e}},function(n,t,e){"use strict";const a=e(3);n.exports=a.extends("array",(function(n,t,e,i){a.apply(this,["array",e,i]),this.items=t,this.shortForm=n}))},function(n,t,e){"use strict";const a=e(3);n.exports=a.extends("arrowfunc",(function(n,t,e,i,r,s,o,c){a.apply(this,["arrowfunc",o,c]),this.arguments=n,this.byref=t,this.body=e,this.type=i,this.nullable=r,this.isStatic=s||!1}))},function(n,t,e){"use strict";const a=e(3);n.exports=a.extends("assign",(function(n,t,e,i,r){a.apply(this,["assign",i,r]),this.left=n,this.right=t,this.operator=e}))},function(n,t,e){"use strict";const a=e(3);n.exports=a.extends("assignref",(function(n,t,e,i){a.apply(this,["assignref",e,i]),this.left=n,this.right=t}))},function(n,t,e){"use strict";const a=e(6);n.exports=a.extends("bin",(function(n,t,e,i,r){a.apply(this,["bin",i,r]),this.type=n,this.left=t,this.right=e}))},function(n,t,e){"use strict";const a=e(5);n.exports=a.extends("boolean",(function(n,t,e,i){a.apply(this,["boolean",n,t,e,i])}))},function(n,t,e){"use strict";const a=e(2);n.exports=a.extends("break",(function(n,t,e){a.apply(this,["break",t,e]),this.level=n}))},function(n,t,e){"use strict";const a=e(3);n.exports=a.extends("byref",(function(n,t,e){a.apply(this,["byref",t,e]),this.what=n}))},function(n,t,e){"use strict";const a=e(3);n.exports=a.extends("call",(function(n,t,e,i){a.apply(this,["call",e,i]),this.what=n,this.arguments=t}))},function(n,t,e){"use strict";const a=e(2);n.exports=a.extends("case",(function(n,t,e,i){a.apply(this,["case",e,i]),this.test=n,this.body=t}))},function(n,t,e){"use strict";const a=e(6);n.exports=a.extends("cast",(function(n,t,e,i,r){a.apply(this,["cast",i,r]),this.type=n,this.raw=t,this.expr=e}))},function(n,t,e){"use strict";const a=e(2);n.exports=a.extends("catch",(function(n,t,e,i,r){a.apply(this,["catch",i,r]),this.body=n,this.what=t,this.variable=e}))},function(n,t,e){"use strict";const a=e(7);n.exports=a.extends("class",(function(n,t,e,i,r,s,o){a.apply(this,["class",n,s,o]),this.isAnonymous=!n,this.extends=t,this.implements=e,this.body=i,this.parseFlags(r)}))},function(n,t,e){"use strict";const a=e(13),i="classconstant",r=a.extends(i,(function(n,t,e,r,s){a.apply(this,[n||i,t,r,s]),this.parseFlags(e)}));r.prototype.parseFlags=function(n){-1===n[0]?this.visibility="":null===n[0]?this.visibility=null:0===n[0]?this.visibility="public":1===n[0]?this.visibility="protected":2===n[0]&&(this.visibility="private")},n.exports=r},function(n,t,e){"use strict";const a=e(3);n.exports=a.extends("clone",(function(n,t,e){a.apply(this,["clone",t,e]),this.what=n}))},function(n,t,e){"use strict";const a=e(3);n.exports=a.extends("closure",(function(n,t,e,i,r,s,o,c){a.apply(this,["closure",o,c]),this.uses=e,this.arguments=n,this.byref=t,this.type=i,this.nullable=r,this.isStatic=s||!1,this.body=null}))},function(n,t,e){"use strict";const a=e(12);n.exports=a.extends("commentblock",(function(n,t,e){a.apply(this,["commentblock",n,t,e])}))},function(n,t,e){"use strict";const a=e(12);n.exports=a.extends("commentline",(function(n,t,e){a.apply(this,["commentline",n,t,e])}))},function(n,t,e){"use strict";const a=e(4);n.exports=a.extends("constant",(function(n,t,e,i){a.apply(this,["constant",e,i]),this.name=n,this.value=t}))},function(n,t,e){"use strict";const a=e(2);n.exports=a.extends("continue",(function(n,t,e){a.apply(this,["continue",t,e]),this.level=n}))},function(n,t,e){"use strict";const a=e(10),i=a.extends("declare",(function(n,t,e,i,r){a.apply(this,["declare",t,i,r]),this.directives=n,this.mode=e}));i.MODE_SHORT="short",i.MODE_BLOCK="block",i.MODE_NONE="none",n.exports=i},function(n,t,e){"use strict";const a=e(4),i="declaredirective";n.exports=a.extends(i,(function(n,t,e,r){a.apply(this,[i,e,r]),this.key=n,this.value=t}))},function(n,t,e){"use strict";const a=e(2);n.exports=a.extends("do",(function(n,t,e,i){a.apply(this,["do",e,i]),this.test=n,this.body=t}))},function(n,t,e){"use strict";const a=e(2);n.exports=a.extends("echo",(function(n,t,e,i){a.apply(this,["echo",e,i]),this.shortForm=t,this.expressions=n}))},function(n,t,e){"use strict";const a=e(3);n.exports=a.extends("empty",(function(n,t,e){a.apply(this,["empty",t,e]),this.expression=n}))},function(n,t,e){"use strict";const a=e(5),i=a.extends("encapsed",(function(n,t,e,i,r){a.apply(this,["encapsed",n,t,i,r]),this.type=e}));i.TYPE_STRING="string",i.TYPE_SHELL="shell",i.TYPE_HEREDOC="heredoc",i.TYPE_OFFSET="offset",n.exports=i},function(n,t,e){"use strict";const a=e(3);n.exports=a.extends("encapsedpart",(function(n,t,e,i,r){a.apply(this,["encapsedpart",i,r]),this.expression=n,this.syntax=t,this.curly=e}))},function(n,t,e){"use strict";const a=e(3);n.exports=a.extends("entry",(function(n,t,e,i,r,s){a.apply(this,["entry",r,s]),this.key=n,this.value=t,this.byRef=e,this.unpack=i}))},function(n,t,e){"use strict";const a=e(4);n.exports=a.extends("error",(function(n,t,e,i,r,s){a.apply(this,["error",r,s]),this.message=n,this.token=t,this.line=e,this.expected=i}))},function(n,t,e){"use strict";const a=e(3);n.exports=a.extends("eval",(function(n,t,e){a.apply(this,["eval",t,e]),this.source=n}))},function(n,t,e){"use strict";const a=e(3);n.exports=a.extends("exit",(function(n,t,e,i){a.apply(this,["exit",e,i]),this.expression=n,this.useDie=t}))},function(n,t,e){"use strict";const a=e(2),i="expressionstatement";n.exports=a.extends(i,(function(n,t,e){a.apply(this,[i,t,e]),this.expression=n}))},function(n,t,e){"use strict";const a=e(2);n.exports=a.extends("for",(function(n,t,e,i,r,s,o){a.apply(this,["for",s,o]),this.init=n,this.test=t,this.increment=e,this.shortForm=r,this.body=i}))},function(n,t,e){"use strict";const a=e(2);n.exports=a.extends("foreach",(function(n,t,e,i,r,s,o){a.apply(this,["foreach",s,o]),this.source=n,this.key=t,this.value=e,this.shortForm=r,this.body=i}))},function(n,t,e){"use strict";const a=e(2);n.exports=a.extends("global",(function(n,t,e){a.apply(this,["global",t,e]),this.items=n}))},function(n,t,e){"use strict";const a=e(2);n.exports=a.extends("goto",(function(n,t,e){a.apply(this,["goto",t,e]),this.label=n}))},function(n,t,e){"use strict";const a=e(2);n.exports=a.extends("halt",(function(n,t,e){a.apply(this,["halt",t,e]),this.after=n}))},function(n,t,e){"use strict";const a=e(4),i=a.extends("identifier",(function(n,t,e){a.apply(this,["identifier",t,e]),this.name=n}));n.exports=i},function(n,t,e){"use strict";const a=e(2);n.exports=a.extends("if",(function(n,t,e,i,r,s){a.apply(this,["if",r,s]),this.test=n,this.body=t,this.alternate=e,this.shortForm=i}))},function(n,t,e){"use strict";const a=e(3);n.exports=a.extends("include",(function(n,t,e,i,r){a.apply(this,["include",i,r]),this.once=n,this.require=t,this.target=e}))},function(n,t,e){"use strict";const a=e(5);n.exports=a.extends("inline",(function(n,t,e,i){a.apply(this,["inline",n,t,e,i])}))},function(n,t,e){"use strict";const a=e(7);n.exports=a.extends("interface",(function(n,t,e,i,r){a.apply(this,["interface",n,i,r]),this.extends=t,this.body=e}))},function(n,t,e){"use strict";const a=e(3);n.exports=a.extends("isset",(function(n,t,e){a.apply(this,["isset",t,e]),this.variables=n}))},function(n,t,e){"use strict";const a=e(2);n.exports=a.extends("label",(function(n,t,e){a.apply(this,["label",t,e]),this.name=n}))},function(n,t,e){"use strict";const a=e(3);n.exports=a.extends("list",(function(n,t,e,i){a.apply(this,["list",e,i]),this.items=n,this.shortForm=t}))},function(n,t,e){"use strict";const a=e(5);n.exports=a.extends("magic",(function(n,t,e,i){a.apply(this,["magic",n,t,e,i])}))},function(n,t,e){"use strict";const a=e(14);n.exports=a.extends("method",(function(){a.apply(this,arguments),this.kind="method"}))},function(n,t,e){"use strict";const a=e(8),i=a.extends("name",(function n(t,e,i,r){a.apply(this,["name",i,r]),e?this.resolution=n.RELATIVE_NAME:1===t.length?this.resolution=n.UNQUALIFIED_NAME:t[0]?this.resolution=n.QUALIFIED_NAME:this.resolution=n.FULL_QUALIFIED_NAME,this.name=t.join("\\")}));i.UNQUALIFIED_NAME="uqn",i.QUALIFIED_NAME="qn",i.FULL_QUALIFIED_NAME="fqn",i.RELATIVE_NAME="rn",n.exports=i},function(n,t,e){"use strict";const a=e(10);n.exports=a.extends("namespace",(function(n,t,e,i,r){a.apply(this,["namespace",t,i,r]),this.name=n,this.withBrackets=e||!1}))},function(n,t,e){"use strict";const a=e(3);n.exports=a.extends("new",(function(n,t,e,i){a.apply(this,["new",e,i]),this.what=n,this.arguments=t}))},function(n,t,e){"use strict";const a=e(4);n.exports=a.extends("noop",(function(n,t){a.apply(this,["noop",n,t])}))},function(n,t,e){"use strict";const a=e(5);n.exports=a.extends("nowdoc",(function(n,t,e,i,r){a.apply(this,["nowdoc",n,t,i,r]),this.label=e}))},function(n,t,e){"use strict";const a=e(4);n.exports=a.extends("nullkeyword",(function(n,t,e){a.apply(this,["nullkeyword",t,e]),this.raw=n}))},function(n,t,e){"use strict";const a=e(5);n.exports=a.extends("number",(function(n,t,e,i){a.apply(this,["number",n,t,e,i])}))},function(n,t,e){"use strict";const a=e(11);n.exports=a.extends("offsetlookup",(function(n,t,e,i){a.apply(this,["offsetlookup",n,t,e,i])}))},function(n,t,e){"use strict";const a=e(7);n.exports=a.extends("parameter",(function(n,t,e,i,r,s,o,c){a.apply(this,["parameter",n,o,c]),this.value=e,this.type=t,this.byref=i,this.variadic=r,this.nullable=s}))},function(n,t,e){"use strict";const a=e(8),i="parentreference",r=a.extends(i,(function(n,t,e){a.apply(this,[i,t,e]),this.raw=n}));n.exports=r},function(n,t,e){"use strict";const a=e(6);n.exports=a.extends("post",(function(n,t,e,i){a.apply(this,["post",e,i]),this.type=n,this.what=t}))},function(n,t,e){"use strict";const a=e(6);n.exports=a.extends("pre",(function(n,t,e,i){a.apply(this,["pre",e,i]),this.type=n,this.what=t}))},function(n,t,e){"use strict";const a=e(3);n.exports=a.extends("print",(function(n,t,e){a.apply(this,["print",t,e]),this.expression=n}))},function(n,t,e){"use strict";const a=e(10);n.exports=a.extends("program",(function(n,t,e,i,r,s){a.apply(this,["program",n,r,s]),this.errors=t,e&&(this.comments=e),i&&(this.tokens=i)}))},function(n,t,e){"use strict";const a=e(2);n.exports=a.extends("property",(function(n,t,e,i,r,s){a.apply(this,["property",r,s]),this.name=n,this.value=t,this.nullable=e,this.type=i}))},function(n,t,e){"use strict";const a=e(11),i="propertylookup";n.exports=a.extends(i,(function(n,t,e,r){a.apply(this,[i,n,t,e,r])}))},function(n,t,e){"use strict";const a=e(2),i="propertystatement",r=a.extends(i,(function(n,t,e,r,s){a.apply(this,[i,r,s]),this.properties=t,this.parseFlags(e)}));r.prototype.parseFlags=function(n){-1===n[0]?this.visibility="":null===n[0]?this.visibility=null:0===n[0]?this.visibility="public":1===n[0]?this.visibility="protected":2===n[0]&&(this.visibility="private"),this.isStatic=1===n[1]},n.exports=r},function(n,t,e){"use strict";const a=e(3);n.exports=a.extends("retif",(function(n,t,e,i,r){a.apply(this,["retif",i,r]),this.test=n,this.trueExpr=t,this.falseExpr=e}))},function(n,t,e){"use strict";const a=e(2);n.exports=a.extends("return",(function(n,t,e){a.apply(this,["return",t,e]),this.expr=n}))},function(n,t,e){"use strict";const a=e(8),i="selfreference",r=a.extends(i,(function(n,t,e){a.apply(this,[i,t,e]),this.raw=n}));n.exports=r},function(n,t,e){"use strict";const a=e(3);n.exports=a.extends("silent",(function(n,t,e){a.apply(this,["silent",t,e]),this.expr=n}))},function(n,t,e){"use strict";const a=e(2);n.exports=a.extends("static",(function(n,t,e){a.apply(this,["static",t,e]),this.variables=n}))},function(n,t,e){"use strict";const a=e(4),i="staticvariable";n.exports=a.extends(i,(function(n,t,e,r){a.apply(this,[i,e,r]),this.variable=n,this.defaultValue=t}))},function(n,t,e){"use strict";const a=e(11);n.exports=a.extends("staticlookup",(function(n,t,e,i){a.apply(this,["staticlookup",n,t,e,i])}))},function(n,t,e){"use strict";const a=e(8),i="staticreference",r=a.extends(i,(function(n,t,e){a.apply(this,[i,t,e]),this.raw=n}));n.exports=r},function(n,t,e){"use strict";const a=e(5);n.exports=a.extends("string",(function(n,t,e,i,r,s){a.apply(this,["string",t,i,r,s]),this.unicode=e,this.isDoubleQuote=n}))},function(n,t,e){"use strict";const a=e(2);n.exports=a.extends("switch",(function(n,t,e,i,r){a.apply(this,["switch",i,r]),this.test=n,this.body=t,this.shortForm=e}))},function(n,t,e){"use strict";const a=e(2);n.exports=a.extends("throw",(function(n,t,e){a.apply(this,["throw",t,e]),this.what=n}))},function(n,t,e){"use strict";const a=e(7);n.exports=a.extends("trait",(function(n,t,e,i){a.apply(this,["trait",n,e,i]),this.body=t}))},function(n,t,e){"use strict";const a=e(4);n.exports=a.extends("traitalias",(function(n,t,e,i,r,s){a.apply(this,["traitalias",r,s]),this.trait=n,this.method=t,this.as=e,this.visibility="",i&&(0===i[0]?this.visibility="public":1===i[0]?this.visibility="protected":2===i[0]&&(this.visibility="private"))}))},function(n,t,e){"use strict";const a=e(4),i="traitprecedence";n.exports=a.extends(i,(function(n,t,e,r,s){a.apply(this,[i,r,s]),this.trait=n,this.method=t,this.instead=e}))},function(n,t,e){"use strict";const a=e(4);n.exports=a.extends("traituse",(function(n,t,e,i){a.apply(this,["traituse",e,i]),this.traits=n,this.adaptations=t}))},function(n,t,e){"use strict";const a=e(2);n.exports=a.extends("try",(function(n,t,e,i,r){a.apply(this,["try",i,r]),this.body=n,this.catches=t,this.always=e}))},function(n,t,e){"use strict";const a=e(8),i="typereference",r=a.extends(i,(function(n,t,e,r){a.apply(this,[i,e,r]),this.name=n,this.raw=t}));r.types=["int","float","string","bool","object","array","callable","iterable","void"],n.exports=r},function(n,t,e){"use strict";const a=e(6);n.exports=a.extends("unary",(function(n,t,e,i){a.apply(this,["unary",e,i]),this.type=n,this.what=t}))},function(n,t,e){"use strict";const a=e(2);n.exports=a.extends("unset",(function(n,t,e){a.apply(this,["unset",t,e]),this.variables=n}))},function(n,t,e){"use strict";const a=e(2);n.exports=a.extends("usegroup",(function(n,t,e,i,r){a.apply(this,["usegroup",i,r]),this.name=n,this.type=t,this.items=e}))},function(n,t,e){"use strict";const a=e(2),i=a.extends("useitem",(function(n,t,e,i,r){a.apply(this,["useitem",i,r]),this.name=n,this.alias=t,this.type=e}));i.TYPE_CONST="const",i.TYPE_FUNCTION="function",n.exports=i},function(n,t,e){"use strict";const a=e(3);n.exports=a.extends("variable",(function(n,t,e,i){a.apply(this,["variable",e,i]),this.name=n,this.curly=t||!1}))},function(n,t,e){"use strict";const a=e(3);n.exports=a.extends("variadic",(function(n,t,e){a.apply(this,["variadic",t,e]),this.what=n}))},function(n,t,e){"use strict";const a=e(2);n.exports=a.extends("while",(function(n,t,e,i,r){a.apply(this,["while",i,r]),this.test=n,this.body=t,this.shortForm=e}))},function(n,t,e){"use strict";const a=e(3);n.exports=a.extends("yield",(function(n,t,e,i){a.apply(this,["yield",e,i]),this.value=n,this.key=t}))},function(n,t,e){"use strict";const a=e(3);n.exports=a.extends("yieldfrom",(function(n,t,e){a.apply(this,["yieldfrom",t,e]),this.value=n}))},function(n,t,e){"use strict";e.r(t),e.d(t,"activate",(function(){return x})),e.d(t,"deactivate",(function(){return C}));var a=e(0),i=e(9),r=e(1);function s(){if(a.workspace.workspaceFolders instanceof Array&&0!==a.workspace.workspaceFolders.length)return a.workspace.workspaceFolders[0]}function o(n){let t=s();return"uri"in t?t.uri.fsPath+"/"+n:""}function c(){let n=a.workspace.getConfiguration("LaravelIntellisense").get("model");return Object(r.isUndefined)(n)?null:(n.endsWith("\\")||(n+="\\"),n)}const l=[{scheme:"file",language:"php"},{scheme:"untitled",language:"php"},{scheme:"file",language:"blade"},{scheme:"file",language:"laravel-blade"}],u=['"',"'",">"];var p=e(15),h=e(16);class m{static async run(n){if(i.existsSync(o("vendor/autoload.php"))&&i.existsSync(o("bootstrap/app.php"))){var t=this.getScript(n),e=await this.execute(t);if(e=/___OUTPUT___(.*)___END_OUTPUT___/g.exec(e))return e[1]}return""}static async execute(n){if(this.running)return"";this.running=!0,n=n.replace(/\"/g,'\\"'),["linux","openbsd","sunos","darwin"].some(n=>h.platform().includes(n))&&(n=(n=(n=n.replace(/\$/g,"\\$")).replace(/\\\\'/g,"\\\\\\\\'")).replace(/\\\\"/g,'\\\\\\\\"'));var t=this.getCommand()+'"'+n+'"';return new Promise((n,e)=>{p.exec(t,(t,a,i)=>{this.running=!1,a.length>0?n(a):(console.error(t),e(i))})})}static getScript(n){return"define('LARAVEL_START', microtime(true));require_once '"+this.filePath("vendor/autoload.php")+"';$app = require_once '"+this.filePath("bootstrap/app.php")+"';$kernel = $app->make(Illuminate\\Contracts\\Console\\Kernel::class);$status = $kernel->handle($input = new Symfony\\Component\\Console\\Input\\ArgvInput,new Symfony\\Component\\Console\\Output\\ConsoleOutput);echo '___OUTPUT___';"+n+"echo '___END_OUTPUT___';"}static getCommand(){return this.isDocker()?this.getDockerscript()+" php -r":"php -r"}static filePath(n){return this.isDocker()?"./"+n:o(n)}static isDocker(){return!!this.getDockerscript()}static getDockerscript(){return a.workspace.getConfiguration("LaravelIntellisense").get("docker")}}m.phpParser=null,m.running=!1;class ${constructor(n,t){this.aliasToken=[],this.tokens=n,this.aliasToken=t}getFullClassName(){const n=this.getClassNameFromToken();if(Object(r.isNull)(n))return null;const t=this.getUseClasses().find(t=>t.endsWith(n));if(n.includes("\\"))return n;if(Object(r.isUndefined)(t)){return c()+n}return t}getUseClasses(){let n=[];for(let t=0;t<this.tokens.length;t++)if("T_USE"===this.tokens[t][0]){let e=[];for(let n=t+1;n<this.tokens.length&&";"!==this.tokens[n];n++)e.push(this.tokens[n]);n.push(this.joinClassNameFromTokens(e))}return n}getUsedVariableTokenOrClassName(n=[]){let t=[],e=!0,a=[];if(0===n.length&&(n=this.aliasToken),Object(r.isUndefined)(n)||n.length<3)return null;const i=this.tokens.slice(0,n[3]).reverse();for(let n=0;n<i.length;n++){if("T_VARIABLE"===i[n][0]&&("{"===i[n+1]||";"===i[n+1]||")"===i[n+1]||"="===i[n+1])){a=i[n],e=!0;break}if("T_DOUBLE_COLON"===i[n][0]){const a=this.checkIfTheDoubleColonIsCorrect(n,i);if(a.isCorrectDoubleColon){t=a.classNameTokens,e=!1;break}}}return e?a:this.joinClassNameFromTokens(t.reverse())}checkIfTheDoubleColonIsCorrect(n,t){let e=[],a=!1;const i=t.slice(n+1);for(let n=0;n<i.length&&("T_STRING"!==i[n][0]&&"T_NS_SEPARATOR"!==i[n][0]||e.push(i[n]),"T_STRING"!==i[n][0]&&"T_NS_SEPARATOR"!==i[n][0]&&("("===i[n][0]&&"T_FUNCTION"===i[n+1][0]||"="===i[n][0]||"{"===i[n][0]||")"===i[n][0]||";"===i[n][0]||"T_OPEN_TAG"===i[n][0])&&(a=!0),"T_STRING"===i[n][0]||"T_OBJECT_OPERATOR"===i[n][0]||"T_NS_SEPARATOR"===i[n][0]);n++);return{isCorrectDoubleColon:a,classNameTokens:e}}getUsedVariableFirstIndexOrClassName(n=[],t=[]){0===n.length&&(n=this.tokens),0===t.length&&(t=this.aliasToken);const e=this.getUsedVariableTokenOrClassName(t);if(Object(r.isNull)(e))return null;if(Object(r.isString)(e))return e;let a=!1;const i=n.slice(0,t[3]).reverse();let s=[];for(const n of i)if("T_VARIABLE"===n[0]&&n[1]===e[1]){const t=this.getFirstVariableToken(n);if(Object(r.isString)(t)){s=t;break}if(t.variableToken.length>0){s=t.variableToken,a=t.isInsideFunctionParams;break}}return Object(r.isString)(s)?s:0===s.length?null:{variableToken:s,isInsideFunctionParams:a}}getFirstVariableToken(n){const t=this.tokens.slice(0,n[3]).reverse();let e=!1,a=!1;for(const n of t){if("T_STRING"===n[0]){e=!0;break}if("T_FUNCTION"===n[0]){a=!0;break}if(";"===n||"{"===n||")"===n)break}return e?{variableToken:n,isInsideFunctionParams:!0}:a?this.getUsedVariableFirstIndexOrClassName(t.reverse(),n):{variableToken:[],isInsideFunctionParams:!1}}getClassNameFromToken(n=[],t=[]){const e=this.getUsedVariableFirstIndexOrClassName(n,t);if(Object(r.isString)(e))return e;if(Object(r.isNull)(e))return null;const a=e.variableToken;return e.isInsideFunctionParams?this.getClassNameFromDependencyInjection(a):this.getClassNameFromEquality(a)}getClassNameFromEquality(n){let t=[],e=null;const a=this.tokens.slice(n[3]+1);for(let n=0;n<a.length;n++){if("="===a[n]){e=n;break}if("T_WHITESPACE"!==a[n][0]){e=null;break}}if(Object(r.isNull)(e))return null;const i=a.slice(e+1);for(let n=0;n<i.length&&("T_STRING"!==i[n][0]&&"T_NS_SEPARATOR"!==i[n][0]||t.push(i[n]),"T_STRING"===i[n][0]||"T_NS_SEPARATOR"===i[n][0]);n++);return this.joinClassNameFromTokens(t)}getClassNameFromDependencyInjection(n){let t=[];const e=this.tokens.slice(0,n[3]).reverse();for(const n of e)if("T_STRING"!==n[0]&&"T_NS_SEPARATOR"!==n[0]||t.push(n),"T_STRING"!==n[0]&&"T_NS_SEPARATOR"!==n[0])break;return t=t.reverse(),0===t.length?this.getClassNameFromToken(e,n):this.joinClassNameFromTokens(t)}joinClassNameFromTokens(n){return n.map(n=>n[1]).join("").trim()}}class d{constructor(n,t){this.aliasToken=[],this.tokens=n,this.aliasToken=t}getFullClassName(){if(0===this.aliasToken.length)return null;return c()+this.aliasToken[1].replace("Resource","")}}class f{constructor(n,t,e){this.tokens=n,this.position=t,this.aliases=e}getEloquentAliasToken(){return this.getAliasToken()}getResourceAliasToken(){let n=[];for(let t=0;t<this.tokens.length&&(t>0&&"T_CLASS"===this.tokens[t-1][0]&&"T_STRING"===this.tokens[t][0]&&this.tokens[t][1].endsWith("Resource")&&(n=this.tokens[t]),"{"!==this.tokens[t]||"T_CONSTANT_ENCAPSED_STRING"===this.tokens[t][0]);t++);const t=this.tokens.filter(n=>n[2]===this.position.line+1).reverse();for(let n=0;n<t.length&&t[n][1].includes(">")&&!("T_OBJECT_OPERATOR"===t[n][0]&&"$this"===t[n+1][1]&&t.length>n+1);n++)if("T_OBJECT_OPERATOR"!==t[n][0]||"T_VARIABLE"!==t[n+1][1]&&t.length>n+1)return[];return n}getFactoryAliasToken(){let n=[];const t=this.tokens.filter(n=>n[2]===this.position.line+1).reverse();for(let n=0;n<t.length;n++){if("T_OBJECT_OPERATOR"===t[n][0]||"T_DOUBLE_ARROW"===t[n][0])return[];if(n>=1&&"T_RETURN"!==t[n][0])return[]}if(0===t.length)return n;const e=this.tokens.slice(0,t[0][3]).filter(n=>Object(r.isArray)(n)).reverse();for(let t=0;t<e.length;t++)if(e.length>t+3&&"T_STRING"===e[t+1][0]&&"define"===e[t+1][1]&&"T_OBJECT_OPERATOR"===e[t+2][0]&&"->"===e[t+2][1]&&"T_VARIABLE"===e[t+3][0]&&"$factory"===e[t+3][1]){n=e[t];break}return n}hasAlias(){return this.checkForAlias()}checkForAlias(){const n=this.tokensOnTheSameLine();return n.shift(),0!==n.length&&(!!this.aliases.includes(n[0][1])||!!this.aliases.includes(this.tokensToString(n)))}getAliasToken(){let n=[];const t=this.tokensOnTheSameLine();t.shift();const e=t.shift();return Object(r.isArray)(e)&&this.aliases.includes(e[1])&&(n=e),n}tokensOnTheSameLine(){return this.tokens.filter(n=>n[2]===this.position.line+1).reverse()}tokensToString(n){return n.map(n=>n[1]).reverse().join("").trim()}}class b{constructor(n,t){this.aliasToken=[],this.tokens=n,this.aliasToken=t}getFullClassName(){const n=this.getClassNameFromToken();if(Object(r.isNull)(n))return null;const t=this.getUseClasses().find(t=>t.endsWith(n));return Object(r.isUndefined)(t)?n:t}getClassNameFromToken(){const n=this.tokens.slice(this.aliasToken[3]);let t=[];for(const e of n)if("T_STRING"!==e[0]&&"T_NS_SEPARATOR"!==e[0]||t.push(e),"T_STRING"!==e[0]&&"T_NS_SEPARATOR"!==e[0])break;return this.joinClassNameFromTokens(t)}getUseClasses(){let n=[];for(let t=0;t<this.tokens.length;t++)if("T_USE"===this.tokens[t][0]){let e=[];for(let n=t+1;n<this.tokens.length&&";"!==this.tokens[n];n++)e.push(this.tokens[n]);n.push(this.joinClassNameFromTokens(e))}return n}joinClassNameFromTokens(n){return n.map(n=>n[1]).join("").trim()}}class g{constructor(n,t){this.cachedParseFunction=null,this.viewAliases=["view","markdown","links","@extends","@component","@include","@each"],this.queryAliases=["where","get","firstWhere","value","orWhere","latest","oldest","firstWhere","firstOrFail","pluck","increment","decrement","qualifyColumn"],this.configAliases=["config","Config::get"],this.routeAliases=["route"],this.translateAliases=["__","trans","trans_choice"],this.tokens=[],this.document=n,this.position=t,this.tokens=this.parseTokens()}parseTokens(){return n=this.document.getText(),new(e(17))({parser:{extractDoc:!0,php7:!0},ast:{withPositions:!0}}).tokenGetAll(n).filter(n=>"T_WHITESPACE"!==n[0]&&"T_COMMENT"!==n[0]&&"T_INLINE_HTML"!==n[0]).map((n,t)=>Object(r.isArray)(n)?[...n,t]:n);var n}getClassName(){const n=new f(this.tokens,this.position,this.queryAliases),t=n.getEloquentAliasToken();if(t.length>0)return this.hasModel(t);let e=n.getResourceAliasToken();if(e.length)return this.hasResource(e);const a=n.getFactoryAliasToken();return a.length>0?this.hasFactory(a):null}hasModel(n){return new $(this.tokens,n).getFullClassName()}hasResource(n){return new d(this.tokens,n).getFullClassName()}hasFactory(n){return new b(this.tokens,n).getFullClassName()}hasConfig(){return new f(this.tokens,this.position,this.configAliases).hasAlias()}hasRoute(){return new f(this.tokens,this.position,this.routeAliases).hasAlias()}hasView(){return new f(this.tokens,this.position,this.viewAliases).hasAlias()}hasTranslation(){return new f(this.tokens,this.position,this.translateAliases).hasAlias()}}class y{constructor(){this.views=null,this.watcher=null,this.syncViews(),this.watchViews()}async provideCompletionItems(n,t){let e=[];if(!new g(n,t).hasView())return e;Object(r.isNull)(this.views)&&await this.syncViews();for(let i of this.views){const r=new a.CompletionItem(i,a.CompletionItemKind.Constant);r.range=n.getWordRangeAtPosition(t,/[\w\d\-_\.\:\\\/]+/g),e.push(r)}return e}syncViews(){m.run("function getViewsFromDirectory($directories, $filesystem, $parentDirectory = null){$views = [];foreach ($directories as $directory) {$viewDirectory = basename($directory);if ($parentDirectory) {$viewDirectory = $parentDirectory . '.' . $viewDirectory;}if ($filesystem->directories($directory)) {$childDirectoryViews = getViewsFromDirectory($filesystem->directories($directory), $filesystem, $viewDirectory);if ($childDirectoryViews) {$views[] = $childDirectoryViews;}}foreach ($filesystem->files($directory) as $file) {if (!is_object($file) || !method_exists($file, 'getBaseName')) {continue;}if (strpos($file->getBaseName(), '.blade.php')) {$fileName = str_replace('.blade.php', '', $file->getBaseName());$views[] = $viewDirectory . '.' . $fileName;}}}return $views;}function getViews($path, $filesystem, $parentDirectory = null, $deluminator = '.'){$views = [];foreach ($filesystem->files($path) as $file) {if (!is_object($file) || !method_exists($file, 'getBaseName')) {continue;}if (strpos($file->getBaseName(), '.blade.php')) {$fileName = str_replace('.blade.php', '', $file->getBaseName());$view = '';if ($parentDirectory) {$view = $parentDirectory . $deluminator;}$view .= $fileName;$views = array_merge($views, [$view]);}}return array_merge($views, Illuminate\\Support\\Arr::flatten(getViewsFromDirectory($filesystem->directories($path), $filesystem)));}$filesystem = new Illuminate\\Filesystem\\Filesystem;$views = [];foreach (app('view')->getFinder()->getPaths() as $path) {$views = array_merge($views, getViews($path, $filesystem));}foreach (app('view')->getFinder()->getHints() as $namespace => $paths) {foreach ($paths as $path) {$views = array_merge($views, getViews($path, $filesystem, $namespace, '::'));}}echo json_encode($views);").then(n=>{this.views=JSON.parse(n)})}watchViews(){this.watcher=a.workspace.createFileSystemWatcher(new a.RelativePattern(s(),"{,**/}{view,views}/{*,**/*}")),this.watcher.onDidCreate(()=>this.onChange()),this.watcher.onDidDelete(()=>this.onChange()),this.watcher.onDidChange(()=>this.onChange())}onChange(){setInterval(()=>{this.syncViews()},5e3)}}class v{constructor(){this.attributes={},this.model=""}async provideCompletionItems(n,t){let e=[];if(this.model=new g(n,t).getClassName(),Object(r.isNull)(this.model))return e;this.attributes.hasOwnProperty(this.model)||await this.syncModel();for(let i of this.attributes[this.model]){const r=new a.CompletionItem(i,a.CompletionItemKind.Constant);r.range=n.getWordRangeAtPosition(t,/[\w\d\-_\.\:\\\/]+/g),e.push(r)}return e}async syncModel(){if(Object(r.isNull)(this.model))return;const n=await function(n){const t=`$user = ${n}::first();echo json_encode(array_keys($user->getAttributes()));`;return m.run(t)}(this.model);this.attributes[this.model]=JSON.parse(n)}}class I{static generate(){if(this.exists())return;const n=this.getFileUri();this.workspaceEdit.createFile(n,{ignoreIfExists:!0}),a.workspace.applyEdit(this.workspaceEdit).then(()=>{this.InsertContent(n)}),this.insertToGitignore()}static exists(){return i.existsSync(this.getIdeHelperPath())}static InsertContent(n){const t=new a.Position(0,0);this.workspaceEdit.insert(n,t,'<?php\n// @formatter:off\n\n/**\n * A helper file for Laravel, to provide autocomplete information to your IDE\n * Generated for Laravel 7.9.2 on 2020-05-06 23:44:40.\n *\n * This file should not be included in your code, only analyzed by your IDE!\n *\n * @author Barry vd. Heuvel <barryvdh@gmail.com>\n * @see https://github.com/barryvdh/laravel-ide-helper\n */\n\nnamespace Illuminate\\Support\\Facades {\n\n    /**\n     *\n     *\n     * @see \\Illuminate\\Contracts\\Foundation\\Application\n     */    class App {\n\n        /**\n         * Get the version number of the application.\n         *\n         * @return string\n         * @static\n         */        public static function version()\n        {\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        return $instance->version();\n        }\n\n        /**\n         * Run the given array of bootstrap classes.\n         *\n         * @param string[] $bootstrappers\n         * @return void\n         * @static\n         */        public static function bootstrapWith($bootstrappers)\n        {\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        $instance->bootstrapWith($bootstrappers);\n        }\n\n        /**\n         * Register a callback to run after loading the environment.\n         *\n         * @param \\Closure $callback\n         * @return void\n         * @static\n         */        public static function afterLoadingEnvironment($callback)\n        {\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        $instance->afterLoadingEnvironment($callback);\n        }\n\n        /**\n         * Register a callback to run before a bootstrapper.\n         *\n         * @param string $bootstrapper\n         * @param \\Closure $callback\n         * @return void\n         * @static\n         */        public static function beforeBootstrapping($bootstrapper, $callback)\n        {\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        $instance->beforeBootstrapping($bootstrapper, $callback);\n        }\n\n        /**\n         * Register a callback to run after a bootstrapper.\n         *\n         * @param string $bootstrapper\n         * @param \\Closure $callback\n         * @return void\n         * @static\n         */        public static function afterBootstrapping($bootstrapper, $callback)\n        {\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        $instance->afterBootstrapping($bootstrapper, $callback);\n        }\n\n        /**\n         * Determine if the application has been bootstrapped before.\n         *\n         * @return bool\n         * @static\n         */        public static function hasBeenBootstrapped()\n        {\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        return $instance->hasBeenBootstrapped();\n        }\n\n        /**\n         * Set the base path for the application.\n         *\n         * @param string $basePath\n         * @return \\Illuminate\\Foundation\\Application\n         * @static\n         */        public static function setBasePath($basePath)\n        {\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        return $instance->setBasePath($basePath);\n        }\n\n        /**\n         * Get the path to the application "app" directory.\n         *\n         * @param string $path\n         * @return string\n         * @static\n         */        public static function path($path = \'\')\n        {\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        return $instance->path($path);\n        }\n\n        /**\n         * Set the application directory.\n         *\n         * @param string $path\n         * @return \\Illuminate\\Foundation\\Application\n         * @static\n         */        public static function useAppPath($path)\n        {\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        return $instance->useAppPath($path);\n        }\n\n        /**\n         * Get the base path of the Laravel installation.\n         *\n         * @param string $path Optionally, a path to append to the base path\n         * @return string\n         * @static\n         */        public static function basePath($path = \'\')\n        {\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        return $instance->basePath($path);\n        }\n\n        /**\n         * Get the path to the bootstrap directory.\n         *\n         * @param string $path Optionally, a path to append to the bootstrap path\n         * @return string\n         * @static\n         */        public static function bootstrapPath($path = \'\')\n        {\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        return $instance->bootstrapPath($path);\n        }\n\n        /**\n         * Get the path to the application configuration files.\n         *\n         * @param string $path Optionally, a path to append to the config path\n         * @return string\n         * @static\n         */        public static function configPath($path = \'\')\n        {\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        return $instance->configPath($path);\n        }\n\n        /**\n         * Get the path to the database directory.\n         *\n         * @param string $path Optionally, a path to append to the database path\n         * @return string\n         * @static\n         */        public static function databasePath($path = \'\')\n        {\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        return $instance->databasePath($path);\n        }\n\n        /**\n         * Set the database directory.\n         *\n         * @param string $path\n         * @return \\Illuminate\\Foundation\\Application\n         * @static\n         */        public static function useDatabasePath($path)\n        {\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        return $instance->useDatabasePath($path);\n        }\n\n        /**\n         * Get the path to the language files.\n         *\n         * @return string\n         * @static\n         */        public static function langPath()\n        {\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        return $instance->langPath();\n        }\n\n        /**\n         * Get the path to the public / web directory.\n         *\n         * @return string\n         * @static\n         */        public static function publicPath()\n        {\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        return $instance->publicPath();\n        }\n\n        /**\n         * Get the path to the storage directory.\n         *\n         * @return string\n         * @static\n         */        public static function storagePath()\n        {\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        return $instance->storagePath();\n        }\n\n        /**\n         * Set the storage directory.\n         *\n         * @param string $path\n         * @return \\Illuminate\\Foundation\\Application\n         * @static\n         */        public static function useStoragePath($path)\n        {\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        return $instance->useStoragePath($path);\n        }\n\n        /**\n         * Get the path to the resources directory.\n         *\n         * @param string $path\n         * @return string\n         * @static\n         */        public static function resourcePath($path = \'\')\n        {\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        return $instance->resourcePath($path);\n        }\n\n        /**\n         * Get the path to the environment file directory.\n         *\n         * @return string\n         * @static\n         */        public static function environmentPath()\n        {\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        return $instance->environmentPath();\n        }\n\n        /**\n         * Set the directory for the environment file.\n         *\n         * @param string $path\n         * @return \\Illuminate\\Foundation\\Application\n         * @static\n         */        public static function useEnvironmentPath($path)\n        {\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        return $instance->useEnvironmentPath($path);\n        }\n\n        /**\n         * Set the environment file to be loaded during bootstrapping.\n         *\n         * @param string $file\n         * @return \\Illuminate\\Foundation\\Application\n         * @static\n         */        public static function loadEnvironmentFrom($file)\n        {\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        return $instance->loadEnvironmentFrom($file);\n        }\n\n        /**\n         * Get the environment file the application is using.\n         *\n         * @return string\n         * @static\n         */        public static function environmentFile()\n        {\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        return $instance->environmentFile();\n        }\n\n        /**\n         * Get the fully qualified path to the environment file.\n         *\n         * @return string\n         * @static\n         */        public static function environmentFilePath()\n        {\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        return $instance->environmentFilePath();\n        }\n\n        /**\n         * Get or check the current application environment.\n         *\n         * @param string|array $environments\n         * @return string|bool\n         * @static\n         */        public static function environment(...$environments)\n        {\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        return $instance->environment(...$environments);\n        }\n\n        /**\n         * Determine if application is in local environment.\n         *\n         * @return bool\n         * @static\n         */        public static function isLocal()\n        {\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        return $instance->isLocal();\n        }\n\n        /**\n         * Determine if application is in production environment.\n         *\n         * @return bool\n         * @static\n         */        public static function isProduction()\n        {\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        return $instance->isProduction();\n        }\n\n        /**\n         * Detect the application\'s current environment.\n         *\n         * @param \\Closure $callback\n         * @return string\n         * @static\n         */        public static function detectEnvironment($callback)\n        {\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        return $instance->detectEnvironment($callback);\n        }\n\n        /**\n         * Determine if the application is running in the console.\n         *\n         * @return bool\n         * @static\n         */        public static function runningInConsole()\n        {\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        return $instance->runningInConsole();\n        }\n\n        /**\n         * Determine if the application is running unit tests.\n         *\n         * @return bool\n         * @static\n         */        public static function runningUnitTests()\n        {\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        return $instance->runningUnitTests();\n        }\n\n        /**\n         * Register all of the configured providers.\n         *\n         * @return void\n         * @static\n         */        public static function registerConfiguredProviders()\n        {\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        $instance->registerConfiguredProviders();\n        }\n\n        /**\n         * Register a service provider with the application.\n         *\n         * @param \\Illuminate\\Support\\ServiceProvider|string $provider\n         * @param bool $force\n         * @return \\Illuminate\\Support\\ServiceProvider\n         * @static\n         */        public static function register($provider, $force = false)\n        {\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        return $instance->register($provider, $force);\n        }\n\n        /**\n         * Get the registered service provider instance if it exists.\n         *\n         * @param \\Illuminate\\Support\\ServiceProvider|string $provider\n         * @return \\Illuminate\\Support\\ServiceProvider|null\n         * @static\n         */        public static function getProvider($provider)\n        {\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        return $instance->getProvider($provider);\n        }\n\n        /**\n         * Get the registered service provider instances if any exist.\n         *\n         * @param \\Illuminate\\Support\\ServiceProvider|string $provider\n         * @return array\n         * @static\n         */        public static function getProviders($provider)\n        {\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        return $instance->getProviders($provider);\n        }\n\n        /**\n         * Resolve a service provider instance from the class name.\n         *\n         * @param string $provider\n         * @return \\Illuminate\\Support\\ServiceProvider\n         * @static\n         */        public static function resolveProvider($provider)\n        {\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        return $instance->resolveProvider($provider);\n        }\n\n        /**\n         * Load and boot all of the remaining deferred providers.\n         *\n         * @return void\n         * @static\n         */        public static function loadDeferredProviders()\n        {\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        $instance->loadDeferredProviders();\n        }\n\n        /**\n         * Load the provider for a deferred service.\n         *\n         * @param string $service\n         * @return void\n         * @static\n         */        public static function loadDeferredProvider($service)\n        {\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        $instance->loadDeferredProvider($service);\n        }\n\n        /**\n         * Register a deferred provider and service.\n         *\n         * @param string $provider\n         * @param string|null $service\n         * @return void\n         * @static\n         */        public static function registerDeferredProvider($provider, $service = null)\n        {\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        $instance->registerDeferredProvider($provider, $service);\n        }\n\n        /**\n         * Resolve the given type from the container.\n         *\n         * @param string $abstract\n         * @param array $parameters\n         * @return mixed\n         * @static\n         */        public static function make($abstract, $parameters = [])\n        {\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        return $instance->make($abstract, $parameters);\n        }\n\n        /**\n         * Determine if the given abstract type has been bound.\n         *\n         * @param string $abstract\n         * @return bool\n         * @static\n         */        public static function bound($abstract)\n        {\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        return $instance->bound($abstract);\n        }\n\n        /**\n         * Determine if the application has booted.\n         *\n         * @return bool\n         * @static\n         */        public static function isBooted()\n        {\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        return $instance->isBooted();\n        }\n\n        /**\n         * Boot the application\'s service providers.\n         *\n         * @return void\n         * @static\n         */        public static function boot()\n        {\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        $instance->boot();\n        }\n\n        /**\n         * Register a new boot listener.\n         *\n         * @param callable $callback\n         * @return void\n         * @static\n         */        public static function booting($callback)\n        {\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        $instance->booting($callback);\n        }\n\n        /**\n         * Register a new "booted" listener.\n         *\n         * @param callable $callback\n         * @return void\n         * @static\n         */        public static function booted($callback)\n        {\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        $instance->booted($callback);\n        }\n\n        /**\n         * {@inheritdoc}\n         *\n         * @static\n         */        public static function handle($request, $type = 1, $catch = true)\n        {\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        return $instance->handle($request, $type, $catch);\n        }\n\n        /**\n         * Determine if middleware has been disabled for the application.\n         *\n         * @return bool\n         * @static\n         */        public static function shouldSkipMiddleware()\n        {\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        return $instance->shouldSkipMiddleware();\n        }\n\n        /**\n         * Get the path to the cached services.php file.\n         *\n         * @return string\n         * @static\n         */        public static function getCachedServicesPath()\n        {\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        return $instance->getCachedServicesPath();\n        }\n\n        /**\n         * Get the path to the cached packages.php file.\n         *\n         * @return string\n         * @static\n         */        public static function getCachedPackagesPath()\n        {\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        return $instance->getCachedPackagesPath();\n        }\n\n        /**\n         * Determine if the application configuration is cached.\n         *\n         * @return bool\n         * @static\n         */        public static function configurationIsCached()\n        {\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        return $instance->configurationIsCached();\n        }\n\n        /**\n         * Get the path to the configuration cache file.\n         *\n         * @return string\n         * @static\n         */        public static function getCachedConfigPath()\n        {\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        return $instance->getCachedConfigPath();\n        }\n\n        /**\n         * Determine if the application routes are cached.\n         *\n         * @return bool\n         * @static\n         */        public static function routesAreCached()\n        {\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        return $instance->routesAreCached();\n        }\n\n        /**\n         * Get the path to the routes cache file.\n         *\n         * @return string\n         * @static\n         */        public static function getCachedRoutesPath()\n        {\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        return $instance->getCachedRoutesPath();\n        }\n\n        /**\n         * Determine if the application events are cached.\n         *\n         * @return bool\n         * @static\n         */        public static function eventsAreCached()\n        {\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        return $instance->eventsAreCached();\n        }\n\n        /**\n         * Get the path to the events cache file.\n         *\n         * @return string\n         * @static\n         */        public static function getCachedEventsPath()\n        {\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        return $instance->getCachedEventsPath();\n        }\n\n        /**\n         * Add new prefix to list of absolute path prefixes.\n         *\n         * @param string $prefix\n         * @return \\Illuminate\\Foundation\\Application\n         * @static\n         */        public static function addAbsoluteCachePathPrefix($prefix)\n        {\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        return $instance->addAbsoluteCachePathPrefix($prefix);\n        }\n\n        /**\n         * Determine if the application is currently down for maintenance.\n         *\n         * @return bool\n         * @static\n         */        public static function isDownForMaintenance()\n        {\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        return $instance->isDownForMaintenance();\n        }\n\n        /**\n         * Throw an HttpException with the given data.\n         *\n         * @param int $code\n         * @param string $message\n         * @param array $headers\n         * @return void\n         * @throws \\Symfony\\Component\\HttpKernel\\Exception\\HttpException\n         * @throws \\Symfony\\Component\\HttpKernel\\Exception\\NotFoundHttpException\n         * @static\n         */        public static function abort($code, $message = \'\', $headers = [])\n        {\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        $instance->abort($code, $message, $headers);\n        }\n\n        /**\n         * Register a terminating callback with the application.\n         *\n         * @param callable|string $callback\n         * @return \\Illuminate\\Foundation\\Application\n         * @static\n         */        public static function terminating($callback)\n        {\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        return $instance->terminating($callback);\n        }\n\n        /**\n         * Terminate the application.\n         *\n         * @return void\n         * @static\n         */        public static function terminate()\n        {\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        $instance->terminate();\n        }\n\n        /**\n         * Get the service providers that have been loaded.\n         *\n         * @return array\n         * @static\n         */        public static function getLoadedProviders()\n        {\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        return $instance->getLoadedProviders();\n        }\n\n        /**\n         * Get the application\'s deferred services.\n         *\n         * @return array\n         * @static\n         */        public static function getDeferredServices()\n        {\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        return $instance->getDeferredServices();\n        }\n\n        /**\n         * Set the application\'s deferred services.\n         *\n         * @param array $services\n         * @return void\n         * @static\n         */        public static function setDeferredServices($services)\n        {\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        $instance->setDeferredServices($services);\n        }\n\n        /**\n         * Add an array of services to the application\'s deferred services.\n         *\n         * @param array $services\n         * @return void\n         * @static\n         */        public static function addDeferredServices($services)\n        {\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        $instance->addDeferredServices($services);\n        }\n\n        /**\n         * Determine if the given service is a deferred service.\n         *\n         * @param string $service\n         * @return bool\n         * @static\n         */        public static function isDeferredService($service)\n        {\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        return $instance->isDeferredService($service);\n        }\n\n        /**\n         * Configure the real-time facade namespace.\n         *\n         * @param string $namespace\n         * @return void\n         * @static\n         */        public static function provideFacades($namespace)\n        {\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        $instance->provideFacades($namespace);\n        }\n\n        /**\n         * Get the current application locale.\n         *\n         * @return string\n         * @static\n         */        public static function getLocale()\n        {\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        return $instance->getLocale();\n        }\n\n        /**\n         * Set the current application locale.\n         *\n         * @param string $locale\n         * @return void\n         * @static\n         */        public static function setLocale($locale)\n        {\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        $instance->setLocale($locale);\n        }\n\n        /**\n         * Determine if application locale is the given locale.\n         *\n         * @param string $locale\n         * @return bool\n         * @static\n         */        public static function isLocale($locale)\n        {\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        return $instance->isLocale($locale);\n        }\n\n        /**\n         * Register the core class aliases in the container.\n         *\n         * @return void\n         * @static\n         */        public static function registerCoreContainerAliases()\n        {\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        $instance->registerCoreContainerAliases();\n        }\n\n        /**\n         * Flush the container of all bindings and resolved instances.\n         *\n         * @return void\n         * @static\n         */        public static function flush()\n        {\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        $instance->flush();\n        }\n\n        /**\n         * Get the application namespace.\n         *\n         * @return string\n         * @throws \\RuntimeException\n         * @static\n         */        public static function getNamespace()\n        {\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        return $instance->getNamespace();\n        }\n\n        /**\n         * Define a contextual binding.\n         *\n         * @param array|string $concrete\n         * @return \\Illuminate\\Contracts\\Container\\ContextualBindingBuilder\n         * @static\n         */        public static function when($concrete)\n        {\n            //Method inherited from \\Illuminate\\Container\\Container\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        return $instance->when($concrete);\n        }\n\n        /**\n         * Returns true if the container can return an entry for the given identifier.\n         *\n         * Returns false otherwise.\n         *\n         * \'has($id)\' returning true does not mean that \'get($id)\' will not throw an exception.\n         * It does however mean that \'get($id)\' will not throw a \'NotFoundExceptionInterface\'.\n         *\n         * @param string $id Identifier of the entry to look for.\n         * @return bool\n         * @static\n         */        public static function has($id)\n        {\n            //Method inherited from \\Illuminate\\Container\\Container\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        return $instance->has($id);\n        }\n\n        /**\n         * Determine if the given abstract type has been resolved.\n         *\n         * @param string $abstract\n         * @return bool\n         * @static\n         */        public static function resolved($abstract)\n        {\n            //Method inherited from \\Illuminate\\Container\\Container\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        return $instance->resolved($abstract);\n        }\n\n        /**\n         * Determine if a given type is shared.\n         *\n         * @param string $abstract\n         * @return bool\n         * @static\n         */        public static function isShared($abstract)\n        {\n            //Method inherited from \\Illuminate\\Container\\Container\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        return $instance->isShared($abstract);\n        }\n\n        /**\n         * Determine if a given string is an alias.\n         *\n         * @param string $name\n         * @return bool\n         * @static\n         */        public static function isAlias($name)\n        {\n            //Method inherited from \\Illuminate\\Container\\Container\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        return $instance->isAlias($name);\n        }\n\n        /**\n         * Register a binding with the container.\n         *\n         * @param string $abstract\n         * @param \\Closure|string|null $concrete\n         * @param bool $shared\n         * @return void\n         * @static\n         */        public static function bind($abstract, $concrete = null, $shared = false)\n        {\n            //Method inherited from \\Illuminate\\Container\\Container\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        $instance->bind($abstract, $concrete, $shared);\n        }\n\n        /**\n         * Determine if the container has a method binding.\n         *\n         * @param string $method\n         * @return bool\n         * @static\n         */        public static function hasMethodBinding($method)\n        {\n            //Method inherited from \\Illuminate\\Container\\Container\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        return $instance->hasMethodBinding($method);\n        }\n\n        /**\n         * Bind a callback to resolve with Container::call.\n         *\n         * @param array|string $method\n         * @param \\Closure $callback\n         * @return void\n         * @static\n         */        public static function bindMethod($method, $callback)\n        {\n            //Method inherited from \\Illuminate\\Container\\Container\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        $instance->bindMethod($method, $callback);\n        }\n\n        /**\n         * Get the method binding for the given method.\n         *\n         * @param string $method\n         * @param mixed $instance\n         * @return mixed\n         * @static\n         */        public static function callMethodBinding($method, $instance)\n        {\n            //Method inherited from \\Illuminate\\Container\\Container\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        return $instance->callMethodBinding($method, $instance);\n        }\n\n        /**\n         * Add a contextual binding to the container.\n         *\n         * @param string $concrete\n         * @param string $abstract\n         * @param \\Closure|string $implementation\n         * @return void\n         * @static\n         */        public static function addContextualBinding($concrete, $abstract, $implementation)\n        {\n            //Method inherited from \\Illuminate\\Container\\Container\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        $instance->addContextualBinding($concrete, $abstract, $implementation);\n        }\n\n        /**\n         * Register a binding if it hasn\'t already been registered.\n         *\n         * @param string $abstract\n         * @param \\Closure|string|null $concrete\n         * @param bool $shared\n         * @return void\n         * @static\n         */        public static function bindIf($abstract, $concrete = null, $shared = false)\n        {\n            //Method inherited from \\Illuminate\\Container\\Container\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        $instance->bindIf($abstract, $concrete, $shared);\n        }\n\n        /**\n         * Register a shared binding in the container.\n         *\n         * @param string $abstract\n         * @param \\Closure|string|null $concrete\n         * @return void\n         * @static\n         */        public static function singleton($abstract, $concrete = null)\n        {\n            //Method inherited from \\Illuminate\\Container\\Container\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        $instance->singleton($abstract, $concrete);\n        }\n\n        /**\n         * Register a shared binding if it hasn\'t already been registered.\n         *\n         * @param string $abstract\n         * @param \\Closure|string|null $concrete\n         * @return void\n         * @static\n         */        public static function singletonIf($abstract, $concrete = null)\n        {\n            //Method inherited from \\Illuminate\\Container\\Container\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        $instance->singletonIf($abstract, $concrete);\n        }\n\n        /**\n         * "Extend" an abstract type in the container.\n         *\n         * @param string $abstract\n         * @param \\Closure $closure\n         * @return void\n         * @throws \\InvalidArgumentException\n         * @static\n         */        public static function extend($abstract, $closure)\n        {\n            //Method inherited from \\Illuminate\\Container\\Container\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        $instance->extend($abstract, $closure);\n        }\n\n        /**\n         * Register an existing instance as shared in the container.\n         *\n         * @param string $abstract\n         * @param mixed $instance\n         * @return mixed\n         * @static\n         */        public static function instance($abstract, $instance)\n        {\n            //Method inherited from \\Illuminate\\Container\\Container\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        return $instance->instance($abstract, $instance);\n        }\n\n        /**\n         * Assign a set of tags to a given binding.\n         *\n         * @param array|string $abstracts\n         * @param array|mixed $tags\n         * @return void\n         * @static\n         */        public static function tag($abstracts, $tags)\n        {\n            //Method inherited from \\Illuminate\\Container\\Container\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        $instance->tag($abstracts, $tags);\n        }\n\n        /**\n         * Resolve all of the bindings for a given tag.\n         *\n         * @param string $tag\n         * @return \\Illuminate\\Container\\iterable\n         * @static\n         */        public static function tagged($tag)\n        {\n            //Method inherited from \\Illuminate\\Container\\Container\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        return $instance->tagged($tag);\n        }\n\n        /**\n         * Alias a type to a different name.\n         *\n         * @param string $abstract\n         * @param string $alias\n         * @return void\n         * @throws \\LogicException\n         * @static\n         */        public static function alias($abstract, $alias)\n        {\n            //Method inherited from \\Illuminate\\Container\\Container\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        $instance->alias($abstract, $alias);\n        }\n\n        /**\n         * Bind a new callback to an abstract\'s rebind event.\n         *\n         * @param string $abstract\n         * @param \\Closure $callback\n         * @return mixed\n         * @static\n         */        public static function rebinding($abstract, $callback)\n        {\n            //Method inherited from \\Illuminate\\Container\\Container\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        return $instance->rebinding($abstract, $callback);\n        }\n\n        /**\n         * Refresh an instance on the given target and method.\n         *\n         * @param string $abstract\n         * @param mixed $target\n         * @param string $method\n         * @return mixed\n         * @static\n         */        public static function refresh($abstract, $target, $method)\n        {\n            //Method inherited from \\Illuminate\\Container\\Container\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        return $instance->refresh($abstract, $target, $method);\n        }\n\n        /**\n         * Wrap the given closure such that its dependencies will be injected when executed.\n         *\n         * @param \\Closure $callback\n         * @param array $parameters\n         * @return \\Closure\n         * @static\n         */        public static function wrap($callback, $parameters = [])\n        {\n            //Method inherited from \\Illuminate\\Container\\Container\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        return $instance->wrap($callback, $parameters);\n        }\n\n        /**\n         * Call the given Closure / class@method and inject its dependencies.\n         *\n         * @param callable|string $callback\n         * @param \\Illuminate\\Container\\array<string,  mixed>  $parameters\n         * @param string|null $defaultMethod\n         * @return mixed\n         * @throws \\InvalidArgumentException\n         * @static\n         */        public static function call($callback, $parameters = [], $defaultMethod = null)\n        {\n            //Method inherited from \\Illuminate\\Container\\Container\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        return $instance->call($callback, $parameters, $defaultMethod);\n        }\n\n        /**\n         * Get a closure to resolve the given type from the container.\n         *\n         * @param string $abstract\n         * @return \\Closure\n         * @static\n         */        public static function factory($abstract)\n        {\n            //Method inherited from \\Illuminate\\Container\\Container\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        return $instance->factory($abstract);\n        }\n\n        /**\n         * An alias function name for make().\n         *\n         * @param string $abstract\n         * @param array $parameters\n         * @return mixed\n         * @throws \\Illuminate\\Contracts\\Container\\BindingResolutionException\n         * @static\n         */        public static function makeWith($abstract, $parameters = [])\n        {\n            //Method inherited from \\Illuminate\\Container\\Container\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        return $instance->makeWith($abstract, $parameters);\n        }\n\n        /**\n         * Finds an entry of the container by its identifier and returns it.\n         *\n         * @param string $id Identifier of the entry to look for.\n         * @throws NotFoundExceptionInterface  No entry was found for **this** identifier.\n         * @throws ContainerExceptionInterface Error while retrieving the entry.\n         * @return mixed Entry.\n         * @static\n         */        public static function get($id)\n        {\n            //Method inherited from \\Illuminate\\Container\\Container\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        return $instance->get($id);\n        }\n\n        /**\n         * Instantiate a concrete instance of the given type.\n         *\n         * @param \\Closure|string $concrete\n         * @return mixed\n         * @throws \\Illuminate\\Contracts\\Container\\BindingResolutionException\n         * @static\n         */        public static function build($concrete)\n        {\n            //Method inherited from \\Illuminate\\Container\\Container\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        return $instance->build($concrete);\n        }\n\n        /**\n         * Register a new resolving callback.\n         *\n         * @param \\Closure|string $abstract\n         * @param \\Closure|null $callback\n         * @return void\n         * @static\n         */        public static function resolving($abstract, $callback = null)\n        {\n            //Method inherited from \\Illuminate\\Container\\Container\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        $instance->resolving($abstract, $callback);\n        }\n\n        /**\n         * Register a new after resolving callback for all types.\n         *\n         * @param \\Closure|string $abstract\n         * @param \\Closure|null $callback\n         * @return void\n         * @static\n         */        public static function afterResolving($abstract, $callback = null)\n        {\n            //Method inherited from \\Illuminate\\Container\\Container\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        $instance->afterResolving($abstract, $callback);\n        }\n\n        /**\n         * Get the container\'s bindings.\n         *\n         * @return array\n         * @static\n         */        public static function getBindings()\n        {\n            //Method inherited from \\Illuminate\\Container\\Container\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        return $instance->getBindings();\n        }\n\n        /**\n         * Get the alias for an abstract if available.\n         *\n         * @param string $abstract\n         * @return string\n         * @static\n         */        public static function getAlias($abstract)\n        {\n            //Method inherited from \\Illuminate\\Container\\Container\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        return $instance->getAlias($abstract);\n        }\n\n        /**\n         * Remove all of the extender callbacks for a given type.\n         *\n         * @param string $abstract\n         * @return void\n         * @static\n         */        public static function forgetExtenders($abstract)\n        {\n            //Method inherited from \\Illuminate\\Container\\Container\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        $instance->forgetExtenders($abstract);\n        }\n\n        /**\n         * Remove a resolved instance from the instance cache.\n         *\n         * @param string $abstract\n         * @return void\n         * @static\n         */        public static function forgetInstance($abstract)\n        {\n            //Method inherited from \\Illuminate\\Container\\Container\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        $instance->forgetInstance($abstract);\n        }\n\n        /**\n         * Clear all of the instances from the container.\n         *\n         * @return void\n         * @static\n         */        public static function forgetInstances()\n        {\n            //Method inherited from \\Illuminate\\Container\\Container\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        $instance->forgetInstances();\n        }\n\n        /**\n         * Get the globally available instance of the container.\n         *\n         * @return static\n         * @static\n         */        public static function getInstance()\n        {\n            //Method inherited from \\Illuminate\\Container\\Container\n                        return \\Illuminate\\Foundation\\Application::getInstance();\n        }\n\n        /**\n         * Set the shared instance of the container.\n         *\n         * @param \\Illuminate\\Contracts\\Container\\Container|null $container\n         * @return \\Illuminate\\Contracts\\Container\\Container|static\n         * @static\n         */        public static function setInstance($container = null)\n        {\n            //Method inherited from \\Illuminate\\Container\\Container\n                        return \\Illuminate\\Foundation\\Application::setInstance($container);\n        }\n\n        /**\n         * Determine if a given offset exists.\n         *\n         * @param string $key\n         * @return bool\n         * @static\n         */        public static function offsetExists($key)\n        {\n            //Method inherited from \\Illuminate\\Container\\Container\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        return $instance->offsetExists($key);\n        }\n\n        /**\n         * Get the value at a given offset.\n         *\n         * @param string $key\n         * @return mixed\n         * @static\n         */        public static function offsetGet($key)\n        {\n            //Method inherited from \\Illuminate\\Container\\Container\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        return $instance->offsetGet($key);\n        }\n\n        /**\n         * Set the value at a given offset.\n         *\n         * @param string $key\n         * @param mixed $value\n         * @return void\n         * @static\n         */        public static function offsetSet($key, $value)\n        {\n            //Method inherited from \\Illuminate\\Container\\Container\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        $instance->offsetSet($key, $value);\n        }\n\n        /**\n         * Unset the value at a given offset.\n         *\n         * @param string $key\n         * @return void\n         * @static\n         */        public static function offsetUnset($key)\n        {\n            //Method inherited from \\Illuminate\\Container\\Container\n                        /** @var \\Illuminate\\Foundation\\Application $instance */\n                        $instance->offsetUnset($key);\n        }\n            }\n\n    /**\n     *\n     *\n     * @see \\Illuminate\\Contracts\\Console\\Kernel\n     */    class Artisan {\n\n        /**\n         * Run the console application.\n         *\n         * @param \\Symfony\\Component\\Console\\Input\\InputInterface $input\n         * @param \\Symfony\\Component\\Console\\Output\\OutputInterface|null $output\n         * @return int\n         * @static\n         */        public static function handle($input, $output = null)\n        {\n            //Method inherited from \\Illuminate\\Foundation\\Console\\Kernel\n                        /** @var \\App\\Console\\Kernel $instance */\n                        return $instance->handle($input, $output);\n        }\n\n        /**\n         * Terminate the application.\n         *\n         * @param \\Symfony\\Component\\Console\\Input\\InputInterface $input\n         * @param int $status\n         * @return void\n         * @static\n         */        public static function terminate($input, $status)\n        {\n            //Method inherited from \\Illuminate\\Foundation\\Console\\Kernel\n                        /** @var \\App\\Console\\Kernel $instance */\n                        $instance->terminate($input, $status);\n        }\n\n        /**\n         * Register a Closure based command with the application.\n         *\n         * @param string $signature\n         * @param \\Closure $callback\n         * @return \\Illuminate\\Foundation\\Console\\ClosureCommand\n         * @static\n         */        public static function command($signature, $callback)\n        {\n            //Method inherited from \\Illuminate\\Foundation\\Console\\Kernel\n                        /** @var \\App\\Console\\Kernel $instance */\n                        return $instance->command($signature, $callback);\n        }\n\n        /**\n         * Register the given command with the console application.\n         *\n         * @param \\Symfony\\Component\\Console\\Command\\Command $command\n         * @return void\n         * @static\n         */        public static function registerCommand($command)\n        {\n            //Method inherited from \\Illuminate\\Foundation\\Console\\Kernel\n                        /** @var \\App\\Console\\Kernel $instance */\n                        $instance->registerCommand($command);\n        }\n\n        /**\n         * Run an Artisan console command by name.\n         *\n         * @param string $command\n         * @param array $parameters\n         * @param \\Symfony\\Component\\Console\\Output\\OutputInterface|null $outputBuffer\n         * @return int\n         * @throws \\Symfony\\Component\\Console\\Exception\\CommandNotFoundException\n         * @static\n         */        public static function call($command, $parameters = [], $outputBuffer = null)\n        {\n            //Method inherited from \\Illuminate\\Foundation\\Console\\Kernel\n                        /** @var \\App\\Console\\Kernel $instance */\n                        return $instance->call($command, $parameters, $outputBuffer);\n        }\n\n        /**\n         * Queue the given console command.\n         *\n         * @param string $command\n         * @param array $parameters\n         * @return \\Illuminate\\Foundation\\Bus\\PendingDispatch\n         * @static\n         */        public static function queue($command, $parameters = [])\n        {\n            //Method inherited from \\Illuminate\\Foundation\\Console\\Kernel\n                        /** @var \\App\\Console\\Kernel $instance */\n                        return $instance->queue($command, $parameters);\n        }\n\n        /**\n         * Get all of the commands registered with the console.\n         *\n         * @return array\n         * @static\n         */        public static function all()\n        {\n            //Method inherited from \\Illuminate\\Foundation\\Console\\Kernel\n                        /** @var \\App\\Console\\Kernel $instance */\n                        return $instance->all();\n        }\n\n        /**\n         * Get the output for the last run command.\n         *\n         * @return string\n         * @static\n         */        public static function output()\n        {\n            //Method inherited from \\Illuminate\\Foundation\\Console\\Kernel\n                        /** @var \\App\\Console\\Kernel $instance */\n                        return $instance->output();\n        }\n\n        /**\n         * Bootstrap the application for artisan commands.\n         *\n         * @return void\n         * @static\n         */        public static function bootstrap()\n        {\n            //Method inherited from \\Illuminate\\Foundation\\Console\\Kernel\n                        /** @var \\App\\Console\\Kernel $instance */\n                        $instance->bootstrap();\n        }\n\n        /**\n         * Set the Artisan application instance.\n         *\n         * @param \\Illuminate\\Console\\Application $artisan\n         * @return void\n         * @static\n         */        public static function setArtisan($artisan)\n        {\n            //Method inherited from \\Illuminate\\Foundation\\Console\\Kernel\n                        /** @var \\App\\Console\\Kernel $instance */\n                        $instance->setArtisan($artisan);\n        }\n            }\n\n    /**\n     *\n     *\n     * @see \\Illuminate\\Auth\\AuthManager\n     * @see \\Illuminate\\Contracts\\Auth\\Factory\n     * @see \\Illuminate\\Contracts\\Auth\\Guard\n     * @see \\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */    class Auth {\n\n        /**\n         * Attempt to get the guard from the local cache.\n         *\n         * @param string|null $name\n         * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n         * @static\n         */        public static function guard($name = null)\n        {\n                        /** @var \\Illuminate\\Auth\\AuthManager $instance */\n                        return $instance->guard($name);\n        }\n\n        /**\n         * Create a session based authentication guard.\n         *\n         * @param string $name\n         * @param array $config\n         * @return \\Illuminate\\Auth\\SessionGuard\n         * @static\n         */        public static function createSessionDriver($name, $config)\n        {\n                        /** @var \\Illuminate\\Auth\\AuthManager $instance */\n                        return $instance->createSessionDriver($name, $config);\n        }\n\n        /**\n         * Create a token based authentication guard.\n         *\n         * @param string $name\n         * @param array $config\n         * @return \\Illuminate\\Auth\\TokenGuard\n         * @static\n         */        public static function createTokenDriver($name, $config)\n        {\n                        /** @var \\Illuminate\\Auth\\AuthManager $instance */\n                        return $instance->createTokenDriver($name, $config);\n        }\n\n        /**\n         * Get the default authentication driver name.\n         *\n         * @return string\n         * @static\n         */        public static function getDefaultDriver()\n        {\n                        /** @var \\Illuminate\\Auth\\AuthManager $instance */\n                        return $instance->getDefaultDriver();\n        }\n\n        /**\n         * Set the default guard driver the factory should serve.\n         *\n         * @param string $name\n         * @return void\n         * @static\n         */        public static function shouldUse($name)\n        {\n                        /** @var \\Illuminate\\Auth\\AuthManager $instance */\n                        $instance->shouldUse($name);\n        }\n\n        /**\n         * Set the default authentication driver name.\n         *\n         * @param string $name\n         * @return void\n         * @static\n         */        public static function setDefaultDriver($name)\n        {\n                        /** @var \\Illuminate\\Auth\\AuthManager $instance */\n                        $instance->setDefaultDriver($name);\n        }\n\n        /**\n         * Register a new callback based request guard.\n         *\n         * @param string $driver\n         * @param callable $callback\n         * @return \\Illuminate\\Auth\\AuthManager\n         * @static\n         */        public static function viaRequest($driver, $callback)\n        {\n                        /** @var \\Illuminate\\Auth\\AuthManager $instance */\n                        return $instance->viaRequest($driver, $callback);\n        }\n\n        /**\n         * Get the user resolver callback.\n         *\n         * @return \\Closure\n         * @static\n         */        public static function userResolver()\n        {\n                        /** @var \\Illuminate\\Auth\\AuthManager $instance */\n                        return $instance->userResolver();\n        }\n\n        /**\n         * Set the callback to be used to resolve users.\n         *\n         * @param \\Closure $userResolver\n         * @return \\Illuminate\\Auth\\AuthManager\n         * @static\n         */        public static function resolveUsersUsing($userResolver)\n        {\n                        /** @var \\Illuminate\\Auth\\AuthManager $instance */\n                        return $instance->resolveUsersUsing($userResolver);\n        }\n\n        /**\n         * Register a custom driver creator Closure.\n         *\n         * @param string $driver\n         * @param \\Closure $callback\n         * @return \\Illuminate\\Auth\\AuthManager\n         * @static\n         */        public static function extend($driver, $callback)\n        {\n                        /** @var \\Illuminate\\Auth\\AuthManager $instance */\n                        return $instance->extend($driver, $callback);\n        }\n\n        /**\n         * Register a custom provider creator Closure.\n         *\n         * @param string $name\n         * @param \\Closure $callback\n         * @return \\Illuminate\\Auth\\AuthManager\n         * @static\n         */        public static function provider($name, $callback)\n        {\n                        /** @var \\Illuminate\\Auth\\AuthManager $instance */\n                        return $instance->provider($name, $callback);\n        }\n\n        /**\n         * Determines if any guards have already been resolved.\n         *\n         * @return bool\n         * @static\n         */        public static function hasResolvedGuards()\n        {\n                        /** @var \\Illuminate\\Auth\\AuthManager $instance */\n                        return $instance->hasResolvedGuards();\n        }\n\n        /**\n         * Create the user provider implementation for the driver.\n         *\n         * @param string|null $provider\n         * @return \\Illuminate\\Contracts\\Auth\\UserProvider|null\n         * @throws \\InvalidArgumentException\n         * @static\n         */        public static function createUserProvider($provider = null)\n        {\n                        /** @var \\Illuminate\\Auth\\AuthManager $instance */\n                        return $instance->createUserProvider($provider);\n        }\n\n        /**\n         * Get the default user provider name.\n         *\n         * @return string\n         * @static\n         */        public static function getDefaultUserProvider()\n        {\n                        /** @var \\Illuminate\\Auth\\AuthManager $instance */\n                        return $instance->getDefaultUserProvider();\n        }\n\n        /**\n         * Get the currently authenticated user.\n         *\n         * @return \\App\\User|null\n         * @static\n         */        public static function user()\n        {\n                        /** @var \\Illuminate\\Auth\\SessionGuard $instance */\n                        return $instance->user();\n        }\n\n        /**\n         * Get the ID for the currently authenticated user.\n         *\n         * @return int|string|null\n         * @static\n         */        public static function id()\n        {\n                        /** @var \\Illuminate\\Auth\\SessionGuard $instance */\n                        return $instance->id();\n        }\n\n        /**\n         * Log a user into the application without sessions or cookies.\n         *\n         * @param array $credentials\n         * @return bool\n         * @static\n         */        public static function once($credentials = [])\n        {\n                        /** @var \\Illuminate\\Auth\\SessionGuard $instance */\n                        return $instance->once($credentials);\n        }\n\n        /**\n         * Log the given user ID into the application without sessions or cookies.\n         *\n         * @param mixed $id\n         * @return \\App\\User|false\n         * @static\n         */        public static function onceUsingId($id)\n        {\n                        /** @var \\Illuminate\\Auth\\SessionGuard $instance */\n                        return $instance->onceUsingId($id);\n        }\n\n        /**\n         * Validate a user\'s credentials.\n         *\n         * @param array $credentials\n         * @return bool\n         * @static\n         */        public static function validate($credentials = [])\n        {\n                        /** @var \\Illuminate\\Auth\\SessionGuard $instance */\n                        return $instance->validate($credentials);\n        }\n\n        /**\n         * Attempt to authenticate using HTTP Basic Auth.\n         *\n         * @param string $field\n         * @param array $extraConditions\n         * @return \\Symfony\\Component\\HttpFoundation\\Response|null\n         * @static\n         */        public static function basic($field = \'email\', $extraConditions = [])\n        {\n                        /** @var \\Illuminate\\Auth\\SessionGuard $instance */\n                        return $instance->basic($field, $extraConditions);\n        }\n\n        /**\n         * Perform a stateless HTTP Basic login attempt.\n         *\n         * @param string $field\n         * @param array $extraConditions\n         * @return \\Symfony\\Component\\HttpFoundation\\Response|null\n         * @static\n         */        public static function onceBasic($field = \'email\', $extraConditions = [])\n        {\n                        /** @var \\Illuminate\\Auth\\SessionGuard $instance */\n                        return $instance->onceBasic($field, $extraConditions);\n        }\n\n        /**\n         * Attempt to authenticate a user using the given credentials.\n         *\n         * @param array $credentials\n         * @param bool $remember\n         * @return bool\n         * @static\n         */        public static function attempt($credentials = [], $remember = false)\n        {\n                        /** @var \\Illuminate\\Auth\\SessionGuard $instance */\n                        return $instance->attempt($credentials, $remember);\n        }\n\n        /**\n         * Log the given user ID into the application.\n         *\n         * @param mixed $id\n         * @param bool $remember\n         * @return \\App\\User|false\n         * @static\n         */        public static function loginUsingId($id, $remember = false)\n        {\n                        /** @var \\Illuminate\\Auth\\SessionGuard $instance */\n                        return $instance->loginUsingId($id, $remember);\n        }\n\n        /**\n         * Log a user into the application.\n         *\n         * @param \\Illuminate\\Contracts\\Auth\\Authenticatable $user\n         * @param bool $remember\n         * @return void\n         * @static\n         */        public static function login($user, $remember = false)\n        {\n                        /** @var \\Illuminate\\Auth\\SessionGuard $instance */\n                        $instance->login($user, $remember);\n        }\n\n        /**\n         * Log the user out of the application.\n         *\n         * @return void\n         * @static\n         */        public static function logout()\n        {\n                        /** @var \\Illuminate\\Auth\\SessionGuard $instance */\n                        $instance->logout();\n        }\n\n        /**\n         * Log the user out of the application on their current device only.\n         *\n         * @return void\n         * @static\n         */        public static function logoutCurrentDevice()\n        {\n                        /** @var \\Illuminate\\Auth\\SessionGuard $instance */\n                        $instance->logoutCurrentDevice();\n        }\n\n        /**\n         * Invalidate other sessions for the current user.\n         *\n         * The application must be using the AuthenticateSession middleware.\n         *\n         * @param string $password\n         * @param string $attribute\n         * @return bool|null\n         * @static\n         */        public static function logoutOtherDevices($password, $attribute = \'password\')\n        {\n                        /** @var \\Illuminate\\Auth\\SessionGuard $instance */\n                        return $instance->logoutOtherDevices($password, $attribute);\n        }\n\n        /**\n         * Register an authentication attempt event listener.\n         *\n         * @param mixed $callback\n         * @return void\n         * @static\n         */        public static function attempting($callback)\n        {\n                        /** @var \\Illuminate\\Auth\\SessionGuard $instance */\n                        $instance->attempting($callback);\n        }\n\n        /**\n         * Get the last user we attempted to authenticate.\n         *\n         * @return \\App\\User\n         * @static\n         */        public static function getLastAttempted()\n        {\n                        /** @var \\Illuminate\\Auth\\SessionGuard $instance */\n                        return $instance->getLastAttempted();\n        }\n\n        /**\n         * Get a unique identifier for the auth session value.\n         *\n         * @return string\n         * @static\n         */        public static function getName()\n        {\n                        /** @var \\Illuminate\\Auth\\SessionGuard $instance */\n                        return $instance->getName();\n        }\n\n        /**\n         * Get the name of the cookie used to store the "recaller".\n         *\n         * @return string\n         * @static\n         */        public static function getRecallerName()\n        {\n                        /** @var \\Illuminate\\Auth\\SessionGuard $instance */\n                        return $instance->getRecallerName();\n        }\n\n        /**\n         * Determine if the user was authenticated via "remember me" cookie.\n         *\n         * @return bool\n         * @static\n         */        public static function viaRemember()\n        {\n                        /** @var \\Illuminate\\Auth\\SessionGuard $instance */\n                        return $instance->viaRemember();\n        }\n\n        /**\n         * Get the cookie creator instance used by the guard.\n         *\n         * @return \\Illuminate\\Contracts\\Cookie\\QueueingFactory\n         * @throws \\RuntimeException\n         * @static\n         */        public static function getCookieJar()\n        {\n                        /** @var \\Illuminate\\Auth\\SessionGuard $instance */\n                        return $instance->getCookieJar();\n        }\n\n        /**\n         * Set the cookie creator instance used by the guard.\n         *\n         * @param \\Illuminate\\Contracts\\Cookie\\QueueingFactory $cookie\n         * @return void\n         * @static\n         */        public static function setCookieJar($cookie)\n        {\n                        /** @var \\Illuminate\\Auth\\SessionGuard $instance */\n                        $instance->setCookieJar($cookie);\n        }\n\n        /**\n         * Get the event dispatcher instance.\n         *\n         * @return \\Illuminate\\Contracts\\Events\\Dispatcher\n         * @static\n         */        public static function getDispatcher()\n        {\n                        /** @var \\Illuminate\\Auth\\SessionGuard $instance */\n                        return $instance->getDispatcher();\n        }\n\n        /**\n         * Set the event dispatcher instance.\n         *\n         * @param \\Illuminate\\Contracts\\Events\\Dispatcher $events\n         * @return void\n         * @static\n         */        public static function setDispatcher($events)\n        {\n                        /** @var \\Illuminate\\Auth\\SessionGuard $instance */\n                        $instance->setDispatcher($events);\n        }\n\n        /**\n         * Get the session store used by the guard.\n         *\n         * @return \\Illuminate\\Contracts\\Session\\Session\n         * @static\n         */        public static function getSession()\n        {\n                        /** @var \\Illuminate\\Auth\\SessionGuard $instance */\n                        return $instance->getSession();\n        }\n\n        /**\n         * Return the currently cached user.\n         *\n         * @return \\App\\User|null\n         * @static\n         */        public static function getUser()\n        {\n                        /** @var \\Illuminate\\Auth\\SessionGuard $instance */\n                        return $instance->getUser();\n        }\n\n        /**\n         * Set the current user.\n         *\n         * @param \\Illuminate\\Contracts\\Auth\\Authenticatable $user\n         * @return \\Illuminate\\Auth\\SessionGuard\n         * @static\n         */        public static function setUser($user)\n        {\n                        /** @var \\Illuminate\\Auth\\SessionGuard $instance */\n                        return $instance->setUser($user);\n        }\n\n        /**\n         * Get the current request instance.\n         *\n         * @return \\Symfony\\Component\\HttpFoundation\\Request\n         * @static\n         */        public static function getRequest()\n        {\n                        /** @var \\Illuminate\\Auth\\SessionGuard $instance */\n                        return $instance->getRequest();\n        }\n\n        /**\n         * Set the current request instance.\n         *\n         * @param \\Symfony\\Component\\HttpFoundation\\Request $request\n         * @return \\Illuminate\\Auth\\SessionGuard\n         * @static\n         */        public static function setRequest($request)\n        {\n                        /** @var \\Illuminate\\Auth\\SessionGuard $instance */\n                        return $instance->setRequest($request);\n        }\n\n        /**\n         * Determine if current user is authenticated. If not, throw an exception.\n         *\n         * @return \\App\\User\n         * @throws \\Illuminate\\Auth\\AuthenticationException\n         * @static\n         */        public static function authenticate()\n        {\n                        /** @var \\Illuminate\\Auth\\SessionGuard $instance */\n                        return $instance->authenticate();\n        }\n\n        /**\n         * Determine if the guard has a user instance.\n         *\n         * @return bool\n         * @static\n         */        public static function hasUser()\n        {\n                        /** @var \\Illuminate\\Auth\\SessionGuard $instance */\n                        return $instance->hasUser();\n        }\n\n        /**\n         * Determine if the current user is authenticated.\n         *\n         * @return bool\n         * @static\n         */        public static function check()\n        {\n                        /** @var \\Illuminate\\Auth\\SessionGuard $instance */\n                        return $instance->check();\n        }\n\n        /**\n         * Determine if the current user is a guest.\n         *\n         * @return bool\n         * @static\n         */        public static function guest()\n        {\n                        /** @var \\Illuminate\\Auth\\SessionGuard $instance */\n                        return $instance->guest();\n        }\n\n        /**\n         * Get the user provider used by the guard.\n         *\n         * @return \\Illuminate\\Contracts\\Auth\\UserProvider\n         * @static\n         */        public static function getProvider()\n        {\n                        /** @var \\Illuminate\\Auth\\SessionGuard $instance */\n                        return $instance->getProvider();\n        }\n\n        /**\n         * Set the user provider used by the guard.\n         *\n         * @param \\Illuminate\\Contracts\\Auth\\UserProvider $provider\n         * @return void\n         * @static\n         */        public static function setProvider($provider)\n        {\n                        /** @var \\Illuminate\\Auth\\SessionGuard $instance */\n                        $instance->setProvider($provider);\n        }\n\n        /**\n         * Register a custom macro.\n         *\n         * @param string $name\n         * @param object|callable $macro\n         * @return void\n         * @static\n         */        public static function macro($name, $macro)\n        {\n                        \\Illuminate\\Auth\\SessionGuard::macro($name, $macro);\n        }\n\n        /**\n         * Mix another object into the class.\n         *\n         * @param object $mixin\n         * @param bool $replace\n         * @return void\n         * @throws \\ReflectionException\n         * @static\n         */        public static function mixin($mixin, $replace = true)\n        {\n                        \\Illuminate\\Auth\\SessionGuard::mixin($mixin, $replace);\n        }\n\n        /**\n         * Checks if macro is registered.\n         *\n         * @param string $name\n         * @return bool\n         * @static\n         */        public static function hasMacro($name)\n        {\n                        return \\Illuminate\\Auth\\SessionGuard::hasMacro($name);\n        }\n            }\n\n    /**\n     *\n     *\n     * @see \\Illuminate\\View\\Compilers\\BladeCompiler\n     */    class Blade {\n\n        /**\n         * Compile the view at the given path.\n         *\n         * @param string|null $path\n         * @return void\n         * @static\n         */        public static function compile($path = null)\n        {\n                        /** @var \\Illuminate\\View\\Compilers\\BladeCompiler $instance */\n                        $instance->compile($path);\n        }\n\n        /**\n         * Get the path currently being compiled.\n         *\n         * @return string\n         * @static\n         */        public static function getPath()\n        {\n                        /** @var \\Illuminate\\View\\Compilers\\BladeCompiler $instance */\n                        return $instance->getPath();\n        }\n\n        /**\n         * Set the path currently being compiled.\n         *\n         * @param string $path\n         * @return void\n         * @static\n         */        public static function setPath($path)\n        {\n                        /** @var \\Illuminate\\View\\Compilers\\BladeCompiler $instance */\n                        $instance->setPath($path);\n        }\n\n        /**\n         * Compile the given Blade template contents.\n         *\n         * @param string $value\n         * @return string\n         * @static\n         */        public static function compileString($value)\n        {\n                        /** @var \\Illuminate\\View\\Compilers\\BladeCompiler $instance */\n                        return $instance->compileString($value);\n        }\n\n        /**\n         * Strip the parentheses from the given expression.\n         *\n         * @param string $expression\n         * @return string\n         * @static\n         */        public static function stripParentheses($expression)\n        {\n                        /** @var \\Illuminate\\View\\Compilers\\BladeCompiler $instance */\n                        return $instance->stripParentheses($expression);\n        }\n\n        /**\n         * Register a custom Blade compiler.\n         *\n         * @param callable $compiler\n         * @return void\n         * @static\n         */        public static function extend($compiler)\n        {\n                        /** @var \\Illuminate\\View\\Compilers\\BladeCompiler $instance */\n                        $instance->extend($compiler);\n        }\n\n        /**\n         * Get the extensions used by the compiler.\n         *\n         * @return array\n         * @static\n         */        public static function getExtensions()\n        {\n                        /** @var \\Illuminate\\View\\Compilers\\BladeCompiler $instance */\n                        return $instance->getExtensions();\n        }\n\n        /**\n         * Register an "if" statement directive.\n         *\n         * @param string $name\n         * @param callable $callback\n         * @return void\n         * @static\n         */        public static function if($name, $callback)\n        {\n                        /** @var \\Illuminate\\View\\Compilers\\BladeCompiler $instance */\n                        $instance->if($name, $callback);\n        }\n\n        /**\n         * Check the result of a condition.\n         *\n         * @param string $name\n         * @param array $parameters\n         * @return bool\n         * @static\n         */        public static function check($name, ...$parameters)\n        {\n                        /** @var \\Illuminate\\View\\Compilers\\BladeCompiler $instance */\n                        return $instance->check($name, ...$parameters);\n        }\n\n        /**\n         * Register a class-based component alias directive.\n         *\n         * @param string $class\n         * @param string|null $alias\n         * @param string $prefix\n         * @return void\n         * @static\n         */        public static function component($class, $alias = null, $prefix = \'\')\n        {\n                        /** @var \\Illuminate\\View\\Compilers\\BladeCompiler $instance */\n                        $instance->component($class, $alias, $prefix);\n        }\n\n        /**\n         * Register an array of class-based components.\n         *\n         * @param array $components\n         * @param string $prefix\n         * @return void\n         * @static\n         */        public static function components($components, $prefix = \'\')\n        {\n                        /** @var \\Illuminate\\View\\Compilers\\BladeCompiler $instance */\n                        $instance->components($components, $prefix);\n        }\n\n        /**\n         * Get the registered class component aliases.\n         *\n         * @return array\n         * @static\n         */        public static function getClassComponentAliases()\n        {\n                        /** @var \\Illuminate\\View\\Compilers\\BladeCompiler $instance */\n                        return $instance->getClassComponentAliases();\n        }\n\n        /**\n         * Register a component alias directive.\n         *\n         * @param string $path\n         * @param string|null $alias\n         * @return void\n         * @static\n         */        public static function aliasComponent($path, $alias = null)\n        {\n                        /** @var \\Illuminate\\View\\Compilers\\BladeCompiler $instance */\n                        $instance->aliasComponent($path, $alias);\n        }\n\n        /**\n         * Register an include alias directive.\n         *\n         * @param string $path\n         * @param string|null $alias\n         * @return void\n         * @static\n         */        public static function include($path, $alias = null)\n        {\n                        /** @var \\Illuminate\\View\\Compilers\\BladeCompiler $instance */\n                        $instance->include($path, $alias);\n        }\n\n        /**\n         * Register an include alias directive.\n         *\n         * @param string $path\n         * @param string|null $alias\n         * @return void\n         * @static\n         */        public static function aliasInclude($path, $alias = null)\n        {\n                        /** @var \\Illuminate\\View\\Compilers\\BladeCompiler $instance */\n                        $instance->aliasInclude($path, $alias);\n        }\n\n        /**\n         * Register a handler for custom directives.\n         *\n         * @param string $name\n         * @param callable $handler\n         * @return void\n         * @throws \\InvalidArgumentException\n         * @static\n         */        public static function directive($name, $handler)\n        {\n                        /** @var \\Illuminate\\View\\Compilers\\BladeCompiler $instance */\n                        $instance->directive($name, $handler);\n        }\n\n        /**\n         * Get the list of custom directives.\n         *\n         * @return array\n         * @static\n         */        public static function getCustomDirectives()\n        {\n                        /** @var \\Illuminate\\View\\Compilers\\BladeCompiler $instance */\n                        return $instance->getCustomDirectives();\n        }\n\n        /**\n         * Register a new precompiler.\n         *\n         * @param callable $precompiler\n         * @return void\n         * @static\n         */        public static function precompiler($precompiler)\n        {\n                        /** @var \\Illuminate\\View\\Compilers\\BladeCompiler $instance */\n                        $instance->precompiler($precompiler);\n        }\n\n        /**\n         * Set the echo format to be used by the compiler.\n         *\n         * @param string $format\n         * @return void\n         * @static\n         */        public static function setEchoFormat($format)\n        {\n                        /** @var \\Illuminate\\View\\Compilers\\BladeCompiler $instance */\n                        $instance->setEchoFormat($format);\n        }\n\n        /**\n         * Set the "echo" format to double encode entities.\n         *\n         * @return void\n         * @static\n         */        public static function withDoubleEncoding()\n        {\n                        /** @var \\Illuminate\\View\\Compilers\\BladeCompiler $instance */\n                        $instance->withDoubleEncoding();\n        }\n\n        /**\n         * Set the "echo" format to not double encode entities.\n         *\n         * @return void\n         * @static\n         */        public static function withoutDoubleEncoding()\n        {\n                        /** @var \\Illuminate\\View\\Compilers\\BladeCompiler $instance */\n                        $instance->withoutDoubleEncoding();\n        }\n\n        /**\n         * Indicate that component tags should not be compiled.\n         *\n         * @return void\n         * @static\n         */        public static function withoutComponentTags()\n        {\n                        /** @var \\Illuminate\\View\\Compilers\\BladeCompiler $instance */\n                        $instance->withoutComponentTags();\n        }\n\n        /**\n         * Get the path to the compiled version of a view.\n         *\n         * @param string $path\n         * @return string\n         * @static\n         */        public static function getCompiledPath($path)\n        {\n            //Method inherited from \\Illuminate\\View\\Compilers\\Compiler\n                        /** @var \\Illuminate\\View\\Compilers\\BladeCompiler $instance */\n                        return $instance->getCompiledPath($path);\n        }\n\n        /**\n         * Determine if the view at the given path is expired.\n         *\n         * @param string $path\n         * @return bool\n         * @static\n         */        public static function isExpired($path)\n        {\n            //Method inherited from \\Illuminate\\View\\Compilers\\Compiler\n                        /** @var \\Illuminate\\View\\Compilers\\BladeCompiler $instance */\n                        return $instance->isExpired($path);\n        }\n\n        /**\n         * Get a new component hash for a component name.\n         *\n         * @param string $component\n         * @return string\n         * @static\n         */        public static function newComponentHash($component)\n        {\n                        return \\Illuminate\\View\\Compilers\\BladeCompiler::newComponentHash($component);\n        }\n\n        /**\n         * Compile a class component opening.\n         *\n         * @param string $component\n         * @param string $data\n         * @param string $hash\n         * @return string\n         * @static\n         */        public static function compileClassComponentOpening($component, $data, $hash)\n        {\n                        return \\Illuminate\\View\\Compilers\\BladeCompiler::compileClassComponentOpening($component, $data, $hash);\n        }\n\n        /**\n         * Compile the end-component statements into valid PHP.\n         *\n         * @return string\n         * @static\n         */        public static function compileEndComponentClass()\n        {\n                        /** @var \\Illuminate\\View\\Compilers\\BladeCompiler $instance */\n                        return $instance->compileEndComponentClass();\n        }\n\n        /**\n         * Sanitize the given component attribute value.\n         *\n         * @param mixed $value\n         * @return mixed\n         * @static\n         */        public static function sanitizeComponentAttribute($value)\n        {\n                        return \\Illuminate\\View\\Compilers\\BladeCompiler::sanitizeComponentAttribute($value);\n        }\n\n        /**\n         * Compile Blade echos into valid PHP.\n         *\n         * @param string $value\n         * @return string\n         * @static\n         */        public static function compileEchos($value)\n        {\n                        /** @var \\Illuminate\\View\\Compilers\\BladeCompiler $instance */\n                        return $instance->compileEchos($value);\n        }\n            }\n\n    /**\n     *\n     *\n     * @method static \\Illuminate\\Broadcasting\\Broadcasters\\Broadcaster channel(string $channel, callable|string  $callback, array $options = [])\n     * @method static mixed auth(\\Illuminate\\Http\\Request $request)\n     * @see \\Illuminate\\Contracts\\Broadcasting\\Factory\n     */    class Broadcast {\n\n        /**\n         * Register the routes for handling broadcast authentication and sockets.\n         *\n         * @param array|null $attributes\n         * @return void\n         * @static\n         */        public static function routes($attributes = null)\n        {\n                        /** @var \\Illuminate\\Broadcasting\\BroadcastManager $instance */\n                        $instance->routes($attributes);\n        }\n\n        /**\n         * Get the socket ID for the given request.\n         *\n         * @param \\Illuminate\\Http\\Request|null $request\n         * @return string|null\n         * @static\n         */        public static function socket($request = null)\n        {\n                        /** @var \\Illuminate\\Broadcasting\\BroadcastManager $instance */\n                        return $instance->socket($request);\n        }\n\n        /**\n         * Begin broadcasting an event.\n         *\n         * @param mixed|null $event\n         * @return \\Illuminate\\Broadcasting\\PendingBroadcast|void\n         * @static\n         */        public static function event($event = null)\n        {\n                        /** @var \\Illuminate\\Broadcasting\\BroadcastManager $instance */\n                        return $instance->event($event);\n        }\n\n        /**\n         * Queue the given event for broadcast.\n         *\n         * @param mixed $event\n         * @return void\n         * @static\n         */        public static function queue($event)\n        {\n                        /** @var \\Illuminate\\Broadcasting\\BroadcastManager $instance */\n                        $instance->queue($event);\n        }\n\n        /**\n         * Get a driver instance.\n         *\n         * @param string|null $driver\n         * @return mixed\n         * @static\n         */        public static function connection($driver = null)\n        {\n                        /** @var \\Illuminate\\Broadcasting\\BroadcastManager $instance */\n                        return $instance->connection($driver);\n        }\n\n        /**\n         * Get a driver instance.\n         *\n         * @param string|null $name\n         * @return mixed\n         * @static\n         */        public static function driver($name = null)\n        {\n                        /** @var \\Illuminate\\Broadcasting\\BroadcastManager $instance */\n                        return $instance->driver($name);\n        }\n\n        /**\n         * Get the default driver name.\n         *\n         * @return string\n         * @static\n         */        public static function getDefaultDriver()\n        {\n                        /** @var \\Illuminate\\Broadcasting\\BroadcastManager $instance */\n                        return $instance->getDefaultDriver();\n        }\n\n        /**\n         * Set the default driver name.\n         *\n         * @param string $name\n         * @return void\n         * @static\n         */        public static function setDefaultDriver($name)\n        {\n                        /** @var \\Illuminate\\Broadcasting\\BroadcastManager $instance */\n                        $instance->setDefaultDriver($name);\n        }\n\n        /**\n         * Register a custom driver creator Closure.\n         *\n         * @param string $driver\n         * @param \\Closure $callback\n         * @return \\Illuminate\\Broadcasting\\BroadcastManager\n         * @static\n         */        public static function extend($driver, $callback)\n        {\n                        /** @var \\Illuminate\\Broadcasting\\BroadcastManager $instance */\n                        return $instance->extend($driver, $callback);\n        }\n            }\n\n    /**\n     *\n     *\n     * @see \\Illuminate\\Contracts\\Bus\\Dispatcher\n     */    class Bus {\n\n        /**\n         * Dispatch a command to its appropriate handler.\n         *\n         * @param mixed $command\n         * @return mixed\n         * @static\n         */        public static function dispatch($command)\n        {\n                        /** @var \\Illuminate\\Bus\\Dispatcher $instance */\n                        return $instance->dispatch($command);\n        }\n\n        /**\n         * Dispatch a command to its appropriate handler in the current process.\n         *\n         * @param mixed $command\n         * @param mixed $handler\n         * @return mixed\n         * @static\n         */        public static function dispatchNow($command, $handler = null)\n        {\n                        /** @var \\Illuminate\\Bus\\Dispatcher $instance */\n                        return $instance->dispatchNow($command, $handler);\n        }\n\n        /**\n         * Determine if the given command has a handler.\n         *\n         * @param mixed $command\n         * @return bool\n         * @static\n         */        public static function hasCommandHandler($command)\n        {\n                        /** @var \\Illuminate\\Bus\\Dispatcher $instance */\n                        return $instance->hasCommandHandler($command);\n        }\n\n        /**\n         * Retrieve the handler for a command.\n         *\n         * @param mixed $command\n         * @return bool|mixed\n         * @static\n         */        public static function getCommandHandler($command)\n        {\n                        /** @var \\Illuminate\\Bus\\Dispatcher $instance */\n                        return $instance->getCommandHandler($command);\n        }\n\n        /**\n         * Dispatch a command to its appropriate handler behind a queue.\n         *\n         * @param mixed $command\n         * @return mixed\n         * @static\n         */        public static function dispatchToQueue($command)\n        {\n                        /** @var \\Illuminate\\Bus\\Dispatcher $instance */\n                        return $instance->dispatchToQueue($command);\n        }\n\n        /**\n         * Dispatch a command to its appropriate handler after the current process.\n         *\n         * @param mixed $command\n         * @param mixed $handler\n         * @return void\n         * @static\n         */        public static function dispatchAfterResponse($command, $handler = null)\n        {\n                        /** @var \\Illuminate\\Bus\\Dispatcher $instance */\n                        $instance->dispatchAfterResponse($command, $handler);\n        }\n\n        /**\n         * Set the pipes through which commands should be piped before dispatching.\n         *\n         * @param array $pipes\n         * @return \\Illuminate\\Bus\\Dispatcher\n         * @static\n         */        public static function pipeThrough($pipes)\n        {\n                        /** @var \\Illuminate\\Bus\\Dispatcher $instance */\n                        return $instance->pipeThrough($pipes);\n        }\n\n        /**\n         * Map a command to a handler.\n         *\n         * @param array $map\n         * @return \\Illuminate\\Bus\\Dispatcher\n         * @static\n         */        public static function map($map)\n        {\n                        /** @var \\Illuminate\\Bus\\Dispatcher $instance */\n                        return $instance->map($map);\n        }\n\n        /**\n         * Assert if a job was dispatched based on a truth-test callback.\n         *\n         * @param string $command\n         * @param callable|int|null $callback\n         * @return void\n         * @static\n         */        public static function assertDispatched($command, $callback = null)\n        {\n                        /** @var \\Illuminate\\Support\\Testing\\Fakes\\BusFake $instance */\n                        $instance->assertDispatched($command, $callback);\n        }\n\n        /**\n         * Assert if a job was pushed a number of times.\n         *\n         * @param string $command\n         * @param int $times\n         * @return void\n         * @static\n         */        public static function assertDispatchedTimes($command, $times = 1)\n        {\n                        /** @var \\Illuminate\\Support\\Testing\\Fakes\\BusFake $instance */\n                        $instance->assertDispatchedTimes($command, $times);\n        }\n\n        /**\n         * Determine if a job was dispatched based on a truth-test callback.\n         *\n         * @param string $command\n         * @param callable|null $callback\n         * @return void\n         * @static\n         */        public static function assertNotDispatched($command, $callback = null)\n        {\n                        /** @var \\Illuminate\\Support\\Testing\\Fakes\\BusFake $instance */\n                        $instance->assertNotDispatched($command, $callback);\n        }\n\n        /**\n         * Assert if a job was dispatched after the response was sent based on a truth-test callback.\n         *\n         * @param string $command\n         * @param callable|int|null $callback\n         * @return void\n         * @static\n         */        public static function assertDispatchedAfterResponse($command, $callback = null)\n        {\n                        /** @var \\Illuminate\\Support\\Testing\\Fakes\\BusFake $instance */\n                        $instance->assertDispatchedAfterResponse($command, $callback);\n        }\n\n        /**\n         * Assert if a job was pushed after the response was sent a number of times.\n         *\n         * @param string $command\n         * @param int $times\n         * @return void\n         * @static\n         */        public static function assertDispatchedAfterResponseTimes($command, $times = 1)\n        {\n                        /** @var \\Illuminate\\Support\\Testing\\Fakes\\BusFake $instance */\n                        $instance->assertDispatchedAfterResponseTimes($command, $times);\n        }\n\n        /**\n         * Determine if a job was dispatched based on a truth-test callback.\n         *\n         * @param string $command\n         * @param callable|null $callback\n         * @return void\n         * @static\n         */        public static function assertNotDispatchedAfterResponse($command, $callback = null)\n        {\n                        /** @var \\Illuminate\\Support\\Testing\\Fakes\\BusFake $instance */\n                        $instance->assertNotDispatchedAfterResponse($command, $callback);\n        }\n\n        /**\n         * Get all of the jobs matching a truth-test callback.\n         *\n         * @param string $command\n         * @param callable|null $callback\n         * @return \\Illuminate\\Support\\Collection\n         * @static\n         */        public static function dispatched($command, $callback = null)\n        {\n                        /** @var \\Illuminate\\Support\\Testing\\Fakes\\BusFake $instance */\n                        return $instance->dispatched($command, $callback);\n        }\n\n        /**\n         * Get all of the jobs dispatched after the response was sent matching a truth-test callback.\n         *\n         * @param string $command\n         * @param callable|null $callback\n         * @return \\Illuminate\\Support\\Collection\n         * @static\n         */        public static function dispatchedAfterResponse($command, $callback = null)\n        {\n                        /** @var \\Illuminate\\Support\\Testing\\Fakes\\BusFake $instance */\n                        return $instance->dispatchedAfterResponse($command, $callback);\n        }\n\n        /**\n         * Determine if there are any stored commands for a given class.\n         *\n         * @param string $command\n         * @return bool\n         * @static\n         */        public static function hasDispatched($command)\n        {\n                        /** @var \\Illuminate\\Support\\Testing\\Fakes\\BusFake $instance */\n                        return $instance->hasDispatched($command);\n        }\n\n        /**\n         * Determine if there are any stored commands for a given class.\n         *\n         * @param string $command\n         * @return bool\n         * @static\n         */        public static function hasDispatchedAfterResponse($command)\n        {\n                        /** @var \\Illuminate\\Support\\Testing\\Fakes\\BusFake $instance */\n                        return $instance->hasDispatchedAfterResponse($command);\n        }\n            }\n\n    /**\n     *\n     *\n     * @method static \\Illuminate\\Contracts\\Cache\\Lock lock(string $name, int $seconds = 0, mixed $owner = null)\n     * @method static \\Illuminate\\Contracts\\Cache\\Lock restoreLock(string $name, string $owner)\n     * @see \\Illuminate\\Cache\\CacheManager\n     * @see \\Illuminate\\Cache\\Repository\n     */    class Cache {\n\n        /**\n         * Get a cache store instance by name, wrapped in a repository.\n         *\n         * @param string|null $name\n         * @return \\Illuminate\\Contracts\\Cache\\Repository\n         * @static\n         */        public static function store($name = null)\n        {\n                        /** @var \\Illuminate\\Cache\\CacheManager $instance */\n                        return $instance->store($name);\n        }\n\n        /**\n         * Get a cache driver instance.\n         *\n         * @param string|null $driver\n         * @return \\Illuminate\\Contracts\\Cache\\Repository\n         * @static\n         */        public static function driver($driver = null)\n        {\n                        /** @var \\Illuminate\\Cache\\CacheManager $instance */\n                        return $instance->driver($driver);\n        }\n\n        /**\n         * Create a new cache repository with the given implementation.\n         *\n         * @param \\Illuminate\\Contracts\\Cache\\Store $store\n         * @return \\Illuminate\\Cache\\Repository\n         * @static\n         */        public static function repository($store)\n        {\n                        /** @var \\Illuminate\\Cache\\CacheManager $instance */\n                        return $instance->repository($store);\n        }\n\n        /**\n         * Re-set the event dispatcher on all resolved cache repositories.\n         *\n         * @return void\n         * @static\n         */        public static function refreshEventDispatcher()\n        {\n                        /** @var \\Illuminate\\Cache\\CacheManager $instance */\n                        $instance->refreshEventDispatcher();\n        }\n\n        /**\n         * Get the default cache driver name.\n         *\n         * @return string\n         * @static\n         */        public static function getDefaultDriver()\n        {\n                        /** @var \\Illuminate\\Cache\\CacheManager $instance */\n                        return $instance->getDefaultDriver();\n        }\n\n        /**\n         * Set the default cache driver name.\n         *\n         * @param string $name\n         * @return void\n         * @static\n         */        public static function setDefaultDriver($name)\n        {\n                        /** @var \\Illuminate\\Cache\\CacheManager $instance */\n                        $instance->setDefaultDriver($name);\n        }\n\n        /**\n         * Unset the given driver instances.\n         *\n         * @param array|string|null $name\n         * @return \\Illuminate\\Cache\\CacheManager\n         * @static\n         */        public static function forgetDriver($name = null)\n        {\n                        /** @var \\Illuminate\\Cache\\CacheManager $instance */\n                        return $instance->forgetDriver($name);\n        }\n\n        /**\n         * Register a custom driver creator Closure.\n         *\n         * @param string $driver\n         * @param \\Closure $callback\n         * @return \\Illuminate\\Cache\\CacheManager\n         * @static\n         */        public static function extend($driver, $callback)\n        {\n                        /** @var \\Illuminate\\Cache\\CacheManager $instance */\n                        return $instance->extend($driver, $callback);\n        }\n\n        /**\n         * Determine if an item exists in the cache.\n         *\n         * @param string $key\n         * @return bool\n         * @static\n         */        public static function has($key)\n        {\n                        /** @var \\Illuminate\\Cache\\Repository $instance */\n                        return $instance->has($key);\n        }\n\n        /**\n         * Determine if an item doesn\'t exist in the cache.\n         *\n         * @param string $key\n         * @return bool\n         * @static\n         */        public static function missing($key)\n        {\n                        /** @var \\Illuminate\\Cache\\Repository $instance */\n                        return $instance->missing($key);\n        }\n\n        /**\n         * Retrieve an item from the cache by key.\n         *\n         * @param string $key\n         * @param mixed $default\n         * @return mixed\n         * @static\n         */        public static function get($key, $default = null)\n        {\n                        /** @var \\Illuminate\\Cache\\Repository $instance */\n                        return $instance->get($key, $default);\n        }\n\n        /**\n         * Retrieve multiple items from the cache by key.\n         *\n         * Items not found in the cache will have a null value.\n         *\n         * @param array $keys\n         * @return array\n         * @static\n         */        public static function many($keys)\n        {\n                        /** @var \\Illuminate\\Cache\\Repository $instance */\n                        return $instance->many($keys);\n        }\n\n        /**\n         * Obtains multiple cache items by their unique keys.\n         *\n         * @param \\Psr\\SimpleCache\\iterable $keys A list of keys that can obtained in a single operation.\n         * @param mixed $default Default value to return for keys that do not exist.\n         * @return \\Psr\\SimpleCache\\iterable A list of key => value pairs. Cache keys that do not exist or are stale will have $default as value.\n         * @throws \\Psr\\SimpleCache\\InvalidArgumentException\n         *   MUST be thrown if $keys is neither an array nor a Traversable,\n         *   or if any of the $keys are not a legal value.\n         * @static\n         */        public static function getMultiple($keys, $default = null)\n        {\n                        /** @var \\Illuminate\\Cache\\Repository $instance */\n                        return $instance->getMultiple($keys, $default);\n        }\n\n        /**\n         * Retrieve an item from the cache and delete it.\n         *\n         * @param string $key\n         * @param mixed $default\n         * @return mixed\n         * @static\n         */        public static function pull($key, $default = null)\n        {\n                        /** @var \\Illuminate\\Cache\\Repository $instance */\n                        return $instance->pull($key, $default);\n        }\n\n        /**\n         * Store an item in the cache.\n         *\n         * @param string $key\n         * @param mixed $value\n         * @param \\DateTimeInterface|\\DateInterval|int|null $ttl\n         * @return bool\n         * @static\n         */        public static function put($key, $value, $ttl = null)\n        {\n                        /** @var \\Illuminate\\Cache\\Repository $instance */\n                        return $instance->put($key, $value, $ttl);\n        }\n\n        /**\n         * Persists data in the cache, uniquely referenced by a key with an optional expiration TTL time.\n         *\n         * @param string $key The key of the item to store.\n         * @param mixed $value The value of the item to store, must be serializable.\n         * @param null|int|\\DateInterval $ttl Optional. The TTL value of this item. If no value is sent and\n         *                                      the driver supports TTL then the library may set a default value\n         *                                      for it or let the driver take care of that.\n         * @return bool True on success and false on failure.\n         * @throws \\Psr\\SimpleCache\\InvalidArgumentException\n         *   MUST be thrown if the $key string is not a legal value.\n         * @static\n         */        public static function set($key, $value, $ttl = null)\n        {\n                        /** @var \\Illuminate\\Cache\\Repository $instance */\n                        return $instance->set($key, $value, $ttl);\n        }\n\n        /**\n         * Store multiple items in the cache for a given number of seconds.\n         *\n         * @param array $values\n         * @param \\DateTimeInterface|\\DateInterval|int|null $ttl\n         * @return bool\n         * @static\n         */        public static function putMany($values, $ttl = null)\n        {\n                        /** @var \\Illuminate\\Cache\\Repository $instance */\n                        return $instance->putMany($values, $ttl);\n        }\n\n        /**\n         * Persists a set of key => value pairs in the cache, with an optional TTL.\n         *\n         * @param \\Psr\\SimpleCache\\iterable $values A list of key => value pairs for a multiple-set operation.\n         * @param null|int|\\DateInterval $ttl Optional. The TTL value of this item. If no value is sent and\n         *                                       the driver supports TTL then the library may set a default value\n         *                                       for it or let the driver take care of that.\n         * @return bool True on success and false on failure.\n         * @throws \\Psr\\SimpleCache\\InvalidArgumentException\n         *   MUST be thrown if $values is neither an array nor a Traversable,\n         *   or if any of the $values are not a legal value.\n         * @static\n         */        public static function setMultiple($values, $ttl = null)\n        {\n                        /** @var \\Illuminate\\Cache\\Repository $instance */\n                        return $instance->setMultiple($values, $ttl);\n        }\n\n        /**\n         * Store an item in the cache if the key does not exist.\n         *\n         * @param string $key\n         * @param mixed $value\n         * @param \\DateTimeInterface|\\DateInterval|int|null $ttl\n         * @return bool\n         * @static\n         */        public static function add($key, $value, $ttl = null)\n        {\n                        /** @var \\Illuminate\\Cache\\Repository $instance */\n                        return $instance->add($key, $value, $ttl);\n        }\n\n        /**\n         * Increment the value of an item in the cache.\n         *\n         * @param string $key\n         * @param mixed $value\n         * @return int|bool\n         * @static\n         */        public static function increment($key, $value = 1)\n        {\n                        /** @var \\Illuminate\\Cache\\Repository $instance */\n                        return $instance->increment($key, $value);\n        }\n\n        /**\n         * Decrement the value of an item in the cache.\n         *\n         * @param string $key\n         * @param mixed $value\n         * @return int|bool\n         * @static\n         */        public static function decrement($key, $value = 1)\n        {\n                        /** @var \\Illuminate\\Cache\\Repository $instance */\n                        return $instance->decrement($key, $value);\n        }\n\n        /**\n         * Store an item in the cache indefinitely.\n         *\n         * @param string $key\n         * @param mixed $value\n         * @return bool\n         * @static\n         */        public static function forever($key, $value)\n        {\n                        /** @var \\Illuminate\\Cache\\Repository $instance */\n                        return $instance->forever($key, $value);\n        }\n\n        /**\n         * Get an item from the cache, or execute the given Closure and store the result.\n         *\n         * @param string $key\n         * @param \\DateTimeInterface|\\DateInterval|int|null $ttl\n         * @param \\Closure $callback\n         * @return mixed\n         * @static\n         */        public static function remember($key, $ttl, $callback)\n        {\n                        /** @var \\Illuminate\\Cache\\Repository $instance */\n                        return $instance->remember($key, $ttl, $callback);\n        }\n\n        /**\n         * Get an item from the cache, or execute the given Closure and store the result forever.\n         *\n         * @param string $key\n         * @param \\Closure $callback\n         * @return mixed\n         * @static\n         */        public static function sear($key, $callback)\n        {\n                        /** @var \\Illuminate\\Cache\\Repository $instance */\n                        return $instance->sear($key, $callback);\n        }\n\n        /**\n         * Get an item from the cache, or execute the given Closure and store the result forever.\n         *\n         * @param string $key\n         * @param \\Closure $callback\n         * @return mixed\n         * @static\n         */        public static function rememberForever($key, $callback)\n        {\n                        /** @var \\Illuminate\\Cache\\Repository $instance */\n                        return $instance->rememberForever($key, $callback);\n        }\n\n        /**\n         * Remove an item from the cache.\n         *\n         * @param string $key\n         * @return bool\n         * @static\n         */        public static function forget($key)\n        {\n                        /** @var \\Illuminate\\Cache\\Repository $instance */\n                        return $instance->forget($key);\n        }\n\n        /**\n         * Delete an item from the cache by its unique key.\n         *\n         * @param string $key The unique cache key of the item to delete.\n         * @return bool True if the item was successfully removed. False if there was an error.\n         * @throws \\Psr\\SimpleCache\\InvalidArgumentException\n         *   MUST be thrown if the $key string is not a legal value.\n         * @static\n         */        public static function delete($key)\n        {\n                        /** @var \\Illuminate\\Cache\\Repository $instance */\n                        return $instance->delete($key);\n        }\n\n        /**\n         * Deletes multiple cache items in a single operation.\n         *\n         * @param \\Psr\\SimpleCache\\iterable $keys A list of string-based keys to be deleted.\n         * @return bool True if the items were successfully removed. False if there was an error.\n         * @throws \\Psr\\SimpleCache\\InvalidArgumentException\n         *   MUST be thrown if $keys is neither an array nor a Traversable,\n         *   or if any of the $keys are not a legal value.\n         * @static\n         */        public static function deleteMultiple($keys)\n        {\n                        /** @var \\Illuminate\\Cache\\Repository $instance */\n                        return $instance->deleteMultiple($keys);\n        }\n\n        /**\n         * Wipes clean the entire cache\'s keys.\n         *\n         * @return bool True on success and false on failure.\n         * @static\n         */        public static function clear()\n        {\n                        /** @var \\Illuminate\\Cache\\Repository $instance */\n                        return $instance->clear();\n        }\n\n        /**\n         * Begin executing a new tags operation if the store supports it.\n         *\n         * @param array|mixed $names\n         * @return \\Illuminate\\Cache\\TaggedCache\n         * @throws \\BadMethodCallException\n         * @static\n         */        public static function tags($names)\n        {\n                        /** @var \\Illuminate\\Cache\\Repository $instance */\n                        return $instance->tags($names);\n        }\n\n        /**\n         * Get the default cache time.\n         *\n         * @return int|null\n         * @static\n         */        public static function getDefaultCacheTime()\n        {\n                        /** @var \\Illuminate\\Cache\\Repository $instance */\n                        return $instance->getDefaultCacheTime();\n        }\n\n        /**\n         * Set the default cache time in seconds.\n         *\n         * @param int|null $seconds\n         * @return \\Illuminate\\Cache\\Repository\n         * @static\n         */        public static function setDefaultCacheTime($seconds)\n        {\n                        /** @var \\Illuminate\\Cache\\Repository $instance */\n                        return $instance->setDefaultCacheTime($seconds);\n        }\n\n        /**\n         * Get the cache store implementation.\n         *\n         * @return \\Illuminate\\Contracts\\Cache\\Store\n         * @static\n         */        public static function getStore()\n        {\n                        /** @var \\Illuminate\\Cache\\Repository $instance */\n                        return $instance->getStore();\n        }\n\n        /**\n         * Get the event dispatcher instance.\n         *\n         * @return \\Illuminate\\Contracts\\Events\\Dispatcher\n         * @static\n         */        public static function getEventDispatcher()\n        {\n                        /** @var \\Illuminate\\Cache\\Repository $instance */\n                        return $instance->getEventDispatcher();\n        }\n\n        /**\n         * Set the event dispatcher instance.\n         *\n         * @param \\Illuminate\\Contracts\\Events\\Dispatcher $events\n         * @return void\n         * @static\n         */        public static function setEventDispatcher($events)\n        {\n                        /** @var \\Illuminate\\Cache\\Repository $instance */\n                        $instance->setEventDispatcher($events);\n        }\n\n        /**\n         * Determine if a cached value exists.\n         *\n         * @param string $key\n         * @return bool\n         * @static\n         */        public static function offsetExists($key)\n        {\n                        /** @var \\Illuminate\\Cache\\Repository $instance */\n                        return $instance->offsetExists($key);\n        }\n\n        /**\n         * Retrieve an item from the cache by key.\n         *\n         * @param string $key\n         * @return mixed\n         * @static\n         */        public static function offsetGet($key)\n        {\n                        /** @var \\Illuminate\\Cache\\Repository $instance */\n                        return $instance->offsetGet($key);\n        }\n\n        /**\n         * Store an item in the cache for the default time.\n         *\n         * @param string $key\n         * @param mixed $value\n         * @return void\n         * @static\n         */        public static function offsetSet($key, $value)\n        {\n                        /** @var \\Illuminate\\Cache\\Repository $instance */\n                        $instance->offsetSet($key, $value);\n        }\n\n        /**\n         * Remove an item from the cache.\n         *\n         * @param string $key\n         * @return void\n         * @static\n         */        public static function offsetUnset($key)\n        {\n                        /** @var \\Illuminate\\Cache\\Repository $instance */\n                        $instance->offsetUnset($key);\n        }\n\n        /**\n         * Register a custom macro.\n         *\n         * @param string $name\n         * @param object|callable $macro\n         * @return void\n         * @static\n         */        public static function macro($name, $macro)\n        {\n                        \\Illuminate\\Cache\\Repository::macro($name, $macro);\n        }\n\n        /**\n         * Mix another object into the class.\n         *\n         * @param object $mixin\n         * @param bool $replace\n         * @return void\n         * @throws \\ReflectionException\n         * @static\n         */        public static function mixin($mixin, $replace = true)\n        {\n                        \\Illuminate\\Cache\\Repository::mixin($mixin, $replace);\n        }\n\n        /**\n         * Checks if macro is registered.\n         *\n         * @param string $name\n         * @return bool\n         * @static\n         */        public static function hasMacro($name)\n        {\n                        return \\Illuminate\\Cache\\Repository::hasMacro($name);\n        }\n\n        /**\n         * Dynamically handle calls to the class.\n         *\n         * @param string $method\n         * @param array $parameters\n         * @return mixed\n         * @throws \\BadMethodCallException\n         * @static\n         */        public static function macroCall($method, $parameters)\n        {\n                        /** @var \\Illuminate\\Cache\\Repository $instance */\n                        return $instance->macroCall($method, $parameters);\n        }\n\n        /**\n         * Remove all items from the cache.\n         *\n         * @return bool\n         * @static\n         */        public static function flush()\n        {\n                        /** @var \\Illuminate\\Cache\\FileStore $instance */\n                        return $instance->flush();\n        }\n\n        /**\n         * Get the Filesystem instance.\n         *\n         * @return \\Illuminate\\Filesystem\\Filesystem\n         * @static\n         */        public static function getFilesystem()\n        {\n                        /** @var \\Illuminate\\Cache\\FileStore $instance */\n                        return $instance->getFilesystem();\n        }\n\n        /**\n         * Get the working directory of the cache.\n         *\n         * @return string\n         * @static\n         */        public static function getDirectory()\n        {\n                        /** @var \\Illuminate\\Cache\\FileStore $instance */\n                        return $instance->getDirectory();\n        }\n\n        /**\n         * Get the cache key prefix.\n         *\n         * @return string\n         * @static\n         */        public static function getPrefix()\n        {\n                        /** @var \\Illuminate\\Cache\\FileStore $instance */\n                        return $instance->getPrefix();\n        }\n            }\n\n    /**\n     *\n     *\n     * @see \\Illuminate\\Config\\Repository\n     */    class Config {\n\n        /**\n         * Determine if the given configuration value exists.\n         *\n         * @param string $key\n         * @return bool\n         * @static\n         */        public static function has($key)\n        {\n                        /** @var \\Illuminate\\Config\\Repository $instance */\n                        return $instance->has($key);\n        }\n\n        /**\n         * Get the specified configuration value.\n         *\n         * @param array|string $key\n         * @param mixed $default\n         * @return mixed\n         * @static\n         */        public static function get($key, $default = null)\n        {\n                        /** @var \\Illuminate\\Config\\Repository $instance */\n                        return $instance->get($key, $default);\n        }\n\n        /**\n         * Get many configuration values.\n         *\n         * @param array $keys\n         * @return array\n         * @static\n         */        public static function getMany($keys)\n        {\n                        /** @var \\Illuminate\\Config\\Repository $instance */\n                        return $instance->getMany($keys);\n        }\n\n        /**\n         * Set a given configuration value.\n         *\n         * @param array|string $key\n         * @param mixed $value\n         * @return void\n         * @static\n         */        public static function set($key, $value = null)\n        {\n                        /** @var \\Illuminate\\Config\\Repository $instance */\n                        $instance->set($key, $value);\n        }\n\n        /**\n         * Prepend a value onto an array configuration value.\n         *\n         * @param string $key\n         * @param mixed $value\n         * @return void\n         * @static\n         */        public static function prepend($key, $value)\n        {\n                        /** @var \\Illuminate\\Config\\Repository $instance */\n                        $instance->prepend($key, $value);\n        }\n\n        /**\n         * Push a value onto an array configuration value.\n         *\n         * @param string $key\n         * @param mixed $value\n         * @return void\n         * @static\n         */        public static function push($key, $value)\n        {\n                        /** @var \\Illuminate\\Config\\Repository $instance */\n                        $instance->push($key, $value);\n        }\n\n        /**\n         * Get all of the configuration items for the application.\n         *\n         * @return array\n         * @static\n         */        public static function all()\n        {\n                        /** @var \\Illuminate\\Config\\Repository $instance */\n                        return $instance->all();\n        }\n\n        /**\n         * Determine if the given configuration option exists.\n         *\n         * @param string $key\n         * @return bool\n         * @static\n         */        public static function offsetExists($key)\n        {\n                        /** @var \\Illuminate\\Config\\Repository $instance */\n                        return $instance->offsetExists($key);\n        }\n\n        /**\n         * Get a configuration option.\n         *\n         * @param string $key\n         * @return mixed\n         * @static\n         */        public static function offsetGet($key)\n        {\n                        /** @var \\Illuminate\\Config\\Repository $instance */\n                        return $instance->offsetGet($key);\n        }\n\n        /**\n         * Set a configuration option.\n         *\n         * @param string $key\n         * @param mixed $value\n         * @return void\n         * @static\n         */        public static function offsetSet($key, $value)\n        {\n                        /** @var \\Illuminate\\Config\\Repository $instance */\n                        $instance->offsetSet($key, $value);\n        }\n\n        /**\n         * Unset a configuration option.\n         *\n         * @param string $key\n         * @return void\n         * @static\n         */        public static function offsetUnset($key)\n        {\n                        /** @var \\Illuminate\\Config\\Repository $instance */\n                        $instance->offsetUnset($key);\n        }\n            }\n\n    /**\n     *\n     *\n     * @see \\Illuminate\\Cookie\\CookieJar\n     */    class Cookie {\n\n        /**\n         * Create a new cookie instance.\n         *\n         * @param string $name\n         * @param string $value\n         * @param int $minutes\n         * @param string|null $path\n         * @param string|null $domain\n         * @param bool|null $secure\n         * @param bool $httpOnly\n         * @param bool $raw\n         * @param string|null $sameSite\n         * @return \\Symfony\\Component\\HttpFoundation\\Cookie\n         * @static\n         */        public static function make($name, $value, $minutes = 0, $path = null, $domain = null, $secure = null, $httpOnly = true, $raw = false, $sameSite = null)\n        {\n                        /** @var \\Illuminate\\Cookie\\CookieJar $instance */\n                        return $instance->make($name, $value, $minutes, $path, $domain, $secure, $httpOnly, $raw, $sameSite);\n        }\n\n        /**\n         * Create a cookie that lasts "forever" (five years).\n         *\n         * @param string $name\n         * @param string $value\n         * @param string|null $path\n         * @param string|null $domain\n         * @param bool|null $secure\n         * @param bool $httpOnly\n         * @param bool $raw\n         * @param string|null $sameSite\n         * @return \\Symfony\\Component\\HttpFoundation\\Cookie\n         * @static\n         */        public static function forever($name, $value, $path = null, $domain = null, $secure = null, $httpOnly = true, $raw = false, $sameSite = null)\n        {\n                        /** @var \\Illuminate\\Cookie\\CookieJar $instance */\n                        return $instance->forever($name, $value, $path, $domain, $secure, $httpOnly, $raw, $sameSite);\n        }\n\n        /**\n         * Expire the given cookie.\n         *\n         * @param string $name\n         * @param string|null $path\n         * @param string|null $domain\n         * @return \\Symfony\\Component\\HttpFoundation\\Cookie\n         * @static\n         */        public static function forget($name, $path = null, $domain = null)\n        {\n                        /** @var \\Illuminate\\Cookie\\CookieJar $instance */\n                        return $instance->forget($name, $path, $domain);\n        }\n\n        /**\n         * Determine if a cookie has been queued.\n         *\n         * @param string $key\n         * @param string|null $path\n         * @return bool\n         * @static\n         */        public static function hasQueued($key, $path = null)\n        {\n                        /** @var \\Illuminate\\Cookie\\CookieJar $instance */\n                        return $instance->hasQueued($key, $path);\n        }\n\n        /**\n         * Get a queued cookie instance.\n         *\n         * @param string $key\n         * @param mixed $default\n         * @param string|null $path\n         * @return \\Symfony\\Component\\HttpFoundation\\Cookie|null\n         * @static\n         */        public static function queued($key, $default = null, $path = null)\n        {\n                        /** @var \\Illuminate\\Cookie\\CookieJar $instance */\n                        return $instance->queued($key, $default, $path);\n        }\n\n        /**\n         * Queue a cookie to send with the next response.\n         *\n         * @param array $parameters\n         * @return void\n         * @static\n         */        public static function queue(...$parameters)\n        {\n                        /** @var \\Illuminate\\Cookie\\CookieJar $instance */\n                        $instance->queue(...$parameters);\n        }\n\n        /**\n         * Remove a cookie from the queue.\n         *\n         * @param string $name\n         * @param string|null $path\n         * @return void\n         * @static\n         */        public static function unqueue($name, $path = null)\n        {\n                        /** @var \\Illuminate\\Cookie\\CookieJar $instance */\n                        $instance->unqueue($name, $path);\n        }\n\n        /**\n         * Set the default path and domain for the jar.\n         *\n         * @param string $path\n         * @param string $domain\n         * @param bool $secure\n         * @param string|null $sameSite\n         * @return \\Illuminate\\Cookie\\CookieJar\n         * @static\n         */        public static function setDefaultPathAndDomain($path, $domain, $secure = false, $sameSite = null)\n        {\n                        /** @var \\Illuminate\\Cookie\\CookieJar $instance */\n                        return $instance->setDefaultPathAndDomain($path, $domain, $secure, $sameSite);\n        }\n\n        /**\n         * Get the cookies which have been queued for the next request.\n         *\n         * @return \\Symfony\\Component\\HttpFoundation\\Cookie[]\n         * @static\n         */        public static function getQueuedCookies()\n        {\n                        /** @var \\Illuminate\\Cookie\\CookieJar $instance */\n                        return $instance->getQueuedCookies();\n        }\n\n        /**\n         * Register a custom macro.\n         *\n         * @param string $name\n         * @param object|callable $macro\n         * @return void\n         * @static\n         */        public static function macro($name, $macro)\n        {\n                        \\Illuminate\\Cookie\\CookieJar::macro($name, $macro);\n        }\n\n        /**\n         * Mix another object into the class.\n         *\n         * @param object $mixin\n         * @param bool $replace\n         * @return void\n         * @throws \\ReflectionException\n         * @static\n         */        public static function mixin($mixin, $replace = true)\n        {\n                        \\Illuminate\\Cookie\\CookieJar::mixin($mixin, $replace);\n        }\n\n        /**\n         * Checks if macro is registered.\n         *\n         * @param string $name\n         * @return bool\n         * @static\n         */        public static function hasMacro($name)\n        {\n                        return \\Illuminate\\Cookie\\CookieJar::hasMacro($name);\n        }\n            }\n\n    /**\n     *\n     *\n     * @see \\Illuminate\\Encryption\\Encrypter\n     */    class Crypt {\n\n        /**\n         * Determine if the given key and cipher combination is valid.\n         *\n         * @param string $key\n         * @param string $cipher\n         * @return bool\n         * @static\n         */        public static function supported($key, $cipher)\n        {\n                        return \\Illuminate\\Encryption\\Encrypter::supported($key, $cipher);\n        }\n\n        /**\n         * Create a new encryption key for the given cipher.\n         *\n         * @param string $cipher\n         * @return string\n         * @static\n         */        public static function generateKey($cipher)\n        {\n                        return \\Illuminate\\Encryption\\Encrypter::generateKey($cipher);\n        }\n\n        /**\n         * Encrypt the given value.\n         *\n         * @param mixed $value\n         * @param bool $serialize\n         * @return string\n         * @throws \\Illuminate\\Contracts\\Encryption\\EncryptException\n         * @static\n         */        public static function encrypt($value, $serialize = true)\n        {\n                        /** @var \\Illuminate\\Encryption\\Encrypter $instance */\n                        return $instance->encrypt($value, $serialize);\n        }\n\n        /**\n         * Encrypt a string without serialization.\n         *\n         * @param string $value\n         * @return string\n         * @throws \\Illuminate\\Contracts\\Encryption\\EncryptException\n         * @static\n         */        public static function encryptString($value)\n        {\n                        /** @var \\Illuminate\\Encryption\\Encrypter $instance */\n                        return $instance->encryptString($value);\n        }\n\n        /**\n         * Decrypt the given value.\n         *\n         * @param string $payload\n         * @param bool $unserialize\n         * @return mixed\n         * @throws \\Illuminate\\Contracts\\Encryption\\DecryptException\n         * @static\n         */        public static function decrypt($payload, $unserialize = true)\n        {\n                        /** @var \\Illuminate\\Encryption\\Encrypter $instance */\n                        return $instance->decrypt($payload, $unserialize);\n        }\n\n        /**\n         * Decrypt the given string without unserialization.\n         *\n         * @param string $payload\n         * @return string\n         * @throws \\Illuminate\\Contracts\\Encryption\\DecryptException\n         * @static\n         */        public static function decryptString($payload)\n        {\n                        /** @var \\Illuminate\\Encryption\\Encrypter $instance */\n                        return $instance->decryptString($payload);\n        }\n\n        /**\n         * Get the encryption key.\n         *\n         * @return string\n         * @static\n         */        public static function getKey()\n        {\n                        /** @var \\Illuminate\\Encryption\\Encrypter $instance */\n                        return $instance->getKey();\n        }\n            }\n\n    /**\n     *\n     *\n     * @see \\Illuminate\\Database\\DatabaseManager\n     * @see \\Illuminate\\Database\\Connection\n     */    class DB {\n\n        /**\n         * Get a database connection instance.\n         *\n         * @param string|null $name\n         * @return \\Illuminate\\Database\\Connection\n         * @static\n         */        public static function connection($name = null)\n        {\n                        /** @var \\Illuminate\\Database\\DatabaseManager $instance */\n                        return $instance->connection($name);\n        }\n\n        /**\n         * Disconnect from the given database and remove from local cache.\n         *\n         * @param string|null $name\n         * @return void\n         * @static\n         */        public static function purge($name = null)\n        {\n                        /** @var \\Illuminate\\Database\\DatabaseManager $instance */\n                        $instance->purge($name);\n        }\n\n        /**\n         * Disconnect from the given database.\n         *\n         * @param string|null $name\n         * @return void\n         * @static\n         */        public static function disconnect($name = null)\n        {\n                        /** @var \\Illuminate\\Database\\DatabaseManager $instance */\n                        $instance->disconnect($name);\n        }\n\n        /**\n         * Reconnect to the given database.\n         *\n         * @param string|null $name\n         * @return \\Illuminate\\Database\\Connection\n         * @static\n         */        public static function reconnect($name = null)\n        {\n                        /** @var \\Illuminate\\Database\\DatabaseManager $instance */\n                        return $instance->reconnect($name);\n        }\n\n        /**\n         * Get the default connection name.\n         *\n         * @return string\n         * @static\n         */        public static function getDefaultConnection()\n        {\n                        /** @var \\Illuminate\\Database\\DatabaseManager $instance */\n                        return $instance->getDefaultConnection();\n        }\n\n        /**\n         * Set the default connection name.\n         *\n         * @param string $name\n         * @return void\n         * @static\n         */        public static function setDefaultConnection($name)\n        {\n                        /** @var \\Illuminate\\Database\\DatabaseManager $instance */\n                        $instance->setDefaultConnection($name);\n        }\n\n        /**\n         * Get all of the support drivers.\n         *\n         * @return array\n         * @static\n         */        public static function supportedDrivers()\n        {\n                        /** @var \\Illuminate\\Database\\DatabaseManager $instance */\n                        return $instance->supportedDrivers();\n        }\n\n        /**\n         * Get all of the drivers that are actually available.\n         *\n         * @return array\n         * @static\n         */        public static function availableDrivers()\n        {\n                        /** @var \\Illuminate\\Database\\DatabaseManager $instance */\n                        return $instance->availableDrivers();\n        }\n\n        /**\n         * Register an extension connection resolver.\n         *\n         * @param string $name\n         * @param callable $resolver\n         * @return void\n         * @static\n         */        public static function extend($name, $resolver)\n        {\n                        /** @var \\Illuminate\\Database\\DatabaseManager $instance */\n                        $instance->extend($name, $resolver);\n        }\n\n        /**\n         * Return all of the created connections.\n         *\n         * @return array\n         * @static\n         */        public static function getConnections()\n        {\n                        /** @var \\Illuminate\\Database\\DatabaseManager $instance */\n                        return $instance->getConnections();\n        }\n\n        /**\n         * Set the database reconnector callback.\n         *\n         * @param callable $reconnector\n         * @return void\n         * @static\n         */        public static function setReconnector($reconnector)\n        {\n                        /** @var \\Illuminate\\Database\\DatabaseManager $instance */\n                        $instance->setReconnector($reconnector);\n        }\n\n        /**\n         * Get a schema builder instance for the connection.\n         *\n         * @return \\Illuminate\\Database\\Schema\\MySqlBuilder\n         * @static\n         */        public static function getSchemaBuilder()\n        {\n                        /** @var \\Illuminate\\Database\\MySqlConnection $instance */\n                        return $instance->getSchemaBuilder();\n        }\n\n        /**\n         * Set the query grammar to the default implementation.\n         *\n         * @return void\n         * @static\n         */        public static function useDefaultQueryGrammar()\n        {\n            //Method inherited from \\Illuminate\\Database\\Connection\n                        /** @var \\Illuminate\\Database\\MySqlConnection $instance */\n                        $instance->useDefaultQueryGrammar();\n        }\n\n        /**\n         * Set the schema grammar to the default implementation.\n         *\n         * @return void\n         * @static\n         */        public static function useDefaultSchemaGrammar()\n        {\n            //Method inherited from \\Illuminate\\Database\\Connection\n                        /** @var \\Illuminate\\Database\\MySqlConnection $instance */\n                        $instance->useDefaultSchemaGrammar();\n        }\n\n        /**\n         * Set the query post processor to the default implementation.\n         *\n         * @return void\n         * @static\n         */        public static function useDefaultPostProcessor()\n        {\n            //Method inherited from \\Illuminate\\Database\\Connection\n                        /** @var \\Illuminate\\Database\\MySqlConnection $instance */\n                        $instance->useDefaultPostProcessor();\n        }\n\n        /**\n         * Begin a fluent query against a database table.\n         *\n         * @param \\Closure|\\Illuminate\\Database\\Query\\Builder|string $table\n         * @param string|null $as\n         * @return \\Illuminate\\Database\\Query\\Builder\n         * @static\n         */        public static function table($table, $as = null)\n        {\n            //Method inherited from \\Illuminate\\Database\\Connection\n                        /** @var \\Illuminate\\Database\\MySqlConnection $instance */\n                        return $instance->table($table, $as);\n        }\n\n        /**\n         * Get a new query builder instance.\n         *\n         * @return \\Illuminate\\Database\\Query\\Builder\n         * @static\n         */        public static function query()\n        {\n            //Method inherited from \\Illuminate\\Database\\Connection\n                        /** @var \\Illuminate\\Database\\MySqlConnection $instance */\n                        return $instance->query();\n        }\n\n        /**\n         * Run a select statement and return a single result.\n         *\n         * @param string $query\n         * @param array $bindings\n         * @param bool $useReadPdo\n         * @return mixed\n         * @static\n         */        public static function selectOne($query, $bindings = [], $useReadPdo = true)\n        {\n            //Method inherited from \\Illuminate\\Database\\Connection\n                        /** @var \\Illuminate\\Database\\MySqlConnection $instance */\n                        return $instance->selectOne($query, $bindings, $useReadPdo);\n        }\n\n        /**\n         * Run a select statement against the database.\n         *\n         * @param string $query\n         * @param array $bindings\n         * @return array\n         * @static\n         */        public static function selectFromWriteConnection($query, $bindings = [])\n        {\n            //Method inherited from \\Illuminate\\Database\\Connection\n                        /** @var \\Illuminate\\Database\\MySqlConnection $instance */\n                        return $instance->selectFromWriteConnection($query, $bindings);\n        }\n\n        /**\n         * Run a select statement against the database.\n         *\n         * @param string $query\n         * @param array $bindings\n         * @param bool $useReadPdo\n         * @return array\n         * @static\n         */        public static function select($query, $bindings = [], $useReadPdo = true)\n        {\n            //Method inherited from \\Illuminate\\Database\\Connection\n                        /** @var \\Illuminate\\Database\\MySqlConnection $instance */\n                        return $instance->select($query, $bindings, $useReadPdo);\n        }\n\n        /**\n         * Run a select statement against the database and returns a generator.\n         *\n         * @param string $query\n         * @param array $bindings\n         * @param bool $useReadPdo\n         * @return \\Generator\n         * @static\n         */        public static function cursor($query, $bindings = [], $useReadPdo = true)\n        {\n            //Method inherited from \\Illuminate\\Database\\Connection\n                        /** @var \\Illuminate\\Database\\MySqlConnection $instance */\n                        return $instance->cursor($query, $bindings, $useReadPdo);\n        }\n\n        /**\n         * Run an insert statement against the database.\n         *\n         * @param string $query\n         * @param array $bindings\n         * @return bool\n         * @static\n         */        public static function insert($query, $bindings = [])\n        {\n            //Method inherited from \\Illuminate\\Database\\Connection\n                        /** @var \\Illuminate\\Database\\MySqlConnection $instance */\n                        return $instance->insert($query, $bindings);\n        }\n\n        /**\n         * Run an update statement against the database.\n         *\n         * @param string $query\n         * @param array $bindings\n         * @return int\n         * @static\n         */        public static function update($query, $bindings = [])\n        {\n            //Method inherited from \\Illuminate\\Database\\Connection\n                        /** @var \\Illuminate\\Database\\MySqlConnection $instance */\n                        return $instance->update($query, $bindings);\n        }\n\n        /**\n         * Run a delete statement against the database.\n         *\n         * @param string $query\n         * @param array $bindings\n         * @return int\n         * @static\n         */        public static function delete($query, $bindings = [])\n        {\n            //Method inherited from \\Illuminate\\Database\\Connection\n                        /** @var \\Illuminate\\Database\\MySqlConnection $instance */\n                        return $instance->delete($query, $bindings);\n        }\n\n        /**\n         * Execute an SQL statement and return the boolean result.\n         *\n         * @param string $query\n         * @param array $bindings\n         * @return bool\n         * @static\n         */        public static function statement($query, $bindings = [])\n        {\n            //Method inherited from \\Illuminate\\Database\\Connection\n                        /** @var \\Illuminate\\Database\\MySqlConnection $instance */\n                        return $instance->statement($query, $bindings);\n        }\n\n        /**\n         * Run an SQL statement and get the number of rows affected.\n         *\n         * @param string $query\n         * @param array $bindings\n         * @return int\n         * @static\n         */        public static function affectingStatement($query, $bindings = [])\n        {\n            //Method inherited from \\Illuminate\\Database\\Connection\n                        /** @var \\Illuminate\\Database\\MySqlConnection $instance */\n                        return $instance->affectingStatement($query, $bindings);\n        }\n\n        /**\n         * Run a raw, unprepared query against the PDO connection.\n         *\n         * @param string $query\n         * @return bool\n         * @static\n         */        public static function unprepared($query)\n        {\n            //Method inherited from \\Illuminate\\Database\\Connection\n                        /** @var \\Illuminate\\Database\\MySqlConnection $instance */\n                        return $instance->unprepared($query);\n        }\n\n        /**\n         * Execute the given callback in "dry run" mode.\n         *\n         * @param \\Closure $callback\n         * @return array\n         * @static\n         */        public static function pretend($callback)\n        {\n            //Method inherited from \\Illuminate\\Database\\Connection\n                        /** @var \\Illuminate\\Database\\MySqlConnection $instance */\n                        return $instance->pretend($callback);\n        }\n\n        /**\n         * Bind values to their parameters in the given statement.\n         *\n         * @param \\PDOStatement $statement\n         * @param array $bindings\n         * @return void\n         * @static\n         */        public static function bindValues($statement, $bindings)\n        {\n            //Method inherited from \\Illuminate\\Database\\Connection\n                        /** @var \\Illuminate\\Database\\MySqlConnection $instance */\n                        $instance->bindValues($statement, $bindings);\n        }\n\n        /**\n         * Prepare the query bindings for execution.\n         *\n         * @param array $bindings\n         * @return array\n         * @static\n         */        public static function prepareBindings($bindings)\n        {\n            //Method inherited from \\Illuminate\\Database\\Connection\n                        /** @var \\Illuminate\\Database\\MySqlConnection $instance */\n                        return $instance->prepareBindings($bindings);\n        }\n\n        /**\n         * Log a query in the connection\'s query log.\n         *\n         * @param string $query\n         * @param array $bindings\n         * @param float|null $time\n         * @return void\n         * @static\n         */        public static function logQuery($query, $bindings, $time = null)\n        {\n            //Method inherited from \\Illuminate\\Database\\Connection\n                        /** @var \\Illuminate\\Database\\MySqlConnection $instance */\n                        $instance->logQuery($query, $bindings, $time);\n        }\n\n        /**\n         * Register a database query listener with the connection.\n         *\n         * @param \\Closure $callback\n         * @return void\n         * @static\n         */        public static function listen($callback)\n        {\n            //Method inherited from \\Illuminate\\Database\\Connection\n                        /** @var \\Illuminate\\Database\\MySqlConnection $instance */\n                        $instance->listen($callback);\n        }\n\n        /**\n         * Get a new raw query expression.\n         *\n         * @param mixed $value\n         * @return \\Illuminate\\Database\\Query\\Expression\n         * @static\n         */        public static function raw($value)\n        {\n            //Method inherited from \\Illuminate\\Database\\Connection\n                        /** @var \\Illuminate\\Database\\MySqlConnection $instance */\n                        return $instance->raw($value);\n        }\n\n        /**\n         * Indicate if any records have been modified.\n         *\n         * @param bool $value\n         * @return void\n         * @static\n         */        public static function recordsHaveBeenModified($value = true)\n        {\n            //Method inherited from \\Illuminate\\Database\\Connection\n                        /** @var \\Illuminate\\Database\\MySqlConnection $instance */\n                        $instance->recordsHaveBeenModified($value);\n        }\n\n        /**\n         * Is Doctrine available?\n         *\n         * @return bool\n         * @static\n         */        public static function isDoctrineAvailable()\n        {\n            //Method inherited from \\Illuminate\\Database\\Connection\n                        /** @var \\Illuminate\\Database\\MySqlConnection $instance */\n                        return $instance->isDoctrineAvailable();\n        }\n\n        /**\n         * Get a Doctrine Schema Column instance.\n         *\n         * @param string $table\n         * @param string $column\n         * @return \\Doctrine\\DBAL\\Schema\\Column\n         * @static\n         */        public static function getDoctrineColumn($table, $column)\n        {\n            //Method inherited from \\Illuminate\\Database\\Connection\n                        /** @var \\Illuminate\\Database\\MySqlConnection $instance */\n                        return $instance->getDoctrineColumn($table, $column);\n        }\n\n        /**\n         * Get the Doctrine DBAL schema manager for the connection.\n         *\n         * @return \\Doctrine\\DBAL\\Schema\\AbstractSchemaManager\n         * @static\n         */        public static function getDoctrineSchemaManager()\n        {\n            //Method inherited from \\Illuminate\\Database\\Connection\n                        /** @var \\Illuminate\\Database\\MySqlConnection $instance */\n                        return $instance->getDoctrineSchemaManager();\n        }\n\n        /**\n         * Get the Doctrine DBAL database connection instance.\n         *\n         * @return \\Doctrine\\DBAL\\Connection\n         * @static\n         */        public static function getDoctrineConnection()\n        {\n            //Method inherited from \\Illuminate\\Database\\Connection\n                        /** @var \\Illuminate\\Database\\MySqlConnection $instance */\n                        return $instance->getDoctrineConnection();\n        }\n\n        /**\n         * Get the current PDO connection.\n         *\n         * @return \\PDO\n         * @static\n         */        public static function getPdo()\n        {\n            //Method inherited from \\Illuminate\\Database\\Connection\n                        /** @var \\Illuminate\\Database\\MySqlConnection $instance */\n                        return $instance->getPdo();\n        }\n\n        /**\n         * Get the current PDO connection parameter without executing any reconnect logic.\n         *\n         * @return \\PDO|\\Closure|null\n         * @static\n         */        public static function getRawPdo()\n        {\n            //Method inherited from \\Illuminate\\Database\\Connection\n                        /** @var \\Illuminate\\Database\\MySqlConnection $instance */\n                        return $instance->getRawPdo();\n        }\n\n        /**\n         * Get the current PDO connection used for reading.\n         *\n         * @return \\PDO\n         * @static\n         */        public static function getReadPdo()\n        {\n            //Method inherited from \\Illuminate\\Database\\Connection\n                        /** @var \\Illuminate\\Database\\MySqlConnection $instance */\n                        return $instance->getReadPdo();\n        }\n\n        /**\n         * Get the current read PDO connection parameter without executing any reconnect logic.\n         *\n         * @return \\PDO|\\Closure|null\n         * @static\n         */        public static function getRawReadPdo()\n        {\n            //Method inherited from \\Illuminate\\Database\\Connection\n                        /** @var \\Illuminate\\Database\\MySqlConnection $instance */\n                        return $instance->getRawReadPdo();\n        }\n\n        /**\n         * Set the PDO connection.\n         *\n         * @param \\PDO|\\Closure|null $pdo\n         * @return \\Illuminate\\Database\\MySqlConnection\n         * @static\n         */        public static function setPdo($pdo)\n        {\n            //Method inherited from \\Illuminate\\Database\\Connection\n                        /** @var \\Illuminate\\Database\\MySqlConnection $instance */\n                        return $instance->setPdo($pdo);\n        }\n\n        /**\n         * Set the PDO connection used for reading.\n         *\n         * @param \\PDO|\\Closure|null $pdo\n         * @return \\Illuminate\\Database\\MySqlConnection\n         * @static\n         */        public static function setReadPdo($pdo)\n        {\n            //Method inherited from \\Illuminate\\Database\\Connection\n                        /** @var \\Illuminate\\Database\\MySqlConnection $instance */\n                        return $instance->setReadPdo($pdo);\n        }\n\n        /**\n         * Get the database connection name.\n         *\n         * @return string|null\n         * @static\n         */        public static function getName()\n        {\n            //Method inherited from \\Illuminate\\Database\\Connection\n                        /** @var \\Illuminate\\Database\\MySqlConnection $instance */\n                        return $instance->getName();\n        }\n\n        /**\n         * Get an option from the configuration options.\n         *\n         * @param string|null $option\n         * @return mixed\n         * @static\n         */        public static function getConfig($option = null)\n        {\n            //Method inherited from \\Illuminate\\Database\\Connection\n                        /** @var \\Illuminate\\Database\\MySqlConnection $instance */\n                        return $instance->getConfig($option);\n        }\n\n        /**\n         * Get the PDO driver name.\n         *\n         * @return string\n         * @static\n         */        public static function getDriverName()\n        {\n            //Method inherited from \\Illuminate\\Database\\Connection\n                        /** @var \\Illuminate\\Database\\MySqlConnection $instance */\n                        return $instance->getDriverName();\n        }\n\n        /**\n         * Get the query grammar used by the connection.\n         *\n         * @return \\Illuminate\\Database\\Query\\Grammars\\Grammar\n         * @static\n         */        public static function getQueryGrammar()\n        {\n            //Method inherited from \\Illuminate\\Database\\Connection\n                        /** @var \\Illuminate\\Database\\MySqlConnection $instance */\n                        return $instance->getQueryGrammar();\n        }\n\n        /**\n         * Set the query grammar used by the connection.\n         *\n         * @param \\Illuminate\\Database\\Query\\Grammars\\Grammar $grammar\n         * @return \\Illuminate\\Database\\MySqlConnection\n         * @static\n         */        public static function setQueryGrammar($grammar)\n        {\n            //Method inherited from \\Illuminate\\Database\\Connection\n                        /** @var \\Illuminate\\Database\\MySqlConnection $instance */\n                        return $instance->setQueryGrammar($grammar);\n        }\n\n        /**\n         * Get the schema grammar used by the connection.\n         *\n         * @return \\Illuminate\\Database\\Schema\\Grammars\\Grammar\n         * @static\n         */        public static function getSchemaGrammar()\n        {\n            //Method inherited from \\Illuminate\\Database\\Connection\n                        /** @var \\Illuminate\\Database\\MySqlConnection $instance */\n                        return $instance->getSchemaGrammar();\n        }\n\n        /**\n         * Set the schema grammar used by the connection.\n         *\n         * @param \\Illuminate\\Database\\Schema\\Grammars\\Grammar $grammar\n         * @return \\Illuminate\\Database\\MySqlConnection\n         * @static\n         */        public static function setSchemaGrammar($grammar)\n        {\n            //Method inherited from \\Illuminate\\Database\\Connection\n                        /** @var \\Illuminate\\Database\\MySqlConnection $instance */\n                        return $instance->setSchemaGrammar($grammar);\n        }\n\n        /**\n         * Get the query post processor used by the connection.\n         *\n         * @return \\Illuminate\\Database\\Query\\Processors\\Processor\n         * @static\n         */        public static function getPostProcessor()\n        {\n            //Method inherited from \\Illuminate\\Database\\Connection\n                        /** @var \\Illuminate\\Database\\MySqlConnection $instance */\n                        return $instance->getPostProcessor();\n        }\n\n        /**\n         * Set the query post processor used by the connection.\n         *\n         * @param \\Illuminate\\Database\\Query\\Processors\\Processor $processor\n         * @return \\Illuminate\\Database\\MySqlConnection\n         * @static\n         */        public static function setPostProcessor($processor)\n        {\n            //Method inherited from \\Illuminate\\Database\\Connection\n                        /** @var \\Illuminate\\Database\\MySqlConnection $instance */\n                        return $instance->setPostProcessor($processor);\n        }\n\n        /**\n         * Get the event dispatcher used by the connection.\n         *\n         * @return \\Illuminate\\Contracts\\Events\\Dispatcher\n         * @static\n         */        public static function getEventDispatcher()\n        {\n            //Method inherited from \\Illuminate\\Database\\Connection\n                        /** @var \\Illuminate\\Database\\MySqlConnection $instance */\n                        return $instance->getEventDispatcher();\n        }\n\n        /**\n         * Set the event dispatcher instance on the connection.\n         *\n         * @param \\Illuminate\\Contracts\\Events\\Dispatcher $events\n         * @return \\Illuminate\\Database\\MySqlConnection\n         * @static\n         */        public static function setEventDispatcher($events)\n        {\n            //Method inherited from \\Illuminate\\Database\\Connection\n                        /** @var \\Illuminate\\Database\\MySqlConnection $instance */\n                        return $instance->setEventDispatcher($events);\n        }\n\n        /**\n         * Unset the event dispatcher for this connection.\n         *\n         * @return void\n         * @static\n         */        public static function unsetEventDispatcher()\n        {\n            //Method inherited from \\Illuminate\\Database\\Connection\n                        /** @var \\Illuminate\\Database\\MySqlConnection $instance */\n                        $instance->unsetEventDispatcher();\n        }\n\n        /**\n         * Determine if the connection is in a "dry run".\n         *\n         * @return bool\n         * @static\n         */        public static function pretending()\n        {\n            //Method inherited from \\Illuminate\\Database\\Connection\n                        /** @var \\Illuminate\\Database\\MySqlConnection $instance */\n                        return $instance->pretending();\n        }\n\n        /**\n         * Get the connection query log.\n         *\n         * @return array\n         * @static\n         */        public static function getQueryLog()\n        {\n            //Method inherited from \\Illuminate\\Database\\Connection\n                        /** @var \\Illuminate\\Database\\MySqlConnection $instance */\n                        return $instance->getQueryLog();\n        }\n\n        /**\n         * Clear the query log.\n         *\n         * @return void\n         * @static\n         */        public static function flushQueryLog()\n        {\n            //Method inherited from \\Illuminate\\Database\\Connection\n                        /** @var \\Illuminate\\Database\\MySqlConnection $instance */\n                        $instance->flushQueryLog();\n        }\n\n        /**\n         * Enable the query log on the connection.\n         *\n         * @return void\n         * @static\n         */        public static function enableQueryLog()\n        {\n            //Method inherited from \\Illuminate\\Database\\Connection\n                        /** @var \\Illuminate\\Database\\MySqlConnection $instance */\n                        $instance->enableQueryLog();\n        }\n\n        /**\n         * Disable the query log on the connection.\n         *\n         * @return void\n         * @static\n         */        public static function disableQueryLog()\n        {\n            //Method inherited from \\Illuminate\\Database\\Connection\n                        /** @var \\Illuminate\\Database\\MySqlConnection $instance */\n                        $instance->disableQueryLog();\n        }\n\n        /**\n         * Determine whether we\'re logging queries.\n         *\n         * @return bool\n         * @static\n         */        public static function logging()\n        {\n            //Method inherited from \\Illuminate\\Database\\Connection\n                        /** @var \\Illuminate\\Database\\MySqlConnection $instance */\n                        return $instance->logging();\n        }\n\n        /**\n         * Get the name of the connected database.\n         *\n         * @return string\n         * @static\n         */        public static function getDatabaseName()\n        {\n            //Method inherited from \\Illuminate\\Database\\Connection\n                        /** @var \\Illuminate\\Database\\MySqlConnection $instance */\n                        return $instance->getDatabaseName();\n        }\n\n        /**\n         * Set the name of the connected database.\n         *\n         * @param string $database\n         * @return \\Illuminate\\Database\\MySqlConnection\n         * @static\n         */        public static function setDatabaseName($database)\n        {\n            //Method inherited from \\Illuminate\\Database\\Connection\n                        /** @var \\Illuminate\\Database\\MySqlConnection $instance */\n                        return $instance->setDatabaseName($database);\n        }\n\n        /**\n         * Get the table prefix for the connection.\n         *\n         * @return string\n         * @static\n         */        public static function getTablePrefix()\n        {\n            //Method inherited from \\Illuminate\\Database\\Connection\n                        /** @var \\Illuminate\\Database\\MySqlConnection $instance */\n                        return $instance->getTablePrefix();\n        }\n\n        /**\n         * Set the table prefix in use by the connection.\n         *\n         * @param string $prefix\n         * @return \\Illuminate\\Database\\MySqlConnection\n         * @static\n         */        public static function setTablePrefix($prefix)\n        {\n            //Method inherited from \\Illuminate\\Database\\Connection\n                        /** @var \\Illuminate\\Database\\MySqlConnection $instance */\n                        return $instance->setTablePrefix($prefix);\n        }\n\n        /**\n         * Set the table prefix and return the grammar.\n         *\n         * @param \\Illuminate\\Database\\Grammar $grammar\n         * @return \\Illuminate\\Database\\Grammar\n         * @static\n         */        public static function withTablePrefix($grammar)\n        {\n            //Method inherited from \\Illuminate\\Database\\Connection\n                        /** @var \\Illuminate\\Database\\MySqlConnection $instance */\n                        return $instance->withTablePrefix($grammar);\n        }\n\n        /**\n         * Register a connection resolver.\n         *\n         * @param string $driver\n         * @param \\Closure $callback\n         * @return void\n         * @static\n         */        public static function resolverFor($driver, $callback)\n        {\n            //Method inherited from \\Illuminate\\Database\\Connection\n                        \\Illuminate\\Database\\MySqlConnection::resolverFor($driver, $callback);\n        }\n\n        /**\n         * Get the connection resolver for the given driver.\n         *\n         * @param string $driver\n         * @return mixed\n         * @static\n         */        public static function getResolver($driver)\n        {\n            //Method inherited from \\Illuminate\\Database\\Connection\n                        return \\Illuminate\\Database\\MySqlConnection::getResolver($driver);\n        }\n\n        /**\n         * Execute a Closure within a transaction.\n         *\n         * @param \\Closure $callback\n         * @param int $attempts\n         * @return mixed\n         * @throws \\Throwable\n         * @static\n         */        public static function transaction($callback, $attempts = 1)\n        {\n            //Method inherited from \\Illuminate\\Database\\Connection\n                        /** @var \\Illuminate\\Database\\MySqlConnection $instance */\n                        return $instance->transaction($callback, $attempts);\n        }\n\n        /**\n         * Start a new database transaction.\n         *\n         * @return void\n         * @throws \\Throwable\n         * @static\n         */        public static function beginTransaction()\n        {\n            //Method inherited from \\Illuminate\\Database\\Connection\n                        /** @var \\Illuminate\\Database\\MySqlConnection $instance */\n                        $instance->beginTransaction();\n        }\n\n        /**\n         * Commit the active database transaction.\n         *\n         * @return void\n         * @throws \\Throwable\n         * @static\n         */        public static function commit()\n        {\n            //Method inherited from \\Illuminate\\Database\\Connection\n                        /** @var \\Illuminate\\Database\\MySqlConnection $instance */\n                        $instance->commit();\n        }\n\n        /**\n         * Rollback the active database transaction.\n         *\n         * @param int|null $toLevel\n         * @return void\n         * @throws \\Throwable\n         * @static\n         */        public static function rollBack($toLevel = null)\n        {\n            //Method inherited from \\Illuminate\\Database\\Connection\n                        /** @var \\Illuminate\\Database\\MySqlConnection $instance */\n                        $instance->rollBack($toLevel);\n        }\n\n        /**\n         * Get the number of active transactions.\n         *\n         * @return int\n         * @static\n         */        public static function transactionLevel()\n        {\n            //Method inherited from \\Illuminate\\Database\\Connection\n                        /** @var \\Illuminate\\Database\\MySqlConnection $instance */\n                        return $instance->transactionLevel();\n        }\n            }\n\n    /**\n     *\n     *\n     * @see \\Illuminate\\Events\\Dispatcher\n     */    class Event {\n\n        /**\n         * Register an event listener with the dispatcher.\n         *\n         * @param string|array $events\n         * @param \\Closure|string $listener\n         * @return void\n         * @static\n         */        public static function listen($events, $listener)\n        {\n                        /** @var \\Illuminate\\Events\\Dispatcher $instance */\n                        $instance->listen($events, $listener);\n        }\n\n        /**\n         * Determine if a given event has listeners.\n         *\n         * @param string $eventName\n         * @return bool\n         * @static\n         */        public static function hasListeners($eventName)\n        {\n                        /** @var \\Illuminate\\Events\\Dispatcher $instance */\n                        return $instance->hasListeners($eventName);\n        }\n\n        /**\n         * Determine if the given event has any wildcard listeners.\n         *\n         * @param string $eventName\n         * @return bool\n         * @static\n         */        public static function hasWildcardListeners($eventName)\n        {\n                        /** @var \\Illuminate\\Events\\Dispatcher $instance */\n                        return $instance->hasWildcardListeners($eventName);\n        }\n\n        /**\n         * Register an event and payload to be fired later.\n         *\n         * @param string $event\n         * @param array $payload\n         * @return void\n         * @static\n         */        public static function push($event, $payload = [])\n        {\n                        /** @var \\Illuminate\\Events\\Dispatcher $instance */\n                        $instance->push($event, $payload);\n        }\n\n        /**\n         * Flush a set of pushed events.\n         *\n         * @param string $event\n         * @return void\n         * @static\n         */        public static function flush($event)\n        {\n                        /** @var \\Illuminate\\Events\\Dispatcher $instance */\n                        $instance->flush($event);\n        }\n\n        /**\n         * Register an event subscriber with the dispatcher.\n         *\n         * @param object|string $subscriber\n         * @return void\n         * @static\n         */        public static function subscribe($subscriber)\n        {\n                        /** @var \\Illuminate\\Events\\Dispatcher $instance */\n                        $instance->subscribe($subscriber);\n        }\n\n        /**\n         * Fire an event until the first non-null response is returned.\n         *\n         * @param string|object $event\n         * @param mixed $payload\n         * @return array|null\n         * @static\n         */        public static function until($event, $payload = [])\n        {\n                        /** @var \\Illuminate\\Events\\Dispatcher $instance */\n                        return $instance->until($event, $payload);\n        }\n\n        /**\n         * Fire an event and call the listeners.\n         *\n         * @param string|object $event\n         * @param mixed $payload\n         * @param bool $halt\n         * @return array|null\n         * @static\n         */        public static function dispatch($event, $payload = [], $halt = false)\n        {\n                        /** @var \\Illuminate\\Events\\Dispatcher $instance */\n                        return $instance->dispatch($event, $payload, $halt);\n        }\n\n        /**\n         * Get all of the listeners for a given event name.\n         *\n         * @param string $eventName\n         * @return array\n         * @static\n         */        public static function getListeners($eventName)\n        {\n                        /** @var \\Illuminate\\Events\\Dispatcher $instance */\n                        return $instance->getListeners($eventName);\n        }\n\n        /**\n         * Register an event listener with the dispatcher.\n         *\n         * @param \\Closure|string $listener\n         * @param bool $wildcard\n         * @return \\Closure\n         * @static\n         */        public static function makeListener($listener, $wildcard = false)\n        {\n                        /** @var \\Illuminate\\Events\\Dispatcher $instance */\n                        return $instance->makeListener($listener, $wildcard);\n        }\n\n        /**\n         * Create a class based listener using the IoC container.\n         *\n         * @param string $listener\n         * @param bool $wildcard\n         * @return \\Closure\n         * @static\n         */        public static function createClassListener($listener, $wildcard = false)\n        {\n                        /** @var \\Illuminate\\Events\\Dispatcher $instance */\n                        return $instance->createClassListener($listener, $wildcard);\n        }\n\n        /**\n         * Remove a set of listeners from the dispatcher.\n         *\n         * @param string $event\n         * @return void\n         * @static\n         */        public static function forget($event)\n        {\n                        /** @var \\Illuminate\\Events\\Dispatcher $instance */\n                        $instance->forget($event);\n        }\n\n        /**\n         * Forget all of the pushed listeners.\n         *\n         * @return void\n         * @static\n         */        public static function forgetPushed()\n        {\n                        /** @var \\Illuminate\\Events\\Dispatcher $instance */\n                        $instance->forgetPushed();\n        }\n\n        /**\n         * Set the queue resolver implementation.\n         *\n         * @param callable $resolver\n         * @return \\Illuminate\\Events\\Dispatcher\n         * @static\n         */        public static function setQueueResolver($resolver)\n        {\n                        /** @var \\Illuminate\\Events\\Dispatcher $instance */\n                        return $instance->setQueueResolver($resolver);\n        }\n\n        /**\n         * Register a custom macro.\n         *\n         * @param string $name\n         * @param object|callable $macro\n         * @return void\n         * @static\n         */        public static function macro($name, $macro)\n        {\n                        \\Illuminate\\Events\\Dispatcher::macro($name, $macro);\n        }\n\n        /**\n         * Mix another object into the class.\n         *\n         * @param object $mixin\n         * @param bool $replace\n         * @return void\n         * @throws \\ReflectionException\n         * @static\n         */        public static function mixin($mixin, $replace = true)\n        {\n                        \\Illuminate\\Events\\Dispatcher::mixin($mixin, $replace);\n        }\n\n        /**\n         * Checks if macro is registered.\n         *\n         * @param string $name\n         * @return bool\n         * @static\n         */        public static function hasMacro($name)\n        {\n                        return \\Illuminate\\Events\\Dispatcher::hasMacro($name);\n        }\n\n        /**\n         * Assert if an event was dispatched based on a truth-test callback.\n         *\n         * @param string $event\n         * @param callable|int|null $callback\n         * @return void\n         * @static\n         */        public static function assertDispatched($event, $callback = null)\n        {\n                        /** @var \\Illuminate\\Support\\Testing\\Fakes\\EventFake $instance */\n                        $instance->assertDispatched($event, $callback);\n        }\n\n        /**\n         * Assert if a event was dispatched a number of times.\n         *\n         * @param string $event\n         * @param int $times\n         * @return void\n         * @static\n         */        public static function assertDispatchedTimes($event, $times = 1)\n        {\n                        /** @var \\Illuminate\\Support\\Testing\\Fakes\\EventFake $instance */\n                        $instance->assertDispatchedTimes($event, $times);\n        }\n\n        /**\n         * Determine if an event was dispatched based on a truth-test callback.\n         *\n         * @param string $event\n         * @param callable|null $callback\n         * @return void\n         * @static\n         */        public static function assertNotDispatched($event, $callback = null)\n        {\n                        /** @var \\Illuminate\\Support\\Testing\\Fakes\\EventFake $instance */\n                        $instance->assertNotDispatched($event, $callback);\n        }\n\n        /**\n         * Get all of the events matching a truth-test callback.\n         *\n         * @param string $event\n         * @param callable|null $callback\n         * @return \\Illuminate\\Support\\Collection\n         * @static\n         */        public static function dispatched($event, $callback = null)\n        {\n                        /** @var \\Illuminate\\Support\\Testing\\Fakes\\EventFake $instance */\n                        return $instance->dispatched($event, $callback);\n        }\n\n        /**\n         * Determine if the given event has been dispatched.\n         *\n         * @param string $event\n         * @return bool\n         * @static\n         */        public static function hasDispatched($event)\n        {\n                        /** @var \\Illuminate\\Support\\Testing\\Fakes\\EventFake $instance */\n                        return $instance->hasDispatched($event);\n        }\n            }\n\n    /**\n     *\n     *\n     * @see \\Illuminate\\Filesystem\\Filesystem\n     */    class File {\n\n        /**\n         * Determine if a file or directory exists.\n         *\n         * @param string $path\n         * @return bool\n         * @static\n         */        public static function exists($path)\n        {\n                        /** @var \\Illuminate\\Filesystem\\Filesystem $instance */\n                        return $instance->exists($path);\n        }\n\n        /**\n         * Determine if a file or directory is missing.\n         *\n         * @param string $path\n         * @return bool\n         * @static\n         */        public static function missing($path)\n        {\n                        /** @var \\Illuminate\\Filesystem\\Filesystem $instance */\n                        return $instance->missing($path);\n        }\n\n        /**\n         * Get the contents of a file.\n         *\n         * @param string $path\n         * @param bool $lock\n         * @return string\n         * @throws \\Illuminate\\Contracts\\Filesystem\\FileNotFoundException\n         * @static\n         */        public static function get($path, $lock = false)\n        {\n                        /** @var \\Illuminate\\Filesystem\\Filesystem $instance */\n                        return $instance->get($path, $lock);\n        }\n\n        /**\n         * Get contents of a file with shared access.\n         *\n         * @param string $path\n         * @return string\n         * @static\n         */        public static function sharedGet($path)\n        {\n                        /** @var \\Illuminate\\Filesystem\\Filesystem $instance */\n                        return $instance->sharedGet($path);\n        }\n\n        /**\n         * Get the returned value of a file.\n         *\n         * @param string $path\n         * @return mixed\n         * @throws \\Illuminate\\Contracts\\Filesystem\\FileNotFoundException\n         * @static\n         */        public static function getRequire($path)\n        {\n                        /** @var \\Illuminate\\Filesystem\\Filesystem $instance */\n                        return $instance->getRequire($path);\n        }\n\n        /**\n         * Require the given file once.\n         *\n         * @param string $file\n         * @return mixed\n         * @static\n         */        public static function requireOnce($file)\n        {\n                        /** @var \\Illuminate\\Filesystem\\Filesystem $instance */\n                        return $instance->requireOnce($file);\n        }\n\n        /**\n         * Get the MD5 hash of the file at the given path.\n         *\n         * @param string $path\n         * @return string\n         * @static\n         */        public static function hash($path)\n        {\n                        /** @var \\Illuminate\\Filesystem\\Filesystem $instance */\n                        return $instance->hash($path);\n        }\n\n        /**\n         * Write the contents of a file.\n         *\n         * @param string $path\n         * @param string $contents\n         * @param bool $lock\n         * @return int|bool\n         * @static\n         */        public static function put($path, $contents, $lock = false)\n        {\n                        /** @var \\Illuminate\\Filesystem\\Filesystem $instance */\n                        return $instance->put($path, $contents, $lock);\n        }\n\n        /**\n         * Write the contents of a file, replacing it atomically if it already exists.\n         *\n         * @param string $path\n         * @param string $content\n         * @return void\n         * @static\n         */        public static function replace($path, $content)\n        {\n                        /** @var \\Illuminate\\Filesystem\\Filesystem $instance */\n                        $instance->replace($path, $content);\n        }\n\n        /**\n         * Prepend to a file.\n         *\n         * @param string $path\n         * @param string $data\n         * @return int\n         * @static\n         */        public static function prepend($path, $data)\n        {\n                        /** @var \\Illuminate\\Filesystem\\Filesystem $instance */\n                        return $instance->prepend($path, $data);\n        }\n\n        /**\n         * Append to a file.\n         *\n         * @param string $path\n         * @param string $data\n         * @return int\n         * @static\n         */        public static function append($path, $data)\n        {\n                        /** @var \\Illuminate\\Filesystem\\Filesystem $instance */\n                        return $instance->append($path, $data);\n        }\n\n        /**\n         * Get or set UNIX mode of a file or directory.\n         *\n         * @param string $path\n         * @param int|null $mode\n         * @return mixed\n         * @static\n         */        public static function chmod($path, $mode = null)\n        {\n                        /** @var \\Illuminate\\Filesystem\\Filesystem $instance */\n                        return $instance->chmod($path, $mode);\n        }\n\n        /**\n         * Delete the file at a given path.\n         *\n         * @param string|array $paths\n         * @return bool\n         * @static\n         */        public static function delete($paths)\n        {\n                        /** @var \\Illuminate\\Filesystem\\Filesystem $instance */\n                        return $instance->delete($paths);\n        }\n\n        /**\n         * Move a file to a new location.\n         *\n         * @param string $path\n         * @param string $target\n         * @return bool\n         * @static\n         */        public static function move($path, $target)\n        {\n                        /** @var \\Illuminate\\Filesystem\\Filesystem $instance */\n                        return $instance->move($path, $target);\n        }\n\n        /**\n         * Copy a file to a new location.\n         *\n         * @param string $path\n         * @param string $target\n         * @return bool\n         * @static\n         */        public static function copy($path, $target)\n        {\n                        /** @var \\Illuminate\\Filesystem\\Filesystem $instance */\n                        return $instance->copy($path, $target);\n        }\n\n        /**\n         * Create a symlink to the target file or directory. On Windows, a hard link is created if the target is a file.\n         *\n         * @param string $target\n         * @param string $link\n         * @return void\n         * @static\n         */        public static function link($target, $link)\n        {\n                        /** @var \\Illuminate\\Filesystem\\Filesystem $instance */\n                        $instance->link($target, $link);\n        }\n\n        /**\n         * Extract the file name from a file path.\n         *\n         * @param string $path\n         * @return string\n         * @static\n         */        public static function name($path)\n        {\n                        /** @var \\Illuminate\\Filesystem\\Filesystem $instance */\n                        return $instance->name($path);\n        }\n\n        /**\n         * Extract the trailing name component from a file path.\n         *\n         * @param string $path\n         * @return string\n         * @static\n         */        public static function basename($path)\n        {\n                        /** @var \\Illuminate\\Filesystem\\Filesystem $instance */\n                        return $instance->basename($path);\n        }\n\n        /**\n         * Extract the parent directory from a file path.\n         *\n         * @param string $path\n         * @return string\n         * @static\n         */        public static function dirname($path)\n        {\n                        /** @var \\Illuminate\\Filesystem\\Filesystem $instance */\n                        return $instance->dirname($path);\n        }\n\n        /**\n         * Extract the file extension from a file path.\n         *\n         * @param string $path\n         * @return string\n         * @static\n         */        public static function extension($path)\n        {\n                        /** @var \\Illuminate\\Filesystem\\Filesystem $instance */\n                        return $instance->extension($path);\n        }\n\n        /**\n         * Get the file type of a given file.\n         *\n         * @param string $path\n         * @return string\n         * @static\n         */        public static function type($path)\n        {\n                        /** @var \\Illuminate\\Filesystem\\Filesystem $instance */\n                        return $instance->type($path);\n        }\n\n        /**\n         * Get the mime-type of a given file.\n         *\n         * @param string $path\n         * @return string|false\n         * @static\n         */        public static function mimeType($path)\n        {\n                        /** @var \\Illuminate\\Filesystem\\Filesystem $instance */\n                        return $instance->mimeType($path);\n        }\n\n        /**\n         * Get the file size of a given file.\n         *\n         * @param string $path\n         * @return int\n         * @static\n         */        public static function size($path)\n        {\n                        /** @var \\Illuminate\\Filesystem\\Filesystem $instance */\n                        return $instance->size($path);\n        }\n\n        /**\n         * Get the file\'s last modification time.\n         *\n         * @param string $path\n         * @return int\n         * @static\n         */        public static function lastModified($path)\n        {\n                        /** @var \\Illuminate\\Filesystem\\Filesystem $instance */\n                        return $instance->lastModified($path);\n        }\n\n        /**\n         * Determine if the given path is a directory.\n         *\n         * @param string $directory\n         * @return bool\n         * @static\n         */        public static function isDirectory($directory)\n        {\n                        /** @var \\Illuminate\\Filesystem\\Filesystem $instance */\n                        return $instance->isDirectory($directory);\n        }\n\n        /**\n         * Determine if the given path is readable.\n         *\n         * @param string $path\n         * @return bool\n         * @static\n         */        public static function isReadable($path)\n        {\n                        /** @var \\Illuminate\\Filesystem\\Filesystem $instance */\n                        return $instance->isReadable($path);\n        }\n\n        /**\n         * Determine if the given path is writable.\n         *\n         * @param string $path\n         * @return bool\n         * @static\n         */        public static function isWritable($path)\n        {\n                        /** @var \\Illuminate\\Filesystem\\Filesystem $instance */\n                        return $instance->isWritable($path);\n        }\n\n        /**\n         * Determine if the given path is a file.\n         *\n         * @param string $file\n         * @return bool\n         * @static\n         */        public static function isFile($file)\n        {\n                        /** @var \\Illuminate\\Filesystem\\Filesystem $instance */\n                        return $instance->isFile($file);\n        }\n\n        /**\n         * Find path names matching a given pattern.\n         *\n         * @param string $pattern\n         * @param int $flags\n         * @return array\n         * @static\n         */        public static function glob($pattern, $flags = 0)\n        {\n                        /** @var \\Illuminate\\Filesystem\\Filesystem $instance */\n                        return $instance->glob($pattern, $flags);\n        }\n\n        /**\n         * Get an array of all files in a directory.\n         *\n         * @param string $directory\n         * @param bool $hidden\n         * @return \\Symfony\\Component\\Finder\\SplFileInfo[]\n         * @static\n         */        public static function files($directory, $hidden = false)\n        {\n                        /** @var \\Illuminate\\Filesystem\\Filesystem $instance */\n                        return $instance->files($directory, $hidden);\n        }\n\n        /**\n         * Get all of the files from the given directory (recursive).\n         *\n         * @param string $directory\n         * @param bool $hidden\n         * @return \\Symfony\\Component\\Finder\\SplFileInfo[]\n         * @static\n         */        public static function allFiles($directory, $hidden = false)\n        {\n                        /** @var \\Illuminate\\Filesystem\\Filesystem $instance */\n                        return $instance->allFiles($directory, $hidden);\n        }\n\n        /**\n         * Get all of the directories within a given directory.\n         *\n         * @param string $directory\n         * @return array\n         * @static\n         */        public static function directories($directory)\n        {\n                        /** @var \\Illuminate\\Filesystem\\Filesystem $instance */\n                        return $instance->directories($directory);\n        }\n\n        /**\n         * Ensure a directory exists.\n         *\n         * @param string $path\n         * @param int $mode\n         * @param bool $recursive\n         * @return void\n         * @static\n         */        public static function ensureDirectoryExists($path, $mode = 493, $recursive = true)\n        {\n                        /** @var \\Illuminate\\Filesystem\\Filesystem $instance */\n                        $instance->ensureDirectoryExists($path, $mode, $recursive);\n        }\n\n        /**\n         * Create a directory.\n         *\n         * @param string $path\n         * @param int $mode\n         * @param bool $recursive\n         * @param bool $force\n         * @return bool\n         * @static\n         */        public static function makeDirectory($path, $mode = 493, $recursive = false, $force = false)\n        {\n                        /** @var \\Illuminate\\Filesystem\\Filesystem $instance */\n                        return $instance->makeDirectory($path, $mode, $recursive, $force);\n        }\n\n        /**\n         * Move a directory.\n         *\n         * @param string $from\n         * @param string $to\n         * @param bool $overwrite\n         * @return bool\n         * @static\n         */        public static function moveDirectory($from, $to, $overwrite = false)\n        {\n                        /** @var \\Illuminate\\Filesystem\\Filesystem $instance */\n                        return $instance->moveDirectory($from, $to, $overwrite);\n        }\n\n        /**\n         * Copy a directory from one location to another.\n         *\n         * @param string $directory\n         * @param string $destination\n         * @param int|null $options\n         * @return bool\n         * @static\n         */        public static function copyDirectory($directory, $destination, $options = null)\n        {\n                        /** @var \\Illuminate\\Filesystem\\Filesystem $instance */\n                        return $instance->copyDirectory($directory, $destination, $options);\n        }\n\n        /**\n         * Recursively delete a directory.\n         *\n         * The directory itself may be optionally preserved.\n         *\n         * @param string $directory\n         * @param bool $preserve\n         * @return bool\n         * @static\n         */        public static function deleteDirectory($directory, $preserve = false)\n        {\n                        /** @var \\Illuminate\\Filesystem\\Filesystem $instance */\n                        return $instance->deleteDirectory($directory, $preserve);\n        }\n\n        /**\n         * Remove all of the directories within a given directory.\n         *\n         * @param string $directory\n         * @return bool\n         * @static\n         */        public static function deleteDirectories($directory)\n        {\n                        /** @var \\Illuminate\\Filesystem\\Filesystem $instance */\n                        return $instance->deleteDirectories($directory);\n        }\n\n        /**\n         * Empty the specified directory of all files and folders.\n         *\n         * @param string $directory\n         * @return bool\n         * @static\n         */        public static function cleanDirectory($directory)\n        {\n                        /** @var \\Illuminate\\Filesystem\\Filesystem $instance */\n                        return $instance->cleanDirectory($directory);\n        }\n\n        /**\n         * Register a custom macro.\n         *\n         * @param string $name\n         * @param object|callable $macro\n         * @return void\n         * @static\n         */        public static function macro($name, $macro)\n        {\n                        \\Illuminate\\Filesystem\\Filesystem::macro($name, $macro);\n        }\n\n        /**\n         * Mix another object into the class.\n         *\n         * @param object $mixin\n         * @param bool $replace\n         * @return void\n         * @throws \\ReflectionException\n         * @static\n         */        public static function mixin($mixin, $replace = true)\n        {\n                        \\Illuminate\\Filesystem\\Filesystem::mixin($mixin, $replace);\n        }\n\n        /**\n         * Checks if macro is registered.\n         *\n         * @param string $name\n         * @return bool\n         * @static\n         */        public static function hasMacro($name)\n        {\n                        return \\Illuminate\\Filesystem\\Filesystem::hasMacro($name);\n        }\n            }\n\n    /**\n     *\n     *\n     * @see \\Illuminate\\Contracts\\Auth\\Access\\Gate\n     */    class Gate {\n\n        /**\n         * Determine if a given ability has been defined.\n         *\n         * @param string|array $ability\n         * @return bool\n         * @static\n         */        public static function has($ability)\n        {\n                        /** @var \\Illuminate\\Auth\\Access\\Gate $instance */\n                        return $instance->has($ability);\n        }\n\n        /**\n         * Define a new ability.\n         *\n         * @param string $ability\n         * @param callable|string $callback\n         * @return \\Illuminate\\Auth\\Access\\Gate\n         * @throws \\InvalidArgumentException\n         * @static\n         */        public static function define($ability, $callback)\n        {\n                        /** @var \\Illuminate\\Auth\\Access\\Gate $instance */\n                        return $instance->define($ability, $callback);\n        }\n\n        /**\n         * Define abilities for a resource.\n         *\n         * @param string $name\n         * @param string $class\n         * @param array|null $abilities\n         * @return \\Illuminate\\Auth\\Access\\Gate\n         * @static\n         */        public static function resource($name, $class, $abilities = null)\n        {\n                        /** @var \\Illuminate\\Auth\\Access\\Gate $instance */\n                        return $instance->resource($name, $class, $abilities);\n        }\n\n        /**\n         * Define a policy class for a given class type.\n         *\n         * @param string $class\n         * @param string $policy\n         * @return \\Illuminate\\Auth\\Access\\Gate\n         * @static\n         */        public static function policy($class, $policy)\n        {\n                        /** @var \\Illuminate\\Auth\\Access\\Gate $instance */\n                        return $instance->policy($class, $policy);\n        }\n\n        /**\n         * Register a callback to run before all Gate checks.\n         *\n         * @param callable $callback\n         * @return \\Illuminate\\Auth\\Access\\Gate\n         * @static\n         */        public static function before($callback)\n        {\n                        /** @var \\Illuminate\\Auth\\Access\\Gate $instance */\n                        return $instance->before($callback);\n        }\n\n        /**\n         * Register a callback to run after all Gate checks.\n         *\n         * @param callable $callback\n         * @return \\Illuminate\\Auth\\Access\\Gate\n         * @static\n         */        public static function after($callback)\n        {\n                        /** @var \\Illuminate\\Auth\\Access\\Gate $instance */\n                        return $instance->after($callback);\n        }\n\n        /**\n         * Determine if the given ability should be granted for the current user.\n         *\n         * @param string $ability\n         * @param array|mixed $arguments\n         * @return bool\n         * @static\n         */        public static function allows($ability, $arguments = [])\n        {\n                        /** @var \\Illuminate\\Auth\\Access\\Gate $instance */\n                        return $instance->allows($ability, $arguments);\n        }\n\n        /**\n         * Determine if the given ability should be denied for the current user.\n         *\n         * @param string $ability\n         * @param array|mixed $arguments\n         * @return bool\n         * @static\n         */        public static function denies($ability, $arguments = [])\n        {\n                        /** @var \\Illuminate\\Auth\\Access\\Gate $instance */\n                        return $instance->denies($ability, $arguments);\n        }\n\n        /**\n         * Determine if all of the given abilities should be granted for the current user.\n         *\n         * @param \\Illuminate\\Auth\\Access\\iterable|string $abilities\n         * @param array|mixed $arguments\n         * @return bool\n         * @static\n         */        public static function check($abilities, $arguments = [])\n        {\n                        /** @var \\Illuminate\\Auth\\Access\\Gate $instance */\n                        return $instance->check($abilities, $arguments);\n        }\n\n        /**\n         * Determine if any one of the given abilities should be granted for the current user.\n         *\n         * @param \\Illuminate\\Auth\\Access\\iterable|string $abilities\n         * @param array|mixed $arguments\n         * @return bool\n         * @static\n         */        public static function any($abilities, $arguments = [])\n        {\n                        /** @var \\Illuminate\\Auth\\Access\\Gate $instance */\n                        return $instance->any($abilities, $arguments);\n        }\n\n        /**\n         * Determine if all of the given abilities should be denied for the current user.\n         *\n         * @param \\Illuminate\\Auth\\Access\\iterable|string $abilities\n         * @param array|mixed $arguments\n         * @return bool\n         * @static\n         */        public static function none($abilities, $arguments = [])\n        {\n                        /** @var \\Illuminate\\Auth\\Access\\Gate $instance */\n                        return $instance->none($abilities, $arguments);\n        }\n\n        /**\n         * Determine if the given ability should be granted for the current user.\n         *\n         * @param string $ability\n         * @param array|mixed $arguments\n         * @return \\Illuminate\\Auth\\Access\\Response\n         * @throws \\Illuminate\\Auth\\Access\\AuthorizationException\n         * @static\n         */        public static function authorize($ability, $arguments = [])\n        {\n                        /** @var \\Illuminate\\Auth\\Access\\Gate $instance */\n                        return $instance->authorize($ability, $arguments);\n        }\n\n        /**\n         * Inspect the user for the given ability.\n         *\n         * @param string $ability\n         * @param array|mixed $arguments\n         * @return \\Illuminate\\Auth\\Access\\Response\n         * @static\n         */        public static function inspect($ability, $arguments = [])\n        {\n                        /** @var \\Illuminate\\Auth\\Access\\Gate $instance */\n                        return $instance->inspect($ability, $arguments);\n        }\n\n        /**\n         * Get the raw result from the authorization callback.\n         *\n         * @param string $ability\n         * @param array|mixed $arguments\n         * @return mixed\n         * @throws \\Illuminate\\Auth\\Access\\AuthorizationException\n         * @static\n         */        public static function raw($ability, $arguments = [])\n        {\n                        /** @var \\Illuminate\\Auth\\Access\\Gate $instance */\n                        return $instance->raw($ability, $arguments);\n        }\n\n        /**\n         * Get a policy instance for a given class.\n         *\n         * @param object|string $class\n         * @return mixed\n         * @static\n         */        public static function getPolicyFor($class)\n        {\n                        /** @var \\Illuminate\\Auth\\Access\\Gate $instance */\n                        return $instance->getPolicyFor($class);\n        }\n\n        /**\n         * Specify a callback to be used to guess policy names.\n         *\n         * @param callable $callback\n         * @return \\Illuminate\\Auth\\Access\\Gate\n         * @static\n         */        public static function guessPolicyNamesUsing($callback)\n        {\n                        /** @var \\Illuminate\\Auth\\Access\\Gate $instance */\n                        return $instance->guessPolicyNamesUsing($callback);\n        }\n\n        /**\n         * Build a policy class instance of the given type.\n         *\n         * @param object|string $class\n         * @return mixed\n         * @throws \\Illuminate\\Contracts\\Container\\BindingResolutionException\n         * @static\n         */        public static function resolvePolicy($class)\n        {\n                        /** @var \\Illuminate\\Auth\\Access\\Gate $instance */\n                        return $instance->resolvePolicy($class);\n        }\n\n        /**\n         * Get a gate instance for the given user.\n         *\n         * @param \\Illuminate\\Contracts\\Auth\\Authenticatable|mixed $user\n         * @return static\n         * @static\n         */        public static function forUser($user)\n        {\n                        /** @var \\Illuminate\\Auth\\Access\\Gate $instance */\n                        return $instance->forUser($user);\n        }\n\n        /**\n         * Get all of the defined abilities.\n         *\n         * @return array\n         * @static\n         */        public static function abilities()\n        {\n                        /** @var \\Illuminate\\Auth\\Access\\Gate $instance */\n                        return $instance->abilities();\n        }\n\n        /**\n         * Get all of the defined policies.\n         *\n         * @return array\n         * @static\n         */        public static function policies()\n        {\n                        /** @var \\Illuminate\\Auth\\Access\\Gate $instance */\n                        return $instance->policies();\n        }\n            }\n\n    /**\n     *\n     *\n     * @see \\Illuminate\\Hashing\\HashManager\n     */    class Hash {\n\n        /**\n         * Create an instance of the Bcrypt hash Driver.\n         *\n         * @return \\Illuminate\\Hashing\\BcryptHasher\n         * @static\n         */        public static function createBcryptDriver()\n        {\n                        /** @var \\Illuminate\\Hashing\\HashManager $instance */\n                        return $instance->createBcryptDriver();\n        }\n\n        /**\n         * Create an instance of the Argon2i hash Driver.\n         *\n         * @return \\Illuminate\\Hashing\\ArgonHasher\n         * @static\n         */        public static function createArgonDriver()\n        {\n                        /** @var \\Illuminate\\Hashing\\HashManager $instance */\n                        return $instance->createArgonDriver();\n        }\n\n        /**\n         * Create an instance of the Argon2id hash Driver.\n         *\n         * @return \\Illuminate\\Hashing\\Argon2IdHasher\n         * @static\n         */        public static function createArgon2idDriver()\n        {\n                        /** @var \\Illuminate\\Hashing\\HashManager $instance */\n                        return $instance->createArgon2idDriver();\n        }\n\n        /**\n         * Get information about the given hashed value.\n         *\n         * @param string $hashedValue\n         * @return array\n         * @static\n         */        public static function info($hashedValue)\n        {\n                        /** @var \\Illuminate\\Hashing\\HashManager $instance */\n                        return $instance->info($hashedValue);\n        }\n\n        /**\n         * Hash the given value.\n         *\n         * @param string $value\n         * @param array $options\n         * @return string\n         * @static\n         */        public static function make($value, $options = [])\n        {\n                        /** @var \\Illuminate\\Hashing\\HashManager $instance */\n                        return $instance->make($value, $options);\n        }\n\n        /**\n         * Check the given plain value against a hash.\n         *\n         * @param string $value\n         * @param string $hashedValue\n         * @param array $options\n         * @return bool\n         * @static\n         */        public static function check($value, $hashedValue, $options = [])\n        {\n                        /** @var \\Illuminate\\Hashing\\HashManager $instance */\n                        return $instance->check($value, $hashedValue, $options);\n        }\n\n        /**\n         * Check if the given hash has been hashed using the given options.\n         *\n         * @param string $hashedValue\n         * @param array $options\n         * @return bool\n         * @static\n         */        public static function needsRehash($hashedValue, $options = [])\n        {\n                        /** @var \\Illuminate\\Hashing\\HashManager $instance */\n                        return $instance->needsRehash($hashedValue, $options);\n        }\n\n        /**\n         * Get the default driver name.\n         *\n         * @return string\n         * @static\n         */        public static function getDefaultDriver()\n        {\n                        /** @var \\Illuminate\\Hashing\\HashManager $instance */\n                        return $instance->getDefaultDriver();\n        }\n\n        /**\n         * Get a driver instance.\n         *\n         * @param string|null $driver\n         * @return mixed\n         * @throws \\InvalidArgumentException\n         * @static\n         */        public static function driver($driver = null)\n        {\n            //Method inherited from \\Illuminate\\Support\\Manager\n                        /** @var \\Illuminate\\Hashing\\HashManager $instance */\n                        return $instance->driver($driver);\n        }\n\n        /**\n         * Register a custom driver creator Closure.\n         *\n         * @param string $driver\n         * @param \\Closure $callback\n         * @return \\Illuminate\\Hashing\\HashManager\n         * @static\n         */        public static function extend($driver, $callback)\n        {\n            //Method inherited from \\Illuminate\\Support\\Manager\n                        /** @var \\Illuminate\\Hashing\\HashManager $instance */\n                        return $instance->extend($driver, $callback);\n        }\n\n        /**\n         * Get all of the created "drivers".\n         *\n         * @return array\n         * @static\n         */        public static function getDrivers()\n        {\n            //Method inherited from \\Illuminate\\Support\\Manager\n                        /** @var \\Illuminate\\Hashing\\HashManager $instance */\n                        return $instance->getDrivers();\n        }\n            }\n\n    /**\n     *\n     *\n     * @method static \\Illuminate\\Http\\Client\\PendingRequest asJson()\n     * @method static \\Illuminate\\Http\\Client\\PendingRequest asForm()\n     * @method static \\Illuminate\\Http\\Client\\PendingRequest attach(string $name, string $contents, string|null $filename = null, array $headers = [])\n     * @method static \\Illuminate\\Http\\Client\\PendingRequest asMultipart()\n     * @method static \\Illuminate\\Http\\Client\\PendingRequest bodyFormat(string $format)\n     * @method static \\Illuminate\\Http\\Client\\PendingRequest contentType(string $contentType)\n     * @method static \\Illuminate\\Http\\Client\\PendingRequest acceptJson()\n     * @method static \\Illuminate\\Http\\Client\\PendingRequest accept(string $contentType)\n     * @method static \\Illuminate\\Http\\Client\\PendingRequest retry(int $times, int $sleep = 0)\n     * @method static \\Illuminate\\Http\\Client\\PendingRequest withHeaders(array $headers)\n     * @method static \\Illuminate\\Http\\Client\\PendingRequest withBasicAuth(string $username, string $password)\n     * @method static \\Illuminate\\Http\\Client\\PendingRequest withDigestAuth(string $username, string $password)\n     * @method static \\Illuminate\\Http\\Client\\PendingRequest withToken(string $token, string $type = \'Bearer\')\n     * @method static \\Illuminate\\Http\\Client\\PendingRequest withCookies(array $cookies, string $domain)\n     * @method static \\Illuminate\\Http\\Client\\PendingRequest withoutRedirecting()\n     * @method static \\Illuminate\\Http\\Client\\PendingRequest withoutVerifying()\n     * @method static \\Illuminate\\Http\\Client\\PendingRequest timeout(int $seconds)\n     * @method static \\Illuminate\\Http\\Client\\PendingRequest withOptions(array $options)\n     * @method static \\Illuminate\\Http\\Client\\PendingRequest beforeSending(callable $callback)\n     * @method static \\Illuminate\\Http\\Client\\Response get(string $url, array $query = [])\n     * @method static \\Illuminate\\Http\\Client\\Response post(string $url, array $data = [])\n     * @method static \\Illuminate\\Http\\Client\\Response patch(string $url, array $data = [])\n     * @method static \\Illuminate\\Http\\Client\\Response put(string $url, array $data = [])\n     * @method static \\Illuminate\\Http\\Client\\Response delete(string $url, array $data = [])\n     * @method static \\Illuminate\\Http\\Client\\Response send(string $method, string $url, array $options = [])\n     * @method static \\Illuminate\\Http\\Client\\PendingRequest stub(callable $callback)\n     * @see \\Illuminate\\Http\\Client\\Factory\n     */    class Http {\n\n        /**\n         * Create a new response instance for use during stubbing.\n         *\n         * @param array|string $body\n         * @param int $status\n         * @param array $headers\n         * @return \\GuzzleHttp\\Promise\\PromiseInterface\n         * @static\n         */        public static function response($body = null, $status = 200, $headers = [])\n        {\n                        return \\Illuminate\\Http\\Client\\Factory::response($body, $status, $headers);\n        }\n\n        /**\n         * Get an invokable object that returns a sequence of responses in order for use during stubbing.\n         *\n         * @param array $responses\n         * @return \\Illuminate\\Http\\Client\\ResponseSequence\n         * @static\n         */        public static function sequence($responses = [])\n        {\n                        /** @var \\Illuminate\\Http\\Client\\Factory $instance */\n                        return $instance->sequence($responses);\n        }\n\n        /**\n         * Register a stub callable that will intercept requests and be able to return stub responses.\n         *\n         * @param callable|array $callback\n         * @return \\Illuminate\\Http\\Client\\Factory\n         * @static\n         */        public static function fake($callback = null)\n        {\n                        /** @var \\Illuminate\\Http\\Client\\Factory $instance */\n                        return $instance->fake($callback);\n        }\n\n        /**\n         * Register a response sequence for the given URL pattern.\n         *\n         * @param string $url\n         * @return \\Illuminate\\Http\\Client\\ResponseSequence\n         * @static\n         */        public static function fakeSequence($url = \'*\')\n        {\n                        /** @var \\Illuminate\\Http\\Client\\Factory $instance */\n                        return $instance->fakeSequence($url);\n        }\n\n        /**\n         * Stub the given URL using the given callback.\n         *\n         * @param string $url\n         * @param \\Illuminate\\Http\\Client\\Response|\\GuzzleHttp\\Promise\\PromiseInterface|callable $callback\n         * @return \\Illuminate\\Http\\Client\\Factory\n         * @static\n         */        public static function stubUrl($url, $callback)\n        {\n                        /** @var \\Illuminate\\Http\\Client\\Factory $instance */\n                        return $instance->stubUrl($url, $callback);\n        }\n\n        /**\n         * Record a request response pair.\n         *\n         * @param \\Illuminate\\Http\\Client\\Request $request\n         * @param \\Illuminate\\Http\\Client\\Response $response\n         * @return void\n         * @static\n         */        public static function recordRequestResponsePair($request, $response)\n        {\n                        /** @var \\Illuminate\\Http\\Client\\Factory $instance */\n                        $instance->recordRequestResponsePair($request, $response);\n        }\n\n        /**\n         * Assert that a request / response pair was recorded matching a given truth test.\n         *\n         * @param callable $callback\n         * @return void\n         * @static\n         */        public static function assertSent($callback)\n        {\n                        /** @var \\Illuminate\\Http\\Client\\Factory $instance */\n                        $instance->assertSent($callback);\n        }\n\n        /**\n         * Assert that a request / response pair was not recorded matching a given truth test.\n         *\n         * @param callable $callback\n         * @return void\n         * @static\n         */        public static function assertNotSent($callback)\n        {\n                        /** @var \\Illuminate\\Http\\Client\\Factory $instance */\n                        $instance->assertNotSent($callback);\n        }\n\n        /**\n         * Assert that no request / response pair was recorded.\n         *\n         * @return void\n         * @static\n         */        public static function assertNothingSent()\n        {\n                        /** @var \\Illuminate\\Http\\Client\\Factory $instance */\n                        $instance->assertNothingSent();\n        }\n\n        /**\n         * Assert how many requests have been recorded.\n         *\n         * @param $count\n         * @return void\n         * @static\n         */        public static function assertSentCount($count)\n        {\n                        /** @var \\Illuminate\\Http\\Client\\Factory $instance */\n                        $instance->assertSentCount($count);\n        }\n\n        /**\n         * Assert that every created response sequence is empty.\n         *\n         * @return void\n         * @static\n         */        public static function assertSequencesAreEmpty()\n        {\n                        /** @var \\Illuminate\\Http\\Client\\Factory $instance */\n                        $instance->assertSequencesAreEmpty();\n        }\n\n        /**\n         * Get a collection of the request / response pairs matching the given truth test.\n         *\n         * @param callable $callback\n         * @return \\Illuminate\\Support\\Collection\n         * @static\n         */        public static function recorded($callback)\n        {\n                        /** @var \\Illuminate\\Http\\Client\\Factory $instance */\n                        return $instance->recorded($callback);\n        }\n\n        /**\n         * Register a custom macro.\n         *\n         * @param string $name\n         * @param object|callable $macro\n         * @return void\n         * @static\n         */        public static function macro($name, $macro)\n        {\n                        \\Illuminate\\Http\\Client\\Factory::macro($name, $macro);\n        }\n\n        /**\n         * Mix another object into the class.\n         *\n         * @param object $mixin\n         * @param bool $replace\n         * @return void\n         * @throws \\ReflectionException\n         * @static\n         */        public static function mixin($mixin, $replace = true)\n        {\n                        \\Illuminate\\Http\\Client\\Factory::mixin($mixin, $replace);\n        }\n\n        /**\n         * Checks if macro is registered.\n         *\n         * @param string $name\n         * @return bool\n         * @static\n         */        public static function hasMacro($name)\n        {\n                        return \\Illuminate\\Http\\Client\\Factory::hasMacro($name);\n        }\n\n        /**\n         * Dynamically handle calls to the class.\n         *\n         * @param string $method\n         * @param array $parameters\n         * @return mixed\n         * @throws \\BadMethodCallException\n         * @static\n         */        public static function macroCall($method, $parameters)\n        {\n                        /** @var \\Illuminate\\Http\\Client\\Factory $instance */\n                        return $instance->macroCall($method, $parameters);\n        }\n            }\n\n    /**\n     *\n     *\n     * @see \\Illuminate\\Translation\\Translator\n     */    class Lang {\n\n        /**\n         * Determine if a translation exists for a given locale.\n         *\n         * @param string $key\n         * @param string|null $locale\n         * @return bool\n         * @static\n         */        public static function hasForLocale($key, $locale = null)\n        {\n                        /** @var \\Illuminate\\Translation\\Translator $instance */\n                        return $instance->hasForLocale($key, $locale);\n        }\n\n        /**\n         * Determine if a translation exists.\n         *\n         * @param string $key\n         * @param string|null $locale\n         * @param bool $fallback\n         * @return bool\n         * @static\n         */        public static function has($key, $locale = null, $fallback = true)\n        {\n                        /** @var \\Illuminate\\Translation\\Translator $instance */\n                        return $instance->has($key, $locale, $fallback);\n        }\n\n        /**\n         * Get the translation for the given key.\n         *\n         * @param string $key\n         * @param array $replace\n         * @param string|null $locale\n         * @param bool $fallback\n         * @return string|array\n         * @static\n         */        public static function get($key, $replace = [], $locale = null, $fallback = true)\n        {\n                        /** @var \\Illuminate\\Translation\\Translator $instance */\n                        return $instance->get($key, $replace, $locale, $fallback);\n        }\n\n        /**\n         * Get a translation according to an integer value.\n         *\n         * @param string $key\n         * @param \\Countable|int|array $number\n         * @param array $replace\n         * @param string|null $locale\n         * @return string\n         * @static\n         */        public static function choice($key, $number, $replace = [], $locale = null)\n        {\n                        /** @var \\Illuminate\\Translation\\Translator $instance */\n                        return $instance->choice($key, $number, $replace, $locale);\n        }\n\n        /**\n         * Add translation lines to the given locale.\n         *\n         * @param array $lines\n         * @param string $locale\n         * @param string $namespace\n         * @return void\n         * @static\n         */        public static function addLines($lines, $locale, $namespace = \'*\')\n        {\n                        /** @var \\Illuminate\\Translation\\Translator $instance */\n                        $instance->addLines($lines, $locale, $namespace);\n        }\n\n        /**\n         * Load the specified language group.\n         *\n         * @param string $namespace\n         * @param string $group\n         * @param string $locale\n         * @return void\n         * @static\n         */        public static function load($namespace, $group, $locale)\n        {\n                        /** @var \\Illuminate\\Translation\\Translator $instance */\n                        $instance->load($namespace, $group, $locale);\n        }\n\n        /**\n         * Add a new namespace to the loader.\n         *\n         * @param string $namespace\n         * @param string $hint\n         * @return void\n         * @static\n         */        public static function addNamespace($namespace, $hint)\n        {\n                        /** @var \\Illuminate\\Translation\\Translator $instance */\n                        $instance->addNamespace($namespace, $hint);\n        }\n\n        /**\n         * Add a new JSON path to the loader.\n         *\n         * @param string $path\n         * @return void\n         * @static\n         */        public static function addJsonPath($path)\n        {\n                        /** @var \\Illuminate\\Translation\\Translator $instance */\n                        $instance->addJsonPath($path);\n        }\n\n        /**\n         * Parse a key into namespace, group, and item.\n         *\n         * @param string $key\n         * @return array\n         * @static\n         */        public static function parseKey($key)\n        {\n                        /** @var \\Illuminate\\Translation\\Translator $instance */\n                        return $instance->parseKey($key);\n        }\n\n        /**\n         * Get the message selector instance.\n         *\n         * @return \\Illuminate\\Translation\\MessageSelector\n         * @static\n         */        public static function getSelector()\n        {\n                        /** @var \\Illuminate\\Translation\\Translator $instance */\n                        return $instance->getSelector();\n        }\n\n        /**\n         * Set the message selector instance.\n         *\n         * @param \\Illuminate\\Translation\\MessageSelector $selector\n         * @return void\n         * @static\n         */        public static function setSelector($selector)\n        {\n                        /** @var \\Illuminate\\Translation\\Translator $instance */\n                        $instance->setSelector($selector);\n        }\n\n        /**\n         * Get the language line loader implementation.\n         *\n         * @return \\Illuminate\\Contracts\\Translation\\Loader\n         * @static\n         */        public static function getLoader()\n        {\n                        /** @var \\Illuminate\\Translation\\Translator $instance */\n                        return $instance->getLoader();\n        }\n\n        /**\n         * Get the default locale being used.\n         *\n         * @return string\n         * @static\n         */        public static function locale()\n        {\n                        /** @var \\Illuminate\\Translation\\Translator $instance */\n                        return $instance->locale();\n        }\n\n        /**\n         * Get the default locale being used.\n         *\n         * @return string\n         * @static\n         */        public static function getLocale()\n        {\n                        /** @var \\Illuminate\\Translation\\Translator $instance */\n                        return $instance->getLocale();\n        }\n\n        /**\n         * Set the default locale.\n         *\n         * @param string $locale\n         * @return void\n         * @static\n         */        public static function setLocale($locale)\n        {\n                        /** @var \\Illuminate\\Translation\\Translator $instance */\n                        $instance->setLocale($locale);\n        }\n\n        /**\n         * Get the fallback locale being used.\n         *\n         * @return string\n         * @static\n         */        public static function getFallback()\n        {\n                        /** @var \\Illuminate\\Translation\\Translator $instance */\n                        return $instance->getFallback();\n        }\n\n        /**\n         * Set the fallback locale being used.\n         *\n         * @param string $fallback\n         * @return void\n         * @static\n         */        public static function setFallback($fallback)\n        {\n                        /** @var \\Illuminate\\Translation\\Translator $instance */\n                        $instance->setFallback($fallback);\n        }\n\n        /**\n         * Set the loaded translation groups.\n         *\n         * @param array $loaded\n         * @return void\n         * @static\n         */        public static function setLoaded($loaded)\n        {\n                        /** @var \\Illuminate\\Translation\\Translator $instance */\n                        $instance->setLoaded($loaded);\n        }\n\n        /**\n         * Set the parsed value of a key.\n         *\n         * @param string $key\n         * @param array $parsed\n         * @return void\n         * @static\n         */        public static function setParsedKey($key, $parsed)\n        {\n            //Method inherited from \\Illuminate\\Support\\NamespacedItemResolver\n                        /** @var \\Illuminate\\Translation\\Translator $instance */\n                        $instance->setParsedKey($key, $parsed);\n        }\n\n        /**\n         * Register a custom macro.\n         *\n         * @param string $name\n         * @param object|callable $macro\n         * @return void\n         * @static\n         */        public static function macro($name, $macro)\n        {\n                        \\Illuminate\\Translation\\Translator::macro($name, $macro);\n        }\n\n        /**\n         * Mix another object into the class.\n         *\n         * @param object $mixin\n         * @param bool $replace\n         * @return void\n         * @throws \\ReflectionException\n         * @static\n         */        public static function mixin($mixin, $replace = true)\n        {\n                        \\Illuminate\\Translation\\Translator::mixin($mixin, $replace);\n        }\n\n        /**\n         * Checks if macro is registered.\n         *\n         * @param string $name\n         * @return bool\n         * @static\n         */        public static function hasMacro($name)\n        {\n                        return \\Illuminate\\Translation\\Translator::hasMacro($name);\n        }\n            }\n\n    /**\n     *\n     *\n     * @see \\Illuminate\\Log\\Logger\n     */    class Log {\n\n        /**\n         * Create a new, on-demand aggregate logger instance.\n         *\n         * @param array $channels\n         * @param string|null $channel\n         * @return \\Psr\\Log\\LoggerInterface\n         * @static\n         */        public static function stack($channels, $channel = null)\n        {\n                        /** @var \\Illuminate\\Log\\LogManager $instance */\n                        return $instance->stack($channels, $channel);\n        }\n\n        /**\n         * Get a log channel instance.\n         *\n         * @param string|null $channel\n         * @return \\Psr\\Log\\LoggerInterface\n         * @static\n         */        public static function channel($channel = null)\n        {\n                        /** @var \\Illuminate\\Log\\LogManager $instance */\n                        return $instance->channel($channel);\n        }\n\n        /**\n         * Get a log driver instance.\n         *\n         * @param string|null $driver\n         * @return \\Psr\\Log\\LoggerInterface\n         * @static\n         */        public static function driver($driver = null)\n        {\n                        /** @var \\Illuminate\\Log\\LogManager $instance */\n                        return $instance->driver($driver);\n        }\n\n        /**\n         *\n         *\n         * @return array\n         * @static\n         */        public static function getChannels()\n        {\n                        /** @var \\Illuminate\\Log\\LogManager $instance */\n                        return $instance->getChannels();\n        }\n\n        /**\n         * Get the default log driver name.\n         *\n         * @return string\n         * @static\n         */        public static function getDefaultDriver()\n        {\n                        /** @var \\Illuminate\\Log\\LogManager $instance */\n                        return $instance->getDefaultDriver();\n        }\n\n        /**\n         * Set the default log driver name.\n         *\n         * @param string $name\n         * @return void\n         * @static\n         */        public static function setDefaultDriver($name)\n        {\n                        /** @var \\Illuminate\\Log\\LogManager $instance */\n                        $instance->setDefaultDriver($name);\n        }\n\n        /**\n         * Register a custom driver creator Closure.\n         *\n         * @param string $driver\n         * @param \\Closure $callback\n         * @return \\Illuminate\\Log\\LogManager\n         * @static\n         */        public static function extend($driver, $callback)\n        {\n                        /** @var \\Illuminate\\Log\\LogManager $instance */\n                        return $instance->extend($driver, $callback);\n        }\n\n        /**\n         * Unset the given channel instance.\n         *\n         * @param string|null $name\n         * @return \\Illuminate\\Log\\LogManager\n         * @static\n         */        public static function forgetChannel($driver = null)\n        {\n                        /** @var \\Illuminate\\Log\\LogManager $instance */\n                        return $instance->forgetChannel($driver);\n        }\n\n        /**\n         * System is unusable.\n         *\n         * @param string $message\n         * @param array $context\n         * @return void\n         * @static\n         */        public static function emergency($message, $context = [])\n        {\n                        /** @var \\Illuminate\\Log\\LogManager $instance */\n                        $instance->emergency($message, $context);\n        }\n\n        /**\n         * Action must be taken immediately.\n         *\n         * Example: Entire website down, database unavailable, etc. This should\n         * trigger the SMS alerts and wake you up.\n         *\n         * @param string $message\n         * @param array $context\n         * @return void\n         * @static\n         */        public static function alert($message, $context = [])\n        {\n                        /** @var \\Illuminate\\Log\\LogManager $instance */\n                        $instance->alert($message, $context);\n        }\n\n        /**\n         * Critical conditions.\n         *\n         * Example: Application component unavailable, unexpected exception.\n         *\n         * @param string $message\n         * @param array $context\n         * @return void\n         * @static\n         */        public static function critical($message, $context = [])\n        {\n                        /** @var \\Illuminate\\Log\\LogManager $instance */\n                        $instance->critical($message, $context);\n        }\n\n        /**\n         * Runtime errors that do not require immediate action but should typically\n         * be logged and monitored.\n         *\n         * @param string $message\n         * @param array $context\n         * @return void\n         * @static\n         */        public static function error($message, $context = [])\n        {\n                        /** @var \\Illuminate\\Log\\LogManager $instance */\n                        $instance->error($message, $context);\n        }\n\n        /**\n         * Exceptional occurrences that are not errors.\n         *\n         * Example: Use of deprecated APIs, poor use of an API, undesirable things\n         * that are not necessarily wrong.\n         *\n         * @param string $message\n         * @param array $context\n         * @return void\n         * @static\n         */        public static function warning($message, $context = [])\n        {\n                        /** @var \\Illuminate\\Log\\LogManager $instance */\n                        $instance->warning($message, $context);\n        }\n\n        /**\n         * Normal but significant events.\n         *\n         * @param string $message\n         * @param array $context\n         * @return void\n         * @static\n         */        public static function notice($message, $context = [])\n        {\n                        /** @var \\Illuminate\\Log\\LogManager $instance */\n                        $instance->notice($message, $context);\n        }\n\n        /**\n         * Interesting events.\n         *\n         * Example: User logs in, SQL logs.\n         *\n         * @param string $message\n         * @param array $context\n         * @return void\n         * @static\n         */        public static function info($message, $context = [])\n        {\n                        /** @var \\Illuminate\\Log\\LogManager $instance */\n                        $instance->info($message, $context);\n        }\n\n        /**\n         * Detailed debug information.\n         *\n         * @param string $message\n         * @param array $context\n         * @return void\n         * @static\n         */        public static function debug($message, $context = [])\n        {\n                        /** @var \\Illuminate\\Log\\LogManager $instance */\n                        $instance->debug($message, $context);\n        }\n\n        /**\n         * Logs with an arbitrary level.\n         *\n         * @param mixed $level\n         * @param string $message\n         * @param array $context\n         * @return void\n         * @static\n         */        public static function log($level, $message, $context = [])\n        {\n                        /** @var \\Illuminate\\Log\\LogManager $instance */\n                        $instance->log($level, $message, $context);\n        }\n            }\n\n    /**\n     *\n     *\n     * @see \\Illuminate\\Mail\\Mailer\n     * @see \\Illuminate\\Support\\Testing\\Fakes\\MailFake\n     */    class Mail {\n\n        /**\n         * Get a mailer instance by name.\n         *\n         * @param string|null $name\n         * @return \\Illuminate\\Mail\\Mailer\n         * @static\n         */        public static function mailer($name = null)\n        {\n                        /** @var \\Illuminate\\Mail\\MailManager $instance */\n                        return $instance->mailer($name);\n        }\n\n        /**\n         * Get a mailer driver instance.\n         *\n         * @param string|null $driver\n         * @return \\Illuminate\\Mail\\Mailer\n         * @static\n         */        public static function driver($driver = null)\n        {\n                        /** @var \\Illuminate\\Mail\\MailManager $instance */\n                        return $instance->driver($driver);\n        }\n\n        /**\n         * Create a new transport instance.\n         *\n         * @param array $config\n         * @return \\Swift_Transport\n         * @static\n         */        public static function createTransport($config)\n        {\n                        /** @var \\Illuminate\\Mail\\MailManager $instance */\n                        return $instance->createTransport($config);\n        }\n\n        /**\n         * Get the default mail driver name.\n         *\n         * @return string\n         * @static\n         */        public static function getDefaultDriver()\n        {\n                        /** @var \\Illuminate\\Mail\\MailManager $instance */\n                        return $instance->getDefaultDriver();\n        }\n\n        /**\n         * Set the default mail driver name.\n         *\n         * @param string $name\n         * @return void\n         * @static\n         */        public static function setDefaultDriver($name)\n        {\n                        /** @var \\Illuminate\\Mail\\MailManager $instance */\n                        $instance->setDefaultDriver($name);\n        }\n\n        /**\n         * Register a custom transport creator Closure.\n         *\n         * @param string $driver\n         * @param \\Closure $callback\n         * @return \\Illuminate\\Mail\\MailManager\n         * @static\n         */        public static function extend($driver, $callback)\n        {\n                        /** @var \\Illuminate\\Mail\\MailManager $instance */\n                        return $instance->extend($driver, $callback);\n        }\n\n        /**\n         * Assert if a mailable was sent based on a truth-test callback.\n         *\n         * @param string $mailable\n         * @param callable|int|null $callback\n         * @return void\n         * @static\n         */        public static function assertSent($mailable, $callback = null)\n        {\n                        /** @var \\Illuminate\\Support\\Testing\\Fakes\\MailFake $instance */\n                        $instance->assertSent($mailable, $callback);\n        }\n\n        /**\n         * Determine if a mailable was not sent based on a truth-test callback.\n         *\n         * @param string $mailable\n         * @param callable|null $callback\n         * @return void\n         * @static\n         */        public static function assertNotSent($mailable, $callback = null)\n        {\n                        /** @var \\Illuminate\\Support\\Testing\\Fakes\\MailFake $instance */\n                        $instance->assertNotSent($mailable, $callback);\n        }\n\n        /**\n         * Assert that no mailables were sent.\n         *\n         * @return void\n         * @static\n         */        public static function assertNothingSent()\n        {\n                        /** @var \\Illuminate\\Support\\Testing\\Fakes\\MailFake $instance */\n                        $instance->assertNothingSent();\n        }\n\n        /**\n         * Assert if a mailable was queued based on a truth-test callback.\n         *\n         * @param string $mailable\n         * @param callable|int|null $callback\n         * @return void\n         * @static\n         */        public static function assertQueued($mailable, $callback = null)\n        {\n                        /** @var \\Illuminate\\Support\\Testing\\Fakes\\MailFake $instance */\n                        $instance->assertQueued($mailable, $callback);\n        }\n\n        /**\n         * Determine if a mailable was not queued based on a truth-test callback.\n         *\n         * @param string $mailable\n         * @param callable|null $callback\n         * @return void\n         * @static\n         */        public static function assertNotQueued($mailable, $callback = null)\n        {\n                        /** @var \\Illuminate\\Support\\Testing\\Fakes\\MailFake $instance */\n                        $instance->assertNotQueued($mailable, $callback);\n        }\n\n        /**\n         * Assert that no mailables were queued.\n         *\n         * @return void\n         * @static\n         */        public static function assertNothingQueued()\n        {\n                        /** @var \\Illuminate\\Support\\Testing\\Fakes\\MailFake $instance */\n                        $instance->assertNothingQueued();\n        }\n\n        /**\n         * Get all of the mailables matching a truth-test callback.\n         *\n         * @param string $mailable\n         * @param callable|null $callback\n         * @return \\Illuminate\\Support\\Collection\n         * @static\n         */        public static function sent($mailable, $callback = null)\n        {\n                        /** @var \\Illuminate\\Support\\Testing\\Fakes\\MailFake $instance */\n                        return $instance->sent($mailable, $callback);\n        }\n\n        /**\n         * Determine if the given mailable has been sent.\n         *\n         * @param string $mailable\n         * @return bool\n         * @static\n         */        public static function hasSent($mailable)\n        {\n                        /** @var \\Illuminate\\Support\\Testing\\Fakes\\MailFake $instance */\n                        return $instance->hasSent($mailable);\n        }\n\n        /**\n         * Get all of the queued mailables matching a truth-test callback.\n         *\n         * @param string $mailable\n         * @param callable|null $callback\n         * @return \\Illuminate\\Support\\Collection\n         * @static\n         */        public static function queued($mailable, $callback = null)\n        {\n                        /** @var \\Illuminate\\Support\\Testing\\Fakes\\MailFake $instance */\n                        return $instance->queued($mailable, $callback);\n        }\n\n        /**\n         * Determine if the given mailable has been queued.\n         *\n         * @param string $mailable\n         * @return bool\n         * @static\n         */        public static function hasQueued($mailable)\n        {\n                        /** @var \\Illuminate\\Support\\Testing\\Fakes\\MailFake $instance */\n                        return $instance->hasQueued($mailable);\n        }\n\n        /**\n         * Begin the process of mailing a mailable class instance.\n         *\n         * @param mixed $users\n         * @return \\Illuminate\\Mail\\PendingMail\n         * @static\n         */        public static function to($users)\n        {\n                        /** @var \\Illuminate\\Support\\Testing\\Fakes\\MailFake $instance */\n                        return $instance->to($users);\n        }\n\n        /**\n         * Begin the process of mailing a mailable class instance.\n         *\n         * @param mixed $users\n         * @return \\Illuminate\\Mail\\PendingMail\n         * @static\n         */        public static function bcc($users)\n        {\n                        /** @var \\Illuminate\\Support\\Testing\\Fakes\\MailFake $instance */\n                        return $instance->bcc($users);\n        }\n\n        /**\n         * Send a new message with only a raw text part.\n         *\n         * @param string $text\n         * @param \\Closure|string $callback\n         * @return void\n         * @static\n         */        public static function raw($text, $callback)\n        {\n                        /** @var \\Illuminate\\Support\\Testing\\Fakes\\MailFake $instance */\n                        $instance->raw($text, $callback);\n        }\n\n        /**\n         * Send a new message using a view.\n         *\n         * @param string|array $view\n         * @param array $data\n         * @param \\Closure|string|null $callback\n         * @return void\n         * @static\n         */        public static function send($view, $data = [], $callback = null)\n        {\n                        /** @var \\Illuminate\\Support\\Testing\\Fakes\\MailFake $instance */\n                        $instance->send($view, $data, $callback);\n        }\n\n        /**\n         * Queue a new e-mail message for sending.\n         *\n         * @param string|array $view\n         * @param string|null $queue\n         * @return mixed\n         * @static\n         */        public static function queue($view, $queue = null)\n        {\n                        /** @var \\Illuminate\\Support\\Testing\\Fakes\\MailFake $instance */\n                        return $instance->queue($view, $queue);\n        }\n\n        /**\n         * Queue a new e-mail message for sending after (n) seconds.\n         *\n         * @param \\DateTimeInterface|\\DateInterval|int $delay\n         * @param \\Illuminate\\Contracts\\Mail\\Mailable|string|array $view\n         * @param string|null $queue\n         * @return mixed\n         * @static\n         */        public static function later($delay, $view, $queue = null)\n        {\n                        /** @var \\Illuminate\\Support\\Testing\\Fakes\\MailFake $instance */\n                        return $instance->later($delay, $view, $queue);\n        }\n\n        /**\n         * Get the array of failed recipients.\n         *\n         * @return array\n         * @static\n         */        public static function failures()\n        {\n                        /** @var \\Illuminate\\Support\\Testing\\Fakes\\MailFake $instance */\n                        return $instance->failures();\n        }\n            }\n\n    /**\n     *\n     *\n     * @see \\Illuminate\\Notifications\\ChannelManager\n     */    class Notification {\n\n        /**\n         * Send the given notification to the given notifiable entities.\n         *\n         * @param \\Illuminate\\Support\\Collection|array|mixed $notifiables\n         * @param mixed $notification\n         * @return void\n         * @static\n         */        public static function send($notifiables, $notification)\n        {\n                        /** @var \\Illuminate\\Notifications\\ChannelManager $instance */\n                        $instance->send($notifiables, $notification);\n        }\n\n        /**\n         * Send the given notification immediately.\n         *\n         * @param \\Illuminate\\Support\\Collection|array|mixed $notifiables\n         * @param mixed $notification\n         * @param array|null $channels\n         * @return void\n         * @static\n         */        public static function sendNow($notifiables, $notification, $channels = null)\n        {\n                        /** @var \\Illuminate\\Notifications\\ChannelManager $instance */\n                        $instance->sendNow($notifiables, $notification, $channels);\n        }\n\n        /**\n         * Get a channel instance.\n         *\n         * @param string|null $name\n         * @return mixed\n         * @static\n         */        public static function channel($name = null)\n        {\n                        /** @var \\Illuminate\\Notifications\\ChannelManager $instance */\n                        return $instance->channel($name);\n        }\n\n        /**\n         * Get the default channel driver name.\n         *\n         * @return string\n         * @static\n         */        public static function getDefaultDriver()\n        {\n                        /** @var \\Illuminate\\Notifications\\ChannelManager $instance */\n                        return $instance->getDefaultDriver();\n        }\n\n        /**\n         * Get the default channel driver name.\n         *\n         * @return string\n         * @static\n         */        public static function deliversVia()\n        {\n                        /** @var \\Illuminate\\Notifications\\ChannelManager $instance */\n                        return $instance->deliversVia();\n        }\n\n        /**\n         * Set the default channel driver name.\n         *\n         * @param string $channel\n         * @return void\n         * @static\n         */        public static function deliverVia($channel)\n        {\n                        /** @var \\Illuminate\\Notifications\\ChannelManager $instance */\n                        $instance->deliverVia($channel);\n        }\n\n        /**\n         * Set the locale of notifications.\n         *\n         * @param string $locale\n         * @return \\Illuminate\\Notifications\\ChannelManager\n         * @static\n         */        public static function locale($locale)\n        {\n                        /** @var \\Illuminate\\Notifications\\ChannelManager $instance */\n                        return $instance->locale($locale);\n        }\n\n        /**\n         * Get a driver instance.\n         *\n         * @param string|null $driver\n         * @return mixed\n         * @throws \\InvalidArgumentException\n         * @static\n         */        public static function driver($driver = null)\n        {\n            //Method inherited from \\Illuminate\\Support\\Manager\n                        /** @var \\Illuminate\\Notifications\\ChannelManager $instance */\n                        return $instance->driver($driver);\n        }\n\n        /**\n         * Register a custom driver creator Closure.\n         *\n         * @param string $driver\n         * @param \\Closure $callback\n         * @return \\Illuminate\\Notifications\\ChannelManager\n         * @static\n         */        public static function extend($driver, $callback)\n        {\n            //Method inherited from \\Illuminate\\Support\\Manager\n                        /** @var \\Illuminate\\Notifications\\ChannelManager $instance */\n                        return $instance->extend($driver, $callback);\n        }\n\n        /**\n         * Get all of the created "drivers".\n         *\n         * @return array\n         * @static\n         */        public static function getDrivers()\n        {\n            //Method inherited from \\Illuminate\\Support\\Manager\n                        /** @var \\Illuminate\\Notifications\\ChannelManager $instance */\n                        return $instance->getDrivers();\n        }\n\n        /**\n         * Assert if a notification was sent based on a truth-test callback.\n         *\n         * @param mixed $notifiable\n         * @param string $notification\n         * @param callable|null $callback\n         * @return void\n         * @throws \\Exception\n         * @static\n         */        public static function assertSentTo($notifiable, $notification, $callback = null)\n        {\n                        /** @var \\Illuminate\\Support\\Testing\\Fakes\\NotificationFake $instance */\n                        $instance->assertSentTo($notifiable, $notification, $callback);\n        }\n\n        /**\n         * Assert if a notification was sent a number of times.\n         *\n         * @param mixed $notifiable\n         * @param string $notification\n         * @param int $times\n         * @return void\n         * @static\n         */        public static function assertSentToTimes($notifiable, $notification, $times = 1)\n        {\n                        /** @var \\Illuminate\\Support\\Testing\\Fakes\\NotificationFake $instance */\n                        $instance->assertSentToTimes($notifiable, $notification, $times);\n        }\n\n        /**\n         * Determine if a notification was sent based on a truth-test callback.\n         *\n         * @param mixed $notifiable\n         * @param string $notification\n         * @param callable|null $callback\n         * @return void\n         * @throws \\Exception\n         * @static\n         */        public static function assertNotSentTo($notifiable, $notification, $callback = null)\n        {\n                        /** @var \\Illuminate\\Support\\Testing\\Fakes\\NotificationFake $instance */\n                        $instance->assertNotSentTo($notifiable, $notification, $callback);\n        }\n\n        /**\n         * Assert that no notifications were sent.\n         *\n         * @return void\n         * @static\n         */        public static function assertNothingSent()\n        {\n                        /** @var \\Illuminate\\Support\\Testing\\Fakes\\NotificationFake $instance */\n                        $instance->assertNothingSent();\n        }\n\n        /**\n         * Assert the total amount of times a notification was sent.\n         *\n         * @param int $expectedCount\n         * @param string $notification\n         * @return void\n         * @static\n         */        public static function assertTimesSent($expectedCount, $notification)\n        {\n                        /** @var \\Illuminate\\Support\\Testing\\Fakes\\NotificationFake $instance */\n                        $instance->assertTimesSent($expectedCount, $notification);\n        }\n\n        /**\n         * Get all of the notifications matching a truth-test callback.\n         *\n         * @param mixed $notifiable\n         * @param string $notification\n         * @param callable|null $callback\n         * @return \\Illuminate\\Support\\Collection\n         * @static\n         */        public static function sent($notifiable, $notification, $callback = null)\n        {\n                        /** @var \\Illuminate\\Support\\Testing\\Fakes\\NotificationFake $instance */\n                        return $instance->sent($notifiable, $notification, $callback);\n        }\n\n        /**\n         * Determine if there are more notifications left to inspect.\n         *\n         * @param mixed $notifiable\n         * @param string $notification\n         * @return bool\n         * @static\n         */        public static function hasSent($notifiable, $notification)\n        {\n                        /** @var \\Illuminate\\Support\\Testing\\Fakes\\NotificationFake $instance */\n                        return $instance->hasSent($notifiable, $notification);\n        }\n\n        /**\n         * Register a custom macro.\n         *\n         * @param string $name\n         * @param object|callable $macro\n         * @return void\n         * @static\n         */        public static function macro($name, $macro)\n        {\n                        \\Illuminate\\Support\\Testing\\Fakes\\NotificationFake::macro($name, $macro);\n        }\n\n        /**\n         * Mix another object into the class.\n         *\n         * @param object $mixin\n         * @param bool $replace\n         * @return void\n         * @throws \\ReflectionException\n         * @static\n         */        public static function mixin($mixin, $replace = true)\n        {\n                        \\Illuminate\\Support\\Testing\\Fakes\\NotificationFake::mixin($mixin, $replace);\n        }\n\n        /**\n         * Checks if macro is registered.\n         *\n         * @param string $name\n         * @return bool\n         * @static\n         */        public static function hasMacro($name)\n        {\n                        return \\Illuminate\\Support\\Testing\\Fakes\\NotificationFake::hasMacro($name);\n        }\n            }\n\n    /**\n     *\n     *\n     * @method static string sendResetLink(array $credentials)\n     * @method static mixed reset(array $credentials, \\Closure $callback)\n     * @see \\Illuminate\\Auth\\Passwords\\PasswordBroker\n     */    class Password {\n\n        /**\n         * Attempt to get the broker from the local cache.\n         *\n         * @param string|null $name\n         * @return \\Illuminate\\Contracts\\Auth\\PasswordBroker\n         * @static\n         */        public static function broker($name = null)\n        {\n                        /** @var \\Illuminate\\Auth\\Passwords\\PasswordBrokerManager $instance */\n                        return $instance->broker($name);\n        }\n\n        /**\n         * Get the default password broker name.\n         *\n         * @return string\n         * @static\n         */        public static function getDefaultDriver()\n        {\n                        /** @var \\Illuminate\\Auth\\Passwords\\PasswordBrokerManager $instance */\n                        return $instance->getDefaultDriver();\n        }\n\n        /**\n         * Set the default password broker name.\n         *\n         * @param string $name\n         * @return void\n         * @static\n         */        public static function setDefaultDriver($name)\n        {\n                        /** @var \\Illuminate\\Auth\\Passwords\\PasswordBrokerManager $instance */\n                        $instance->setDefaultDriver($name);\n        }\n            }\n\n    /**\n     *\n     *\n     * @see \\Illuminate\\Queue\\QueueManager\n     * @see \\Illuminate\\Queue\\Queue\n     */    class Queue {\n\n        /**\n         * Register an event listener for the before job event.\n         *\n         * @param mixed $callback\n         * @return void\n         * @static\n         */        public static function before($callback)\n        {\n                        /** @var \\Illuminate\\Queue\\QueueManager $instance */\n                        $instance->before($callback);\n        }\n\n        /**\n         * Register an event listener for the after job event.\n         *\n         * @param mixed $callback\n         * @return void\n         * @static\n         */        public static function after($callback)\n        {\n                        /** @var \\Illuminate\\Queue\\QueueManager $instance */\n                        $instance->after($callback);\n        }\n\n        /**\n         * Register an event listener for the exception occurred job event.\n         *\n         * @param mixed $callback\n         * @return void\n         * @static\n         */        public static function exceptionOccurred($callback)\n        {\n                        /** @var \\Illuminate\\Queue\\QueueManager $instance */\n                        $instance->exceptionOccurred($callback);\n        }\n\n        /**\n         * Register an event listener for the daemon queue loop.\n         *\n         * @param mixed $callback\n         * @return void\n         * @static\n         */        public static function looping($callback)\n        {\n                        /** @var \\Illuminate\\Queue\\QueueManager $instance */\n                        $instance->looping($callback);\n        }\n\n        /**\n         * Register an event listener for the failed job event.\n         *\n         * @param mixed $callback\n         * @return void\n         * @static\n         */        public static function failing($callback)\n        {\n                        /** @var \\Illuminate\\Queue\\QueueManager $instance */\n                        $instance->failing($callback);\n        }\n\n        /**\n         * Register an event listener for the daemon queue stopping.\n         *\n         * @param mixed $callback\n         * @return void\n         * @static\n         */        public static function stopping($callback)\n        {\n                        /** @var \\Illuminate\\Queue\\QueueManager $instance */\n                        $instance->stopping($callback);\n        }\n\n        /**\n         * Determine if the driver is connected.\n         *\n         * @param string|null $name\n         * @return bool\n         * @static\n         */        public static function connected($name = null)\n        {\n                        /** @var \\Illuminate\\Queue\\QueueManager $instance */\n                        return $instance->connected($name);\n        }\n\n        /**\n         * Resolve a queue connection instance.\n         *\n         * @param string|null $name\n         * @return \\Illuminate\\Contracts\\Queue\\Queue\n         * @static\n         */        public static function connection($name = null)\n        {\n                        /** @var \\Illuminate\\Queue\\QueueManager $instance */\n                        return $instance->connection($name);\n        }\n\n        /**\n         * Add a queue connection resolver.\n         *\n         * @param string $driver\n         * @param \\Closure $resolver\n         * @return void\n         * @static\n         */        public static function extend($driver, $resolver)\n        {\n                        /** @var \\Illuminate\\Queue\\QueueManager $instance */\n                        $instance->extend($driver, $resolver);\n        }\n\n        /**\n         * Add a queue connection resolver.\n         *\n         * @param string $driver\n         * @param \\Closure $resolver\n         * @return void\n         * @static\n         */        public static function addConnector($driver, $resolver)\n        {\n                        /** @var \\Illuminate\\Queue\\QueueManager $instance */\n                        $instance->addConnector($driver, $resolver);\n        }\n\n        /**\n         * Get the name of the default queue connection.\n         *\n         * @return string\n         * @static\n         */        public static function getDefaultDriver()\n        {\n                        /** @var \\Illuminate\\Queue\\QueueManager $instance */\n                        return $instance->getDefaultDriver();\n        }\n\n        /**\n         * Set the name of the default queue connection.\n         *\n         * @param string $name\n         * @return void\n         * @static\n         */        public static function setDefaultDriver($name)\n        {\n                        /** @var \\Illuminate\\Queue\\QueueManager $instance */\n                        $instance->setDefaultDriver($name);\n        }\n\n        /**\n         * Get the full name for the given connection.\n         *\n         * @param string|null $connection\n         * @return string\n         * @static\n         */        public static function getName($connection = null)\n        {\n                        /** @var \\Illuminate\\Queue\\QueueManager $instance */\n                        return $instance->getName($connection);\n        }\n\n        /**\n         * Assert if a job was pushed based on a truth-test callback.\n         *\n         * @param string $job\n         * @param callable|int|null $callback\n         * @return void\n         * @static\n         */        public static function assertPushed($job, $callback = null)\n        {\n                        /** @var \\Illuminate\\Support\\Testing\\Fakes\\QueueFake $instance */\n                        $instance->assertPushed($job, $callback);\n        }\n\n        /**\n         * Assert if a job was pushed based on a truth-test callback.\n         *\n         * @param string $queue\n         * @param string $job\n         * @param callable|null $callback\n         * @return void\n         * @static\n         */        public static function assertPushedOn($queue, $job, $callback = null)\n        {\n                        /** @var \\Illuminate\\Support\\Testing\\Fakes\\QueueFake $instance */\n                        $instance->assertPushedOn($queue, $job, $callback);\n        }\n\n        /**\n         * Assert if a job was pushed with chained jobs based on a truth-test callback.\n         *\n         * @param string $job\n         * @param array $expectedChain\n         * @param callable|null $callback\n         * @return void\n         * @static\n         */        public static function assertPushedWithChain($job, $expectedChain = [], $callback = null)\n        {\n                        /** @var \\Illuminate\\Support\\Testing\\Fakes\\QueueFake $instance */\n                        $instance->assertPushedWithChain($job, $expectedChain, $callback);\n        }\n\n        /**\n         * Assert if a job was pushed with an empty chain based on a truth-test callback.\n         *\n         * @param string $job\n         * @param callable|null $callback\n         * @return void\n         * @static\n         */        public static function assertPushedWithoutChain($job, $callback = null)\n        {\n                        /** @var \\Illuminate\\Support\\Testing\\Fakes\\QueueFake $instance */\n                        $instance->assertPushedWithoutChain($job, $callback);\n        }\n\n        /**\n         * Determine if a job was pushed based on a truth-test callback.\n         *\n         * @param string $job\n         * @param callable|null $callback\n         * @return void\n         * @static\n         */        public static function assertNotPushed($job, $callback = null)\n        {\n                        /** @var \\Illuminate\\Support\\Testing\\Fakes\\QueueFake $instance */\n                        $instance->assertNotPushed($job, $callback);\n        }\n\n        /**\n         * Assert that no jobs were pushed.\n         *\n         * @return void\n         * @static\n         */        public static function assertNothingPushed()\n        {\n                        /** @var \\Illuminate\\Support\\Testing\\Fakes\\QueueFake $instance */\n                        $instance->assertNothingPushed();\n        }\n\n        /**\n         * Get all of the jobs matching a truth-test callback.\n         *\n         * @param string $job\n         * @param callable|null $callback\n         * @return \\Illuminate\\Support\\Collection\n         * @static\n         */        public static function pushed($job, $callback = null)\n        {\n                        /** @var \\Illuminate\\Support\\Testing\\Fakes\\QueueFake $instance */\n                        return $instance->pushed($job, $callback);\n        }\n\n        /**\n         * Determine if there are any stored jobs for a given class.\n         *\n         * @param string $job\n         * @return bool\n         * @static\n         */        public static function hasPushed($job)\n        {\n                        /** @var \\Illuminate\\Support\\Testing\\Fakes\\QueueFake $instance */\n                        return $instance->hasPushed($job);\n        }\n\n        /**\n         * Get the size of the queue.\n         *\n         * @param string|null $queue\n         * @return int\n         * @static\n         */        public static function size($queue = null)\n        {\n                        /** @var \\Illuminate\\Support\\Testing\\Fakes\\QueueFake $instance */\n                        return $instance->size($queue);\n        }\n\n        /**\n         * Push a new job onto the queue.\n         *\n         * @param string $job\n         * @param mixed $data\n         * @param string|null $queue\n         * @return mixed\n         * @static\n         */        public static function push($job, $data = \'\', $queue = null)\n        {\n                        /** @var \\Illuminate\\Support\\Testing\\Fakes\\QueueFake $instance */\n                        return $instance->push($job, $data, $queue);\n        }\n\n        /**\n         * Push a raw payload onto the queue.\n         *\n         * @param string $payload\n         * @param string|null $queue\n         * @param array $options\n         * @return mixed\n         * @static\n         */        public static function pushRaw($payload, $queue = null, $options = [])\n        {\n                        /** @var \\Illuminate\\Support\\Testing\\Fakes\\QueueFake $instance */\n                        return $instance->pushRaw($payload, $queue, $options);\n        }\n\n        /**\n         * Push a new job onto the queue after a delay.\n         *\n         * @param \\DateTimeInterface|\\DateInterval|int $delay\n         * @param string $job\n         * @param mixed $data\n         * @param string|null $queue\n         * @return mixed\n         * @static\n         */        public static function later($delay, $job, $data = \'\', $queue = null)\n        {\n                        /** @var \\Illuminate\\Support\\Testing\\Fakes\\QueueFake $instance */\n                        return $instance->later($delay, $job, $data, $queue);\n        }\n\n        /**\n         * Push a new job onto the queue.\n         *\n         * @param string $queue\n         * @param string $job\n         * @param mixed $data\n         * @return mixed\n         * @static\n         */        public static function pushOn($queue, $job, $data = \'\')\n        {\n                        /** @var \\Illuminate\\Support\\Testing\\Fakes\\QueueFake $instance */\n                        return $instance->pushOn($queue, $job, $data);\n        }\n\n        /**\n         * Push a new job onto the queue after a delay.\n         *\n         * @param string $queue\n         * @param \\DateTimeInterface|\\DateInterval|int $delay\n         * @param string $job\n         * @param mixed $data\n         * @return mixed\n         * @static\n         */        public static function laterOn($queue, $delay, $job, $data = \'\')\n        {\n                        /** @var \\Illuminate\\Support\\Testing\\Fakes\\QueueFake $instance */\n                        return $instance->laterOn($queue, $delay, $job, $data);\n        }\n\n        /**\n         * Pop the next job off of the queue.\n         *\n         * @param string|null $queue\n         * @return \\Illuminate\\Contracts\\Queue\\Job|null\n         * @static\n         */        public static function pop($queue = null)\n        {\n                        /** @var \\Illuminate\\Support\\Testing\\Fakes\\QueueFake $instance */\n                        return $instance->pop($queue);\n        }\n\n        /**\n         * Push an array of jobs onto the queue.\n         *\n         * @param array $jobs\n         * @param mixed $data\n         * @param string|null $queue\n         * @return mixed\n         * @static\n         */        public static function bulk($jobs, $data = \'\', $queue = null)\n        {\n                        /** @var \\Illuminate\\Support\\Testing\\Fakes\\QueueFake $instance */\n                        return $instance->bulk($jobs, $data, $queue);\n        }\n\n        /**\n         * Get the jobs that have been pushed.\n         *\n         * @return array\n         * @static\n         */        public static function pushedJobs()\n        {\n                        /** @var \\Illuminate\\Support\\Testing\\Fakes\\QueueFake $instance */\n                        return $instance->pushedJobs();\n        }\n\n        /**\n         * Get the connection name for the queue.\n         *\n         * @return string\n         * @static\n         */        public static function getConnectionName()\n        {\n                        /** @var \\Illuminate\\Support\\Testing\\Fakes\\QueueFake $instance */\n                        return $instance->getConnectionName();\n        }\n\n        /**\n         * Set the connection name for the queue.\n         *\n         * @param string $name\n         * @return \\Illuminate\\Support\\Testing\\Fakes\\QueueFake\n         * @static\n         */        public static function setConnectionName($name)\n        {\n                        /** @var \\Illuminate\\Support\\Testing\\Fakes\\QueueFake $instance */\n                        return $instance->setConnectionName($name);\n        }\n\n        /**\n         * Get the retry delay for an object-based queue handler.\n         *\n         * @param mixed $job\n         * @return mixed\n         * @static\n         */        public static function getJobRetryDelay($job)\n        {\n            //Method inherited from \\Illuminate\\Queue\\Queue\n                        /** @var \\Illuminate\\Queue\\SyncQueue $instance */\n                        return $instance->getJobRetryDelay($job);\n        }\n\n        /**\n         * Get the expiration timestamp for an object-based queue handler.\n         *\n         * @param mixed $job\n         * @return mixed\n         * @static\n         */        public static function getJobExpiration($job)\n        {\n            //Method inherited from \\Illuminate\\Queue\\Queue\n                        /** @var \\Illuminate\\Queue\\SyncQueue $instance */\n                        return $instance->getJobExpiration($job);\n        }\n\n        /**\n         * Register a callback to be executed when creating job payloads.\n         *\n         * @param callable $callback\n         * @return void\n         * @static\n         */        public static function createPayloadUsing($callback)\n        {\n            //Method inherited from \\Illuminate\\Queue\\Queue\n                        \\Illuminate\\Queue\\SyncQueue::createPayloadUsing($callback);\n        }\n\n        /**\n         * Set the IoC container instance.\n         *\n         * @param \\Illuminate\\Container\\Container $container\n         * @return void\n         * @static\n         */        public static function setContainer($container)\n        {\n            //Method inherited from \\Illuminate\\Queue\\Queue\n                        /** @var \\Illuminate\\Queue\\SyncQueue $instance */\n                        $instance->setContainer($container);\n        }\n            }\n\n    /**\n     *\n     *\n     * @see \\Illuminate\\Routing\\Redirector\n     */    class Redirect {\n\n        /**\n         * Create a new redirect response to the "home" route.\n         *\n         * @param int $status\n         * @return \\Illuminate\\Http\\RedirectResponse\n         * @static\n         */        public static function home($status = 302)\n        {\n                        /** @var \\Illuminate\\Routing\\Redirector $instance */\n                        return $instance->home($status);\n        }\n\n        /**\n         * Create a new redirect response to the previous location.\n         *\n         * @param int $status\n         * @param array $headers\n         * @param mixed $fallback\n         * @return \\Illuminate\\Http\\RedirectResponse\n         * @static\n         */        public static function back($status = 302, $headers = [], $fallback = false)\n        {\n                        /** @var \\Illuminate\\Routing\\Redirector $instance */\n                        return $instance->back($status, $headers, $fallback);\n        }\n\n        /**\n         * Create a new redirect response to the current URI.\n         *\n         * @param int $status\n         * @param array $headers\n         * @return \\Illuminate\\Http\\RedirectResponse\n         * @static\n         */        public static function refresh($status = 302, $headers = [])\n        {\n                        /** @var \\Illuminate\\Routing\\Redirector $instance */\n                        return $instance->refresh($status, $headers);\n        }\n\n        /**\n         * Create a new redirect response, while putting the current URL in the session.\n         *\n         * @param string $path\n         * @param int $status\n         * @param array $headers\n         * @param bool|null $secure\n         * @return \\Illuminate\\Http\\RedirectResponse\n         * @static\n         */        public static function guest($path, $status = 302, $headers = [], $secure = null)\n        {\n                        /** @var \\Illuminate\\Routing\\Redirector $instance */\n                        return $instance->guest($path, $status, $headers, $secure);\n        }\n\n        /**\n         * Create a new redirect response to the previously intended location.\n         *\n         * @param string $default\n         * @param int $status\n         * @param array $headers\n         * @param bool|null $secure\n         * @return \\Illuminate\\Http\\RedirectResponse\n         * @static\n         */        public static function intended($default = \'/\', $status = 302, $headers = [], $secure = null)\n        {\n                        /** @var \\Illuminate\\Routing\\Redirector $instance */\n                        return $instance->intended($default, $status, $headers, $secure);\n        }\n\n        /**\n         * Set the intended url.\n         *\n         * @param string $url\n         * @return void\n         * @static\n         */        public static function setIntendedUrl($url)\n        {\n                        /** @var \\Illuminate\\Routing\\Redirector $instance */\n                        $instance->setIntendedUrl($url);\n        }\n\n        /**\n         * Create a new redirect response to the given path.\n         *\n         * @param string $path\n         * @param int $status\n         * @param array $headers\n         * @param bool|null $secure\n         * @return \\Illuminate\\Http\\RedirectResponse\n         * @static\n         */        public static function to($path, $status = 302, $headers = [], $secure = null)\n        {\n                        /** @var \\Illuminate\\Routing\\Redirector $instance */\n                        return $instance->to($path, $status, $headers, $secure);\n        }\n\n        /**\n         * Create a new redirect response to an external URL (no validation).\n         *\n         * @param string $path\n         * @param int $status\n         * @param array $headers\n         * @return \\Illuminate\\Http\\RedirectResponse\n         * @static\n         */        public static function away($path, $status = 302, $headers = [])\n        {\n                        /** @var \\Illuminate\\Routing\\Redirector $instance */\n                        return $instance->away($path, $status, $headers);\n        }\n\n        /**\n         * Create a new redirect response to the given HTTPS path.\n         *\n         * @param string $path\n         * @param int $status\n         * @param array $headers\n         * @return \\Illuminate\\Http\\RedirectResponse\n         * @static\n         */        public static function secure($path, $status = 302, $headers = [])\n        {\n                        /** @var \\Illuminate\\Routing\\Redirector $instance */\n                        return $instance->secure($path, $status, $headers);\n        }\n\n        /**\n         * Create a new redirect response to a named route.\n         *\n         * @param string $route\n         * @param mixed $parameters\n         * @param int $status\n         * @param array $headers\n         * @return \\Illuminate\\Http\\RedirectResponse\n         * @static\n         */        public static function route($route, $parameters = [], $status = 302, $headers = [])\n        {\n                        /** @var \\Illuminate\\Routing\\Redirector $instance */\n                        return $instance->route($route, $parameters, $status, $headers);\n        }\n\n        /**\n         * Create a new redirect response to a signed named route.\n         *\n         * @param string $route\n         * @param mixed $parameters\n         * @param \\DateTimeInterface|\\DateInterval|int|null $expiration\n         * @param int $status\n         * @param array $headers\n         * @return \\Illuminate\\Http\\RedirectResponse\n         * @static\n         */        public static function signedRoute($route, $parameters = [], $expiration = null, $status = 302, $headers = [])\n        {\n                        /** @var \\Illuminate\\Routing\\Redirector $instance */\n                        return $instance->signedRoute($route, $parameters, $expiration, $status, $headers);\n        }\n\n        /**\n         * Create a new redirect response to a signed named route.\n         *\n         * @param string $route\n         * @param \\DateTimeInterface|\\DateInterval|int|null $expiration\n         * @param mixed $parameters\n         * @param int $status\n         * @param array $headers\n         * @return \\Illuminate\\Http\\RedirectResponse\n         * @static\n         */        public static function temporarySignedRoute($route, $expiration, $parameters = [], $status = 302, $headers = [])\n        {\n                        /** @var \\Illuminate\\Routing\\Redirector $instance */\n                        return $instance->temporarySignedRoute($route, $expiration, $parameters, $status, $headers);\n        }\n\n        /**\n         * Create a new redirect response to a controller action.\n         *\n         * @param string|array $action\n         * @param mixed $parameters\n         * @param int $status\n         * @param array $headers\n         * @return \\Illuminate\\Http\\RedirectResponse\n         * @static\n         */        public static function action($action, $parameters = [], $status = 302, $headers = [])\n        {\n                        /** @var \\Illuminate\\Routing\\Redirector $instance */\n                        return $instance->action($action, $parameters, $status, $headers);\n        }\n\n        /**\n         * Get the URL generator instance.\n         *\n         * @return \\Illuminate\\Routing\\UrlGenerator\n         * @static\n         */        public static function getUrlGenerator()\n        {\n                        /** @var \\Illuminate\\Routing\\Redirector $instance */\n                        return $instance->getUrlGenerator();\n        }\n\n        /**\n         * Set the active session store.\n         *\n         * @param \\Illuminate\\Session\\Store $session\n         * @return void\n         * @static\n         */        public static function setSession($session)\n        {\n                        /** @var \\Illuminate\\Routing\\Redirector $instance */\n                        $instance->setSession($session);\n        }\n\n        /**\n         * Register a custom macro.\n         *\n         * @param string $name\n         * @param object|callable $macro\n         * @return void\n         * @static\n         */        public static function macro($name, $macro)\n        {\n                        \\Illuminate\\Routing\\Redirector::macro($name, $macro);\n        }\n\n        /**\n         * Mix another object into the class.\n         *\n         * @param object $mixin\n         * @param bool $replace\n         * @return void\n         * @throws \\ReflectionException\n         * @static\n         */        public static function mixin($mixin, $replace = true)\n        {\n                        \\Illuminate\\Routing\\Redirector::mixin($mixin, $replace);\n        }\n\n        /**\n         * Checks if macro is registered.\n         *\n         * @param string $name\n         * @return bool\n         * @static\n         */        public static function hasMacro($name)\n        {\n                        return \\Illuminate\\Routing\\Redirector::hasMacro($name);\n        }\n            }\n\n    /**\n     *\n     *\n     * @method static mixed filterFiles(mixed $files)\n     * @see \\Illuminate\\Http\\Request\n     */    class Request {\n\n        /**\n         * Create a new Illuminate HTTP request from server variables.\n         *\n         * @return static\n         * @static\n         */        public static function capture()\n        {\n                        return \\Illuminate\\Http\\Request::capture();\n        }\n\n        /**\n         * Return the Request instance.\n         *\n         * @return \\Illuminate\\Http\\Request\n         * @static\n         */        public static function instance()\n        {\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->instance();\n        }\n\n        /**\n         * Get the request method.\n         *\n         * @return string\n         * @static\n         */        public static function method()\n        {\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->method();\n        }\n\n        /**\n         * Get the root URL for the application.\n         *\n         * @return string\n         * @static\n         */        public static function root()\n        {\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->root();\n        }\n\n        /**\n         * Get the URL (no query string) for the request.\n         *\n         * @return string\n         * @static\n         */        public static function url()\n        {\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->url();\n        }\n\n        /**\n         * Get the full URL for the request.\n         *\n         * @return string\n         * @static\n         */        public static function fullUrl()\n        {\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->fullUrl();\n        }\n\n        /**\n         * Get the full URL for the request with the added query string parameters.\n         *\n         * @param array $query\n         * @return string\n         * @static\n         */        public static function fullUrlWithQuery($query)\n        {\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->fullUrlWithQuery($query);\n        }\n\n        /**\n         * Get the current path info for the request.\n         *\n         * @return string\n         * @static\n         */        public static function path()\n        {\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->path();\n        }\n\n        /**\n         * Get the current decoded path info for the request.\n         *\n         * @return string\n         * @static\n         */        public static function decodedPath()\n        {\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->decodedPath();\n        }\n\n        /**\n         * Get a segment from the URI (1 based index).\n         *\n         * @param int $index\n         * @param string|null $default\n         * @return string|null\n         * @static\n         */        public static function segment($index, $default = null)\n        {\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->segment($index, $default);\n        }\n\n        /**\n         * Get all of the segments for the request path.\n         *\n         * @return array\n         * @static\n         */        public static function segments()\n        {\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->segments();\n        }\n\n        /**\n         * Determine if the current request URI matches a pattern.\n         *\n         * @param mixed $patterns\n         * @return bool\n         * @static\n         */        public static function is(...$patterns)\n        {\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->is(...$patterns);\n        }\n\n        /**\n         * Determine if the route name matches a given pattern.\n         *\n         * @param mixed $patterns\n         * @return bool\n         * @static\n         */        public static function routeIs(...$patterns)\n        {\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->routeIs(...$patterns);\n        }\n\n        /**\n         * Determine if the current request URL and query string matches a pattern.\n         *\n         * @param mixed $patterns\n         * @return bool\n         * @static\n         */        public static function fullUrlIs(...$patterns)\n        {\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->fullUrlIs(...$patterns);\n        }\n\n        /**\n         * Determine if the request is the result of an AJAX call.\n         *\n         * @return bool\n         * @static\n         */        public static function ajax()\n        {\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->ajax();\n        }\n\n        /**\n         * Determine if the request is the result of an PJAX call.\n         *\n         * @return bool\n         * @static\n         */        public static function pjax()\n        {\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->pjax();\n        }\n\n        /**\n         * Determine if the request is the result of an prefetch call.\n         *\n         * @return bool\n         * @static\n         */        public static function prefetch()\n        {\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->prefetch();\n        }\n\n        /**\n         * Determine if the request is over HTTPS.\n         *\n         * @return bool\n         * @static\n         */        public static function secure()\n        {\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->secure();\n        }\n\n        /**\n         * Get the client IP address.\n         *\n         * @return string|null\n         * @static\n         */        public static function ip()\n        {\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->ip();\n        }\n\n        /**\n         * Get the client IP addresses.\n         *\n         * @return array\n         * @static\n         */        public static function ips()\n        {\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->ips();\n        }\n\n        /**\n         * Get the client user agent.\n         *\n         * @return string\n         * @static\n         */        public static function userAgent()\n        {\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->userAgent();\n        }\n\n        /**\n         * Merge new input into the current request\'s input array.\n         *\n         * @param array $input\n         * @return \\Illuminate\\Http\\Request\n         * @static\n         */        public static function merge($input)\n        {\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->merge($input);\n        }\n\n        /**\n         * Replace the input for the current request.\n         *\n         * @param array $input\n         * @return \\Illuminate\\Http\\Request\n         * @static\n         */        public static function replace($input)\n        {\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->replace($input);\n        }\n\n        /**\n         * This method belongs to Symfony HttpFoundation and is not usually needed when using Laravel.\n         *\n         * Instead, you may use the "input" method.\n         *\n         * @param string $key\n         * @param mixed $default\n         * @return mixed\n         * @static\n         */        public static function get($key, $default = null)\n        {\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->get($key, $default);\n        }\n\n        /**\n         * Get the JSON payload for the request.\n         *\n         * @param string|null $key\n         * @param mixed $default\n         * @return \\Symfony\\Component\\HttpFoundation\\ParameterBag|mixed\n         * @static\n         */        public static function json($key = null, $default = null)\n        {\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->json($key, $default);\n        }\n\n        /**\n         * Create a new request instance from the given Laravel request.\n         *\n         * @param \\Illuminate\\Http\\Request $from\n         * @param \\Illuminate\\Http\\Request|null $to\n         * @return static\n         * @static\n         */        public static function createFrom($from, $to = null)\n        {\n                        return \\Illuminate\\Http\\Request::createFrom($from, $to);\n        }\n\n        /**\n         * Create an Illuminate request from a Symfony instance.\n         *\n         * @param \\Symfony\\Component\\HttpFoundation\\Request $request\n         * @return static\n         * @static\n         */        public static function createFromBase($request)\n        {\n                        return \\Illuminate\\Http\\Request::createFromBase($request);\n        }\n\n        /**\n         * Clones a request and overrides some of its parameters.\n         *\n         * @param array $query The GET parameters\n         * @param array $request The POST parameters\n         * @param array $attributes The request attributes (parameters parsed from the PATH_INFO, ...)\n         * @param array $cookies The COOKIE parameters\n         * @param array $files The FILES parameters\n         * @param array $server The SERVER parameters\n         * @return static\n         * @static\n         */        public static function duplicate($query = null, $request = null, $attributes = null, $cookies = null, $files = null, $server = null)\n        {\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->duplicate($query, $request, $attributes, $cookies, $files, $server);\n        }\n\n        /**\n         * Get the session associated with the request.\n         *\n         * @return \\Illuminate\\Session\\Store\n         * @throws \\RuntimeException\n         * @static\n         */        public static function session()\n        {\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->session();\n        }\n\n        /**\n         * Get the session associated with the request.\n         *\n         * @return \\Illuminate\\Session\\Store|null\n         * @static\n         */        public static function getSession()\n        {\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->getSession();\n        }\n\n        /**\n         * Set the session instance on the request.\n         *\n         * @param \\Illuminate\\Contracts\\Session\\Session $session\n         * @return void\n         * @static\n         */        public static function setLaravelSession($session)\n        {\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        $instance->setLaravelSession($session);\n        }\n\n        /**\n         * Get the user making the request.\n         *\n         * @param string|null $guard\n         * @return mixed\n         * @static\n         */        public static function user($guard = null)\n        {\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->user($guard);\n        }\n\n        /**\n         * Get the route handling the request.\n         *\n         * @param string|null $param\n         * @param mixed $default\n         * @return \\Illuminate\\Routing\\Route|object|string|null\n         * @static\n         */        public static function route($param = null, $default = null)\n        {\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->route($param, $default);\n        }\n\n        /**\n         * Get a unique fingerprint for the request / route / IP address.\n         *\n         * @return string\n         * @throws \\RuntimeException\n         * @static\n         */        public static function fingerprint()\n        {\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->fingerprint();\n        }\n\n        /**\n         * Set the JSON payload for the request.\n         *\n         * @param \\Symfony\\Component\\HttpFoundation\\ParameterBag $json\n         * @return \\Illuminate\\Http\\Request\n         * @static\n         */        public static function setJson($json)\n        {\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->setJson($json);\n        }\n\n        /**\n         * Get the user resolver callback.\n         *\n         * @return \\Closure\n         * @static\n         */        public static function getUserResolver()\n        {\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->getUserResolver();\n        }\n\n        /**\n         * Set the user resolver callback.\n         *\n         * @param \\Closure $callback\n         * @return \\Illuminate\\Http\\Request\n         * @static\n         */        public static function setUserResolver($callback)\n        {\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->setUserResolver($callback);\n        }\n\n        /**\n         * Get the route resolver callback.\n         *\n         * @return \\Closure\n         * @static\n         */        public static function getRouteResolver()\n        {\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->getRouteResolver();\n        }\n\n        /**\n         * Set the route resolver callback.\n         *\n         * @param \\Closure $callback\n         * @return \\Illuminate\\Http\\Request\n         * @static\n         */        public static function setRouteResolver($callback)\n        {\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->setRouteResolver($callback);\n        }\n\n        /**\n         * Get all of the input and files for the request.\n         *\n         * @return array\n         * @static\n         */        public static function toArray()\n        {\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->toArray();\n        }\n\n        /**\n         * Determine if the given offset exists.\n         *\n         * @param string $offset\n         * @return bool\n         * @static\n         */        public static function offsetExists($offset)\n        {\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->offsetExists($offset);\n        }\n\n        /**\n         * Get the value at the given offset.\n         *\n         * @param string $offset\n         * @return mixed\n         * @static\n         */        public static function offsetGet($offset)\n        {\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->offsetGet($offset);\n        }\n\n        /**\n         * Set the value at the given offset.\n         *\n         * @param string $offset\n         * @param mixed $value\n         * @return void\n         * @static\n         */        public static function offsetSet($offset, $value)\n        {\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        $instance->offsetSet($offset, $value);\n        }\n\n        /**\n         * Remove the value at the given offset.\n         *\n         * @param string $offset\n         * @return void\n         * @static\n         */        public static function offsetUnset($offset)\n        {\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        $instance->offsetUnset($offset);\n        }\n\n        /**\n         * Sets the parameters for this request.\n         *\n         * This method also re-initializes all properties.\n         *\n         * @param array $query The GET parameters\n         * @param array $request The POST parameters\n         * @param array $attributes The request attributes (parameters parsed from the PATH_INFO, ...)\n         * @param array $cookies The COOKIE parameters\n         * @param array $files The FILES parameters\n         * @param array $server The SERVER parameters\n         * @param string|resource|null $content The raw body data\n         * @static\n         */        public static function initialize($query = [], $request = [], $attributes = [], $cookies = [], $files = [], $server = [], $content = null)\n        {\n            //Method inherited from \\Symfony\\Component\\HttpFoundation\\Request\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->initialize($query, $request, $attributes, $cookies, $files, $server, $content);\n        }\n\n        /**\n         * Creates a new request with values from PHP\'s super globals.\n         *\n         * @return static\n         * @static\n         */        public static function createFromGlobals()\n        {\n            //Method inherited from \\Symfony\\Component\\HttpFoundation\\Request\n                        return \\Illuminate\\Http\\Request::createFromGlobals();\n        }\n\n        /**\n         * Creates a Request based on a given URI and configuration.\n         *\n         * The information contained in the URI always take precedence\n         * over the other information (server and parameters).\n         *\n         * @param string $uri The URI\n         * @param string $method The HTTP method\n         * @param array $parameters The query (GET) or request (POST) parameters\n         * @param array $cookies The request cookies ($_COOKIE)\n         * @param array $files The request files ($_FILES)\n         * @param array $server The server parameters ($_SERVER)\n         * @param string|resource|null $content The raw body data\n         * @return static\n         * @static\n         */        public static function create($uri, $method = \'GET\', $parameters = [], $cookies = [], $files = [], $server = [], $content = null)\n        {\n            //Method inherited from \\Symfony\\Component\\HttpFoundation\\Request\n                        return \\Illuminate\\Http\\Request::create($uri, $method, $parameters, $cookies, $files, $server, $content);\n        }\n\n        /**\n         * Sets a callable able to create a Request instance.\n         *\n         * This is mainly useful when you need to override the Request class\n         * to keep BC with an existing system. It should not be used for any\n         * other purpose.\n         *\n         * @static\n         */        public static function setFactory($callable)\n        {\n            //Method inherited from \\Symfony\\Component\\HttpFoundation\\Request\n                        return \\Illuminate\\Http\\Request::setFactory($callable);\n        }\n\n        /**\n         * Overrides the PHP global variables according to this request instance.\n         *\n         * It overrides $_GET, $_POST, $_REQUEST, $_SERVER, $_COOKIE.\n         * $_FILES is never overridden, see rfc1867\n         *\n         * @static\n         */        public static function overrideGlobals()\n        {\n            //Method inherited from \\Symfony\\Component\\HttpFoundation\\Request\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->overrideGlobals();\n        }\n\n        /**\n         * Sets a list of trusted proxies.\n         *\n         * You should only list the reverse proxies that you manage directly.\n         *\n         * @param array $proxies A list of trusted proxies, the string \'REMOTE_ADDR\' will be replaced with $_SERVER[\'REMOTE_ADDR\']\n         * @param int $trustedHeaderSet A bit field of Request::HEADER_*, to set which headers to trust from your proxies\n         * @throws \\InvalidArgumentException When $trustedHeaderSet is invalid\n         * @static\n         */        public static function setTrustedProxies($proxies, $trustedHeaderSet)\n        {\n            //Method inherited from \\Symfony\\Component\\HttpFoundation\\Request\n                        return \\Illuminate\\Http\\Request::setTrustedProxies($proxies, $trustedHeaderSet);\n        }\n\n        /**\n         * Gets the list of trusted proxies.\n         *\n         * @return array An array of trusted proxies\n         * @static\n         */        public static function getTrustedProxies()\n        {\n            //Method inherited from \\Symfony\\Component\\HttpFoundation\\Request\n                        return \\Illuminate\\Http\\Request::getTrustedProxies();\n        }\n\n        /**\n         * Gets the set of trusted headers from trusted proxies.\n         *\n         * @return int A bit field of Request::HEADER_* that defines which headers are trusted from your proxies\n         * @static\n         */        public static function getTrustedHeaderSet()\n        {\n            //Method inherited from \\Symfony\\Component\\HttpFoundation\\Request\n                        return \\Illuminate\\Http\\Request::getTrustedHeaderSet();\n        }\n\n        /**\n         * Sets a list of trusted host patterns.\n         *\n         * You should only list the hosts you manage using regexs.\n         *\n         * @param array $hostPatterns A list of trusted host patterns\n         * @static\n         */        public static function setTrustedHosts($hostPatterns)\n        {\n            //Method inherited from \\Symfony\\Component\\HttpFoundation\\Request\n                        return \\Illuminate\\Http\\Request::setTrustedHosts($hostPatterns);\n        }\n\n        /**\n         * Gets the list of trusted host patterns.\n         *\n         * @return array An array of trusted host patterns\n         * @static\n         */        public static function getTrustedHosts()\n        {\n            //Method inherited from \\Symfony\\Component\\HttpFoundation\\Request\n                        return \\Illuminate\\Http\\Request::getTrustedHosts();\n        }\n\n        /**\n         * Normalizes a query string.\n         *\n         * It builds a normalized query string, where keys/value pairs are alphabetized,\n         * have consistent escaping and unneeded delimiters are removed.\n         *\n         * @return string A normalized query string for the Request\n         * @static\n         */        public static function normalizeQueryString($qs)\n        {\n            //Method inherited from \\Symfony\\Component\\HttpFoundation\\Request\n                        return \\Illuminate\\Http\\Request::normalizeQueryString($qs);\n        }\n\n        /**\n         * Enables support for the _method request parameter to determine the intended HTTP method.\n         *\n         * Be warned that enabling this feature might lead to CSRF issues in your code.\n         * Check that you are using CSRF tokens when required.\n         * If the HTTP method parameter override is enabled, an html-form with method "POST" can be altered\n         * and used to send a "PUT" or "DELETE" request via the _method request parameter.\n         * If these methods are not protected against CSRF, this presents a possible vulnerability.\n         *\n         * The HTTP method can only be overridden when the real HTTP method is POST.\n         *\n         * @static\n         */        public static function enableHttpMethodParameterOverride()\n        {\n            //Method inherited from \\Symfony\\Component\\HttpFoundation\\Request\n                        return \\Illuminate\\Http\\Request::enableHttpMethodParameterOverride();\n        }\n\n        /**\n         * Checks whether support for the _method request parameter is enabled.\n         *\n         * @return bool True when the _method request parameter is enabled, false otherwise\n         * @static\n         */        public static function getHttpMethodParameterOverride()\n        {\n            //Method inherited from \\Symfony\\Component\\HttpFoundation\\Request\n                        return \\Illuminate\\Http\\Request::getHttpMethodParameterOverride();\n        }\n\n        /**\n         * Whether the request contains a Session which was started in one of the\n         * previous requests.\n         *\n         * @return bool\n         * @static\n         */        public static function hasPreviousSession()\n        {\n            //Method inherited from \\Symfony\\Component\\HttpFoundation\\Request\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->hasPreviousSession();\n        }\n\n        /**\n         * Whether the request contains a Session object.\n         *\n         * This method does not give any information about the state of the session object,\n         * like whether the session is started or not. It is just a way to check if this Request\n         * is associated with a Session instance.\n         *\n         * @return bool true when the Request contains a Session object, false otherwise\n         * @static\n         */        public static function hasSession()\n        {\n            //Method inherited from \\Symfony\\Component\\HttpFoundation\\Request\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->hasSession();\n        }\n\n        /**\n         *\n         *\n         * @static\n         */        public static function setSession($session)\n        {\n            //Method inherited from \\Symfony\\Component\\HttpFoundation\\Request\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->setSession($session);\n        }\n\n        /**\n         *\n         *\n         * @internal\n         * @static\n         */        public static function setSessionFactory($factory)\n        {\n            //Method inherited from \\Symfony\\Component\\HttpFoundation\\Request\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->setSessionFactory($factory);\n        }\n\n        /**\n         * Returns the client IP addresses.\n         *\n         * In the returned array the most trusted IP address is first, and the\n         * least trusted one last. The "real" client IP address is the last one,\n         * but this is also the least trusted one. Trusted proxies are stripped.\n         *\n         * Use this method carefully; you should use getClientIp() instead.\n         *\n         * @return array The client IP addresses\n         * @see getClientIp()\n         * @static\n         */        public static function getClientIps()\n        {\n            //Method inherited from \\Symfony\\Component\\HttpFoundation\\Request\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->getClientIps();\n        }\n\n        /**\n         * Returns the client IP address.\n         *\n         * This method can read the client IP address from the "X-Forwarded-For" header\n         * when trusted proxies were set via "setTrustedProxies()". The "X-Forwarded-For"\n         * header value is a comma+space separated list of IP addresses, the left-most\n         * being the original client, and each successive proxy that passed the request\n         * adding the IP address where it received the request from.\n         *\n         * If your reverse proxy uses a different header name than "X-Forwarded-For",\n         * ("Client-Ip" for instance), configure it via the $trustedHeaderSet\n         * argument of the Request::setTrustedProxies() method instead.\n         *\n         * @return string|null The client IP address\n         * @see getClientIps()\n         * @see https://wikipedia.org/wiki/X-Forwarded-For\n         * @static\n         */        public static function getClientIp()\n        {\n            //Method inherited from \\Symfony\\Component\\HttpFoundation\\Request\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->getClientIp();\n        }\n\n        /**\n         * Returns current script name.\n         *\n         * @return string\n         * @static\n         */        public static function getScriptName()\n        {\n            //Method inherited from \\Symfony\\Component\\HttpFoundation\\Request\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->getScriptName();\n        }\n\n        /**\n         * Returns the path being requested relative to the executed script.\n         *\n         * The path info always starts with a /.\n         *\n         * Suppose this request is instantiated from /mysite on localhost:\n         *\n         *  * http://localhost/mysite              returns an empty string\n         *  * http://localhost/mysite/about        returns \'/about\'\n         *  * http://localhost/mysite/enco%20ded   returns \'/enco%20ded\'\n         *  * http://localhost/mysite/about?var=1  returns \'/about\'\n         *\n         * @return string The raw path (i.e. not urldecoded)\n         * @static\n         */        public static function getPathInfo()\n        {\n            //Method inherited from \\Symfony\\Component\\HttpFoundation\\Request\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->getPathInfo();\n        }\n\n        /**\n         * Returns the root path from which this request is executed.\n         *\n         * Suppose that an index.php file instantiates this request object:\n         *\n         *  * http://localhost/index.php         returns an empty string\n         *  * http://localhost/index.php/page    returns an empty string\n         *  * http://localhost/web/index.php     returns \'/web\'\n         *  * http://localhost/we%20b/index.php  returns \'/we%20b\'\n         *\n         * @return string The raw path (i.e. not urldecoded)\n         * @static\n         */        public static function getBasePath()\n        {\n            //Method inherited from \\Symfony\\Component\\HttpFoundation\\Request\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->getBasePath();\n        }\n\n        /**\n         * Returns the root URL from which this request is executed.\n         *\n         * The base URL never ends with a /.\n         *\n         * This is similar to getBasePath(), except that it also includes the\n         * script filename (e.g. index.php) if one exists.\n         *\n         * @return string The raw URL (i.e. not urldecoded)\n         * @static\n         */        public static function getBaseUrl()\n        {\n            //Method inherited from \\Symfony\\Component\\HttpFoundation\\Request\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->getBaseUrl();\n        }\n\n        /**\n         * Gets the request\'s scheme.\n         *\n         * @return string\n         * @static\n         */        public static function getScheme()\n        {\n            //Method inherited from \\Symfony\\Component\\HttpFoundation\\Request\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->getScheme();\n        }\n\n        /**\n         * Returns the port on which the request is made.\n         *\n         * This method can read the client port from the "X-Forwarded-Port" header\n         * when trusted proxies were set via "setTrustedProxies()".\n         *\n         * The "X-Forwarded-Port" header must contain the client port.\n         *\n         * @return int|string can be a string if fetched from the server bag\n         * @static\n         */        public static function getPort()\n        {\n            //Method inherited from \\Symfony\\Component\\HttpFoundation\\Request\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->getPort();\n        }\n\n        /**\n         * Returns the user.\n         *\n         * @return string|null\n         * @static\n         */        public static function getUser()\n        {\n            //Method inherited from \\Symfony\\Component\\HttpFoundation\\Request\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->getUser();\n        }\n\n        /**\n         * Returns the password.\n         *\n         * @return string|null\n         * @static\n         */        public static function getPassword()\n        {\n            //Method inherited from \\Symfony\\Component\\HttpFoundation\\Request\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->getPassword();\n        }\n\n        /**\n         * Gets the user info.\n         *\n         * @return string A user name and, optionally, scheme-specific information about how to gain authorization to access the server\n         * @static\n         */        public static function getUserInfo()\n        {\n            //Method inherited from \\Symfony\\Component\\HttpFoundation\\Request\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->getUserInfo();\n        }\n\n        /**\n         * Returns the HTTP host being requested.\n         *\n         * The port name will be appended to the host if it\'s non-standard.\n         *\n         * @return string\n         * @static\n         */        public static function getHttpHost()\n        {\n            //Method inherited from \\Symfony\\Component\\HttpFoundation\\Request\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->getHttpHost();\n        }\n\n        /**\n         * Returns the requested URI (path and query string).\n         *\n         * @return string The raw URI (i.e. not URI decoded)\n         * @static\n         */        public static function getRequestUri()\n        {\n            //Method inherited from \\Symfony\\Component\\HttpFoundation\\Request\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->getRequestUri();\n        }\n\n        /**\n         * Gets the scheme and HTTP host.\n         *\n         * If the URL was called with basic authentication, the user\n         * and the password are not added to the generated string.\n         *\n         * @return string The scheme and HTTP host\n         * @static\n         */        public static function getSchemeAndHttpHost()\n        {\n            //Method inherited from \\Symfony\\Component\\HttpFoundation\\Request\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->getSchemeAndHttpHost();\n        }\n\n        /**\n         * Generates a normalized URI (URL) for the Request.\n         *\n         * @return string A normalized URI (URL) for the Request\n         * @see getQueryString()\n         * @static\n         */        public static function getUri()\n        {\n            //Method inherited from \\Symfony\\Component\\HttpFoundation\\Request\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->getUri();\n        }\n\n        /**\n         * Generates a normalized URI for the given path.\n         *\n         * @param string $path A path to use instead of the current one\n         * @return string The normalized URI for the path\n         * @static\n         */        public static function getUriForPath($path)\n        {\n            //Method inherited from \\Symfony\\Component\\HttpFoundation\\Request\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->getUriForPath($path);\n        }\n\n        /**\n         * Returns the path as relative reference from the current Request path.\n         *\n         * Only the URIs path component (no schema, host etc.) is relevant and must be given.\n         * Both paths must be absolute and not contain relative parts.\n         * Relative URLs from one resource to another are useful when generating self-contained downloadable document archives.\n         * Furthermore, they can be used to reduce the link size in documents.\n         *\n         * Example target paths, given a base path of "/a/b/c/d":\n         * - "/a/b/c/d"     -> ""\n         * - "/a/b/c/"      -> "./"\n         * - "/a/b/"        -> "../"\n         * - "/a/b/c/other" -> "other"\n         * - "/a/x/y"       -> "../../x/y"\n         *\n         * @return string The relative target path\n         * @static\n         */        public static function getRelativeUriForPath($path)\n        {\n            //Method inherited from \\Symfony\\Component\\HttpFoundation\\Request\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->getRelativeUriForPath($path);\n        }\n\n        /**\n         * Generates the normalized query string for the Request.\n         *\n         * It builds a normalized query string, where keys/value pairs are alphabetized\n         * and have consistent escaping.\n         *\n         * @return string|null A normalized query string for the Request\n         * @static\n         */        public static function getQueryString()\n        {\n            //Method inherited from \\Symfony\\Component\\HttpFoundation\\Request\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->getQueryString();\n        }\n\n        /**\n         * Checks whether the request is secure or not.\n         *\n         * This method can read the client protocol from the "X-Forwarded-Proto" header\n         * when trusted proxies were set via "setTrustedProxies()".\n         *\n         * The "X-Forwarded-Proto" header must contain the protocol: "https" or "http".\n         *\n         * @return bool\n         * @static\n         */        public static function isSecure()\n        {\n            //Method inherited from \\Symfony\\Component\\HttpFoundation\\Request\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->isSecure();\n        }\n\n        /**\n         * Returns the host name.\n         *\n         * This method can read the client host name from the "X-Forwarded-Host" header\n         * when trusted proxies were set via "setTrustedProxies()".\n         *\n         * The "X-Forwarded-Host" header must contain the client host name.\n         *\n         * @return string\n         * @throws SuspiciousOperationException when the host name is invalid or not trusted\n         * @static\n         */        public static function getHost()\n        {\n            //Method inherited from \\Symfony\\Component\\HttpFoundation\\Request\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->getHost();\n        }\n\n        /**\n         * Sets the request method.\n         *\n         * @static\n         */        public static function setMethod($method)\n        {\n            //Method inherited from \\Symfony\\Component\\HttpFoundation\\Request\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->setMethod($method);\n        }\n\n        /**\n         * Gets the request "intended" method.\n         *\n         * If the X-HTTP-Method-Override header is set, and if the method is a POST,\n         * then it is used to determine the "real" intended HTTP method.\n         *\n         * The _method request parameter can also be used to determine the HTTP method,\n         * but only if enableHttpMethodParameterOverride() has been called.\n         *\n         * The method is always an uppercased string.\n         *\n         * @return string The request method\n         * @see getRealMethod()\n         * @static\n         */        public static function getMethod()\n        {\n            //Method inherited from \\Symfony\\Component\\HttpFoundation\\Request\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->getMethod();\n        }\n\n        /**\n         * Gets the "real" request method.\n         *\n         * @return string The request method\n         * @see getMethod()\n         * @static\n         */        public static function getRealMethod()\n        {\n            //Method inherited from \\Symfony\\Component\\HttpFoundation\\Request\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->getRealMethod();\n        }\n\n        /**\n         * Gets the mime type associated with the format.\n         *\n         * @return string|null The associated mime type (null if not found)\n         * @static\n         */        public static function getMimeType($format)\n        {\n            //Method inherited from \\Symfony\\Component\\HttpFoundation\\Request\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->getMimeType($format);\n        }\n\n        /**\n         * Gets the mime types associated with the format.\n         *\n         * @return array The associated mime types\n         * @static\n         */        public static function getMimeTypes($format)\n        {\n            //Method inherited from \\Symfony\\Component\\HttpFoundation\\Request\n                        return \\Illuminate\\Http\\Request::getMimeTypes($format);\n        }\n\n        /**\n         * Gets the format associated with the mime type.\n         *\n         * @return string|null The format (null if not found)\n         * @static\n         */        public static function getFormat($mimeType)\n        {\n            //Method inherited from \\Symfony\\Component\\HttpFoundation\\Request\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->getFormat($mimeType);\n        }\n\n        /**\n         * Associates a format with mime types.\n         *\n         * @param string|array $mimeTypes The associated mime types (the preferred one must be the first as it will be used as the content type)\n         * @static\n         */        public static function setFormat($format, $mimeTypes)\n        {\n            //Method inherited from \\Symfony\\Component\\HttpFoundation\\Request\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->setFormat($format, $mimeTypes);\n        }\n\n        /**\n         * Gets the request format.\n         *\n         * Here is the process to determine the format:\n         *\n         *  * format defined by the user (with setRequestFormat())\n         *  * _format request attribute\n         *  * $default\n         *\n         * @see getPreferredFormat\n         * @return string|null The request format\n         * @static\n         */        public static function getRequestFormat($default = \'html\')\n        {\n            //Method inherited from \\Symfony\\Component\\HttpFoundation\\Request\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->getRequestFormat($default);\n        }\n\n        /**\n         * Sets the request format.\n         *\n         * @static\n         */        public static function setRequestFormat($format)\n        {\n            //Method inherited from \\Symfony\\Component\\HttpFoundation\\Request\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->setRequestFormat($format);\n        }\n\n        /**\n         * Gets the format associated with the request.\n         *\n         * @return string|null The format (null if no content type is present)\n         * @static\n         */        public static function getContentType()\n        {\n            //Method inherited from \\Symfony\\Component\\HttpFoundation\\Request\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->getContentType();\n        }\n\n        /**\n         * Sets the default locale.\n         *\n         * @static\n         */        public static function setDefaultLocale($locale)\n        {\n            //Method inherited from \\Symfony\\Component\\HttpFoundation\\Request\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->setDefaultLocale($locale);\n        }\n\n        /**\n         * Get the default locale.\n         *\n         * @return string\n         * @static\n         */        public static function getDefaultLocale()\n        {\n            //Method inherited from \\Symfony\\Component\\HttpFoundation\\Request\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->getDefaultLocale();\n        }\n\n        /**\n         * Sets the locale.\n         *\n         * @static\n         */        public static function setLocale($locale)\n        {\n            //Method inherited from \\Symfony\\Component\\HttpFoundation\\Request\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->setLocale($locale);\n        }\n\n        /**\n         * Get the locale.\n         *\n         * @return string\n         * @static\n         */        public static function getLocale()\n        {\n            //Method inherited from \\Symfony\\Component\\HttpFoundation\\Request\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->getLocale();\n        }\n\n        /**\n         * Checks if the request method is of specified type.\n         *\n         * @param string $method Uppercase request method (GET, POST etc)\n         * @return bool\n         * @static\n         */        public static function isMethod($method)\n        {\n            //Method inherited from \\Symfony\\Component\\HttpFoundation\\Request\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->isMethod($method);\n        }\n\n        /**\n         * Checks whether or not the method is safe.\n         *\n         * @see https://tools.ietf.org/html/rfc7231#section-4.2.1\n         * @return bool\n         * @static\n         */        public static function isMethodSafe()\n        {\n            //Method inherited from \\Symfony\\Component\\HttpFoundation\\Request\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->isMethodSafe();\n        }\n\n        /**\n         * Checks whether or not the method is idempotent.\n         *\n         * @return bool\n         * @static\n         */        public static function isMethodIdempotent()\n        {\n            //Method inherited from \\Symfony\\Component\\HttpFoundation\\Request\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->isMethodIdempotent();\n        }\n\n        /**\n         * Checks whether the method is cacheable or not.\n         *\n         * @see https://tools.ietf.org/html/rfc7231#section-4.2.3\n         * @return bool True for GET and HEAD, false otherwise\n         * @static\n         */        public static function isMethodCacheable()\n        {\n            //Method inherited from \\Symfony\\Component\\HttpFoundation\\Request\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->isMethodCacheable();\n        }\n\n        /**\n         * Returns the protocol version.\n         *\n         * If the application is behind a proxy, the protocol version used in the\n         * requests between the client and the proxy and between the proxy and the\n         * server might be different. This returns the former (from the "Via" header)\n         * if the proxy is trusted (see "setTrustedProxies()"), otherwise it returns\n         * the latter (from the "SERVER_PROTOCOL" server parameter).\n         *\n         * @return string\n         * @static\n         */        public static function getProtocolVersion()\n        {\n            //Method inherited from \\Symfony\\Component\\HttpFoundation\\Request\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->getProtocolVersion();\n        }\n\n        /**\n         * Returns the request body content.\n         *\n         * @param bool $asResource If true, a resource will be returned\n         * @return string|resource The request body content or a resource to read the body stream\n         * @throws \\LogicException\n         * @static\n         */        public static function getContent($asResource = false)\n        {\n            //Method inherited from \\Symfony\\Component\\HttpFoundation\\Request\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->getContent($asResource);\n        }\n\n        /**\n         * Gets the Etags.\n         *\n         * @return array The entity tags\n         * @static\n         */        public static function getETags()\n        {\n            //Method inherited from \\Symfony\\Component\\HttpFoundation\\Request\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->getETags();\n        }\n\n        /**\n         *\n         *\n         * @return bool\n         * @static\n         */        public static function isNoCache()\n        {\n            //Method inherited from \\Symfony\\Component\\HttpFoundation\\Request\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->isNoCache();\n        }\n\n        /**\n         * Gets the preferred format for the response by inspecting, in the following order:\n         *   * the request format set using setRequestFormat\n         *   * the values of the Accept HTTP header\n         *\n         * Note that if you use this method, you should send the "Vary: Accept" header\n         * in the response to prevent any issues with intermediary HTTP caches.\n         *\n         * @static\n         */        public static function getPreferredFormat($default = \'html\')\n        {\n            //Method inherited from \\Symfony\\Component\\HttpFoundation\\Request\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->getPreferredFormat($default);\n        }\n\n        /**\n         * Returns the preferred language.\n         *\n         * @param string[] $locales An array of ordered available locales\n         * @return string|null The preferred locale\n         * @static\n         */        public static function getPreferredLanguage($locales = null)\n        {\n            //Method inherited from \\Symfony\\Component\\HttpFoundation\\Request\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->getPreferredLanguage($locales);\n        }\n\n        /**\n         * Gets a list of languages acceptable by the client browser.\n         *\n         * @return array Languages ordered in the user browser preferences\n         * @static\n         */        public static function getLanguages()\n        {\n            //Method inherited from \\Symfony\\Component\\HttpFoundation\\Request\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->getLanguages();\n        }\n\n        /**\n         * Gets a list of charsets acceptable by the client browser.\n         *\n         * @return array List of charsets in preferable order\n         * @static\n         */        public static function getCharsets()\n        {\n            //Method inherited from \\Symfony\\Component\\HttpFoundation\\Request\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->getCharsets();\n        }\n\n        /**\n         * Gets a list of encodings acceptable by the client browser.\n         *\n         * @return array List of encodings in preferable order\n         * @static\n         */        public static function getEncodings()\n        {\n            //Method inherited from \\Symfony\\Component\\HttpFoundation\\Request\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->getEncodings();\n        }\n\n        /**\n         * Gets a list of content types acceptable by the client browser.\n         *\n         * @return array List of content types in preferable order\n         * @static\n         */        public static function getAcceptableContentTypes()\n        {\n            //Method inherited from \\Symfony\\Component\\HttpFoundation\\Request\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->getAcceptableContentTypes();\n        }\n\n        /**\n         * Returns true if the request is a XMLHttpRequest.\n         *\n         * It works if your JavaScript library sets an X-Requested-With HTTP header.\n         * It is known to work with common JavaScript frameworks:\n         *\n         * @see https://wikipedia.org/wiki/List_of_Ajax_frameworks#JavaScript\n         * @return bool true if the request is an XMLHttpRequest, false otherwise\n         * @static\n         */        public static function isXmlHttpRequest()\n        {\n            //Method inherited from \\Symfony\\Component\\HttpFoundation\\Request\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->isXmlHttpRequest();\n        }\n\n        /**\n         * Indicates whether this request originated from a trusted proxy.\n         *\n         * This can be useful to determine whether or not to trust the\n         * contents of a proxy-specific header.\n         *\n         * @return bool true if the request came from a trusted proxy, false otherwise\n         * @static\n         */        public static function isFromTrustedProxy()\n        {\n            //Method inherited from \\Symfony\\Component\\HttpFoundation\\Request\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->isFromTrustedProxy();\n        }\n\n        /**\n         * Determine if the given content types match.\n         *\n         * @param string $actual\n         * @param string $type\n         * @return bool\n         * @static\n         */        public static function matchesType($actual, $type)\n        {\n                        return \\Illuminate\\Http\\Request::matchesType($actual, $type);\n        }\n\n        /**\n         * Determine if the request is sending JSON.\n         *\n         * @return bool\n         * @static\n         */        public static function isJson()\n        {\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->isJson();\n        }\n\n        /**\n         * Determine if the current request probably expects a JSON response.\n         *\n         * @return bool\n         * @static\n         */        public static function expectsJson()\n        {\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->expectsJson();\n        }\n\n        /**\n         * Determine if the current request is asking for JSON.\n         *\n         * @return bool\n         * @static\n         */        public static function wantsJson()\n        {\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->wantsJson();\n        }\n\n        /**\n         * Determines whether the current requests accepts a given content type.\n         *\n         * @param string|array $contentTypes\n         * @return bool\n         * @static\n         */        public static function accepts($contentTypes)\n        {\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->accepts($contentTypes);\n        }\n\n        /**\n         * Return the most suitable content type from the given array based on content negotiation.\n         *\n         * @param string|array $contentTypes\n         * @return string|null\n         * @static\n         */        public static function prefers($contentTypes)\n        {\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->prefers($contentTypes);\n        }\n\n        /**\n         * Determine if the current request accepts any content type.\n         *\n         * @return bool\n         * @static\n         */        public static function acceptsAnyContentType()\n        {\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->acceptsAnyContentType();\n        }\n\n        /**\n         * Determines whether a request accepts JSON.\n         *\n         * @return bool\n         * @static\n         */        public static function acceptsJson()\n        {\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->acceptsJson();\n        }\n\n        /**\n         * Determines whether a request accepts HTML.\n         *\n         * @return bool\n         * @static\n         */        public static function acceptsHtml()\n        {\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->acceptsHtml();\n        }\n\n        /**\n         * Get the data format expected in the response.\n         *\n         * @param string $default\n         * @return string\n         * @static\n         */        public static function format($default = \'html\')\n        {\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->format($default);\n        }\n\n        /**\n         * Retrieve an old input item.\n         *\n         * @param string|null $key\n         * @param string|array|null $default\n         * @return string|array\n         * @static\n         */        public static function old($key = null, $default = null)\n        {\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->old($key, $default);\n        }\n\n        /**\n         * Flash the input for the current request to the session.\n         *\n         * @return void\n         * @static\n         */        public static function flash()\n        {\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        $instance->flash();\n        }\n\n        /**\n         * Flash only some of the input to the session.\n         *\n         * @param array|mixed $keys\n         * @return void\n         * @static\n         */        public static function flashOnly($keys)\n        {\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        $instance->flashOnly($keys);\n        }\n\n        /**\n         * Flash only some of the input to the session.\n         *\n         * @param array|mixed $keys\n         * @return void\n         * @static\n         */        public static function flashExcept($keys)\n        {\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        $instance->flashExcept($keys);\n        }\n\n        /**\n         * Flush all of the old input from the session.\n         *\n         * @return void\n         * @static\n         */        public static function flush()\n        {\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        $instance->flush();\n        }\n\n        /**\n         * Retrieve a server variable from the request.\n         *\n         * @param string|null $key\n         * @param string|array|null $default\n         * @return string|array|null\n         * @static\n         */        public static function server($key = null, $default = null)\n        {\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->server($key, $default);\n        }\n\n        /**\n         * Determine if a header is set on the request.\n         *\n         * @param string $key\n         * @return bool\n         * @static\n         */        public static function hasHeader($key)\n        {\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->hasHeader($key);\n        }\n\n        /**\n         * Retrieve a header from the request.\n         *\n         * @param string|null $key\n         * @param string|array|null $default\n         * @return string|array|null\n         * @static\n         */        public static function header($key = null, $default = null)\n        {\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->header($key, $default);\n        }\n\n        /**\n         * Get the bearer token from the request headers.\n         *\n         * @return string|null\n         * @static\n         */        public static function bearerToken()\n        {\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->bearerToken();\n        }\n\n        /**\n         * Determine if the request contains a given input item key.\n         *\n         * @param string|array $key\n         * @return bool\n         * @static\n         */        public static function exists($key)\n        {\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->exists($key);\n        }\n\n        /**\n         * Determine if the request contains a given input item key.\n         *\n         * @param string|array $key\n         * @return bool\n         * @static\n         */        public static function has($key)\n        {\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->has($key);\n        }\n\n        /**\n         * Determine if the request contains any of the given inputs.\n         *\n         * @param string|array $keys\n         * @return bool\n         * @static\n         */        public static function hasAny($keys)\n        {\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->hasAny($keys);\n        }\n\n        /**\n         * Determine if the request contains a non-empty value for an input item.\n         *\n         * @param string|array $key\n         * @return bool\n         * @static\n         */        public static function filled($key)\n        {\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->filled($key);\n        }\n\n        /**\n         * Determine if the request contains a non-empty value for any of the given inputs.\n         *\n         * @param string|array $keys\n         * @return bool\n         * @static\n         */        public static function anyFilled($keys)\n        {\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->anyFilled($keys);\n        }\n\n        /**\n         * Determine if the request is missing a given input item key.\n         *\n         * @param string|array $key\n         * @return bool\n         * @static\n         */        public static function missing($key)\n        {\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->missing($key);\n        }\n\n        /**\n         * Get the keys for all of the input and files.\n         *\n         * @return array\n         * @static\n         */        public static function keys()\n        {\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->keys();\n        }\n\n        /**\n         * Get all of the input and files for the request.\n         *\n         * @param array|mixed|null $keys\n         * @return array\n         * @static\n         */        public static function all($keys = null)\n        {\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->all($keys);\n        }\n\n        /**\n         * Retrieve an input item from the request.\n         *\n         * @param string|null $key\n         * @param mixed $default\n         * @return mixed\n         * @static\n         */        public static function input($key = null, $default = null)\n        {\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->input($key, $default);\n        }\n\n        /**\n         * Retrieve input as a boolean value.\n         *\n         * Returns true when value is "1", "true", "on", and "yes". Otherwise, returns false.\n         *\n         * @param string|null $key\n         * @param bool $default\n         * @return bool\n         * @static\n         */        public static function boolean($key = null, $default = false)\n        {\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->boolean($key, $default);\n        }\n\n        /**\n         * Get a subset containing the provided keys with values from the input data.\n         *\n         * @param array|mixed $keys\n         * @return array\n         * @static\n         */        public static function only($keys)\n        {\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->only($keys);\n        }\n\n        /**\n         * Get all of the input except for a specified array of items.\n         *\n         * @param array|mixed $keys\n         * @return array\n         * @static\n         */        public static function except($keys)\n        {\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->except($keys);\n        }\n\n        /**\n         * Retrieve a query string item from the request.\n         *\n         * @param string|null $key\n         * @param string|array|null $default\n         * @return string|array|null\n         * @static\n         */        public static function query($key = null, $default = null)\n        {\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->query($key, $default);\n        }\n\n        /**\n         * Retrieve a request payload item from the request.\n         *\n         * @param string|null $key\n         * @param string|array|null $default\n         * @return string|array|null\n         * @static\n         */        public static function post($key = null, $default = null)\n        {\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->post($key, $default);\n        }\n\n        /**\n         * Determine if a cookie is set on the request.\n         *\n         * @param string $key\n         * @return bool\n         * @static\n         */        public static function hasCookie($key)\n        {\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->hasCookie($key);\n        }\n\n        /**\n         * Retrieve a cookie from the request.\n         *\n         * @param string|null $key\n         * @param string|array|null $default\n         * @return string|array|null\n         * @static\n         */        public static function cookie($key = null, $default = null)\n        {\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->cookie($key, $default);\n        }\n\n        /**\n         * Get an array of all of the files on the request.\n         *\n         * @return array\n         * @static\n         */        public static function allFiles()\n        {\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->allFiles();\n        }\n\n        /**\n         * Determine if the uploaded data contains a file.\n         *\n         * @param string $key\n         * @return bool\n         * @static\n         */        public static function hasFile($key)\n        {\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->hasFile($key);\n        }\n\n        /**\n         * Retrieve a file from the request.\n         *\n         * @param string|null $key\n         * @param mixed $default\n         * @return \\Illuminate\\Http\\UploadedFile|\\Illuminate\\Http\\UploadedFile[]|array|null\n         * @static\n         */        public static function file($key = null, $default = null)\n        {\n                        /** @var \\Illuminate\\Http\\Request $instance */\n                        return $instance->file($key, $default);\n        }\n\n        /**\n         * Register a custom macro.\n         *\n         * @param string $name\n         * @param object|callable $macro\n         * @return void\n         * @static\n         */        public static function macro($name, $macro)\n        {\n                        \\Illuminate\\Http\\Request::macro($name, $macro);\n        }\n\n        /**\n         * Mix another object into the class.\n         *\n         * @param object $mixin\n         * @param bool $replace\n         * @return void\n         * @throws \\ReflectionException\n         * @static\n         */        public static function mixin($mixin, $replace = true)\n        {\n                        \\Illuminate\\Http\\Request::mixin($mixin, $replace);\n        }\n\n        /**\n         * Checks if macro is registered.\n         *\n         * @param string $name\n         * @return bool\n         * @static\n         */        public static function hasMacro($name)\n        {\n                        return \\Illuminate\\Http\\Request::hasMacro($name);\n        }\n\n        /**\n         *\n         *\n         * @static\n         */        public static function validate($rules, ...$params)\n        {\n                        return \\Illuminate\\Http\\Request::validate($rules, ...$params);\n        }\n\n        /**\n         *\n         *\n         * @static\n         */        public static function validateWithBag($errorBag, $rules, ...$params)\n        {\n                        return \\Illuminate\\Http\\Request::validateWithBag($errorBag, $rules, ...$params);\n        }\n\n        /**\n         *\n         *\n         * @static\n         */        public static function hasValidSignature($absolute = true)\n        {\n                        return \\Illuminate\\Http\\Request::hasValidSignature($absolute);\n        }\n            }\n\n    /**\n     *\n     *\n     * @see \\Illuminate\\Contracts\\Routing\\ResponseFactory\n     */    class Response {\n\n        /**\n         * Create a new response instance.\n         *\n         * @param string $content\n         * @param int $status\n         * @param array $headers\n         * @return \\Illuminate\\Http\\Response\n         * @static\n         */        public static function make($content = \'\', $status = 200, $headers = [])\n        {\n                        /** @var \\Illuminate\\Routing\\ResponseFactory $instance */\n                        return $instance->make($content, $status, $headers);\n        }\n\n        /**\n         * Create a new "no content" response.\n         *\n         * @param int $status\n         * @param array $headers\n         * @return \\Illuminate\\Http\\Response\n         * @static\n         */        public static function noContent($status = 204, $headers = [])\n        {\n                        /** @var \\Illuminate\\Routing\\ResponseFactory $instance */\n                        return $instance->noContent($status, $headers);\n        }\n\n        /**\n         * Create a new response for a given view.\n         *\n         * @param string|array $view\n         * @param array $data\n         * @param int $status\n         * @param array $headers\n         * @return \\Illuminate\\Http\\Response\n         * @static\n         */        public static function view($view, $data = [], $status = 200, $headers = [])\n        {\n                        /** @var \\Illuminate\\Routing\\ResponseFactory $instance */\n                        return $instance->view($view, $data, $status, $headers);\n        }\n\n        /**\n         * Create a new JSON response instance.\n         *\n         * @param mixed $data\n         * @param int $status\n         * @param array $headers\n         * @param int $options\n         * @return \\Illuminate\\Http\\JsonResponse\n         * @static\n         */        public static function json($data = [], $status = 200, $headers = [], $options = 0)\n        {\n                        /** @var \\Illuminate\\Routing\\ResponseFactory $instance */\n                        return $instance->json($data, $status, $headers, $options);\n        }\n\n        /**\n         * Create a new JSONP response instance.\n         *\n         * @param string $callback\n         * @param mixed $data\n         * @param int $status\n         * @param array $headers\n         * @param int $options\n         * @return \\Illuminate\\Http\\JsonResponse\n         * @static\n         */        public static function jsonp($callback, $data = [], $status = 200, $headers = [], $options = 0)\n        {\n                        /** @var \\Illuminate\\Routing\\ResponseFactory $instance */\n                        return $instance->jsonp($callback, $data, $status, $headers, $options);\n        }\n\n        /**\n         * Create a new streamed response instance.\n         *\n         * @param \\Closure $callback\n         * @param int $status\n         * @param array $headers\n         * @return \\Symfony\\Component\\HttpFoundation\\StreamedResponse\n         * @static\n         */        public static function stream($callback, $status = 200, $headers = [])\n        {\n                        /** @var \\Illuminate\\Routing\\ResponseFactory $instance */\n                        return $instance->stream($callback, $status, $headers);\n        }\n\n        /**\n         * Create a new streamed response instance as a file download.\n         *\n         * @param \\Closure $callback\n         * @param string|null $name\n         * @param array $headers\n         * @param string|null $disposition\n         * @return \\Symfony\\Component\\HttpFoundation\\StreamedResponse\n         * @static\n         */        public static function streamDownload($callback, $name = null, $headers = [], $disposition = \'attachment\')\n        {\n                        /** @var \\Illuminate\\Routing\\ResponseFactory $instance */\n                        return $instance->streamDownload($callback, $name, $headers, $disposition);\n        }\n\n        /**\n         * Create a new file download response.\n         *\n         * @param \\SplFileInfo|string $file\n         * @param string|null $name\n         * @param array $headers\n         * @param string|null $disposition\n         * @return \\Symfony\\Component\\HttpFoundation\\BinaryFileResponse\n         * @static\n         */        public static function download($file, $name = null, $headers = [], $disposition = \'attachment\')\n        {\n                        /** @var \\Illuminate\\Routing\\ResponseFactory $instance */\n                        return $instance->download($file, $name, $headers, $disposition);\n        }\n\n        /**\n         * Return the raw contents of a binary file.\n         *\n         * @param \\SplFileInfo|string $file\n         * @param array $headers\n         * @return \\Symfony\\Component\\HttpFoundation\\BinaryFileResponse\n         * @static\n         */        public static function file($file, $headers = [])\n        {\n                        /** @var \\Illuminate\\Routing\\ResponseFactory $instance */\n                        return $instance->file($file, $headers);\n        }\n\n        /**\n         * Create a new redirect response to the given path.\n         *\n         * @param string $path\n         * @param int $status\n         * @param array $headers\n         * @param bool|null $secure\n         * @return \\Illuminate\\Http\\RedirectResponse\n         * @static\n         */        public static function redirectTo($path, $status = 302, $headers = [], $secure = null)\n        {\n                        /** @var \\Illuminate\\Routing\\ResponseFactory $instance */\n                        return $instance->redirectTo($path, $status, $headers, $secure);\n        }\n\n        /**\n         * Create a new redirect response to a named route.\n         *\n         * @param string $route\n         * @param mixed $parameters\n         * @param int $status\n         * @param array $headers\n         * @return \\Illuminate\\Http\\RedirectResponse\n         * @static\n         */        public static function redirectToRoute($route, $parameters = [], $status = 302, $headers = [])\n        {\n                        /** @var \\Illuminate\\Routing\\ResponseFactory $instance */\n                        return $instance->redirectToRoute($route, $parameters, $status, $headers);\n        }\n\n        /**\n         * Create a new redirect response to a controller action.\n         *\n         * @param string $action\n         * @param mixed $parameters\n         * @param int $status\n         * @param array $headers\n         * @return \\Illuminate\\Http\\RedirectResponse\n         * @static\n         */        public static function redirectToAction($action, $parameters = [], $status = 302, $headers = [])\n        {\n                        /** @var \\Illuminate\\Routing\\ResponseFactory $instance */\n                        return $instance->redirectToAction($action, $parameters, $status, $headers);\n        }\n\n        /**\n         * Create a new redirect response, while putting the current URL in the session.\n         *\n         * @param string $path\n         * @param int $status\n         * @param array $headers\n         * @param bool|null $secure\n         * @return \\Illuminate\\Http\\RedirectResponse\n         * @static\n         */        public static function redirectGuest($path, $status = 302, $headers = [], $secure = null)\n        {\n                        /** @var \\Illuminate\\Routing\\ResponseFactory $instance */\n                        return $instance->redirectGuest($path, $status, $headers, $secure);\n        }\n\n        /**\n         * Create a new redirect response to the previously intended location.\n         *\n         * @param string $default\n         * @param int $status\n         * @param array $headers\n         * @param bool|null $secure\n         * @return \\Illuminate\\Http\\RedirectResponse\n         * @static\n         */        public static function redirectToIntended($default = \'/\', $status = 302, $headers = [], $secure = null)\n        {\n                        /** @var \\Illuminate\\Routing\\ResponseFactory $instance */\n                        return $instance->redirectToIntended($default, $status, $headers, $secure);\n        }\n\n        /**\n         * Register a custom macro.\n         *\n         * @param string $name\n         * @param object|callable $macro\n         * @return void\n         * @static\n         */        public static function macro($name, $macro)\n        {\n                        \\Illuminate\\Routing\\ResponseFactory::macro($name, $macro);\n        }\n\n        /**\n         * Mix another object into the class.\n         *\n         * @param object $mixin\n         * @param bool $replace\n         * @return void\n         * @throws \\ReflectionException\n         * @static\n         */        public static function mixin($mixin, $replace = true)\n        {\n                        \\Illuminate\\Routing\\ResponseFactory::mixin($mixin, $replace);\n        }\n\n        /**\n         * Checks if macro is registered.\n         *\n         * @param string $name\n         * @return bool\n         * @static\n         */        public static function hasMacro($name)\n        {\n                        return \\Illuminate\\Routing\\ResponseFactory::hasMacro($name);\n        }\n            }\n\n    /**\n     *\n     *\n     * @method static \\Illuminate\\Routing\\RouteRegistrar prefix(string  $prefix)\n     * @method static \\Illuminate\\Routing\\RouteRegistrar where(array  $where)\n     * @method static \\Illuminate\\Routing\\RouteRegistrar middleware(array|string|null $middleware)\n     * @method static \\Illuminate\\Routing\\RouteRegistrar as(string $value)\n     * @method static \\Illuminate\\Routing\\RouteRegistrar domain(string $value)\n     * @method static \\Illuminate\\Routing\\RouteRegistrar name(string $value)\n     * @method static \\Illuminate\\Routing\\RouteRegistrar namespace(string $value)\n     * @see \\Illuminate\\Routing\\Router\n     */    class Route {\n\n        /**\n         * Register a new GET route with the router.\n         *\n         * @param string $uri\n         * @param array|string|callable|null $action\n         * @return \\Illuminate\\Routing\\Route\n         * @static\n         */        public static function get($uri, $action = null)\n        {\n                        /** @var \\Illuminate\\Routing\\Router $instance */\n                        return $instance->get($uri, $action);\n        }\n\n        /**\n         * Register a new POST route with the router.\n         *\n         * @param string $uri\n         * @param array|string|callable|null $action\n         * @return \\Illuminate\\Routing\\Route\n         * @static\n         */        public static function post($uri, $action = null)\n        {\n                        /** @var \\Illuminate\\Routing\\Router $instance */\n                        return $instance->post($uri, $action);\n        }\n\n        /**\n         * Register a new PUT route with the router.\n         *\n         * @param string $uri\n         * @param array|string|callable|null $action\n         * @return \\Illuminate\\Routing\\Route\n         * @static\n         */        public static function put($uri, $action = null)\n        {\n                        /** @var \\Illuminate\\Routing\\Router $instance */\n                        return $instance->put($uri, $action);\n        }\n\n        /**\n         * Register a new PATCH route with the router.\n         *\n         * @param string $uri\n         * @param array|string|callable|null $action\n         * @return \\Illuminate\\Routing\\Route\n         * @static\n         */        public static function patch($uri, $action = null)\n        {\n                        /** @var \\Illuminate\\Routing\\Router $instance */\n                        return $instance->patch($uri, $action);\n        }\n\n        /**\n         * Register a new DELETE route with the router.\n         *\n         * @param string $uri\n         * @param array|string|callable|null $action\n         * @return \\Illuminate\\Routing\\Route\n         * @static\n         */        public static function delete($uri, $action = null)\n        {\n                        /** @var \\Illuminate\\Routing\\Router $instance */\n                        return $instance->delete($uri, $action);\n        }\n\n        /**\n         * Register a new OPTIONS route with the router.\n         *\n         * @param string $uri\n         * @param array|string|callable|null $action\n         * @return \\Illuminate\\Routing\\Route\n         * @static\n         */        public static function options($uri, $action = null)\n        {\n                        /** @var \\Illuminate\\Routing\\Router $instance */\n                        return $instance->options($uri, $action);\n        }\n\n        /**\n         * Register a new route responding to all verbs.\n         *\n         * @param string $uri\n         * @param array|string|callable|null $action\n         * @return \\Illuminate\\Routing\\Route\n         * @static\n         */        public static function any($uri, $action = null)\n        {\n                        /** @var \\Illuminate\\Routing\\Router $instance */\n                        return $instance->any($uri, $action);\n        }\n\n        /**\n         * Register a new Fallback route with the router.\n         *\n         * @param array|string|callable|null $action\n         * @return \\Illuminate\\Routing\\Route\n         * @static\n         */        public static function fallback($action)\n        {\n                        /** @var \\Illuminate\\Routing\\Router $instance */\n                        return $instance->fallback($action);\n        }\n\n        /**\n         * Create a redirect from one URI to another.\n         *\n         * @param string $uri\n         * @param string $destination\n         * @param int $status\n         * @return \\Illuminate\\Routing\\Route\n         * @static\n         */        public static function redirect($uri, $destination, $status = 302)\n        {\n                        /** @var \\Illuminate\\Routing\\Router $instance */\n                        return $instance->redirect($uri, $destination, $status);\n        }\n\n        /**\n         * Create a permanent redirect from one URI to another.\n         *\n         * @param string $uri\n         * @param string $destination\n         * @return \\Illuminate\\Routing\\Route\n         * @static\n         */        public static function permanentRedirect($uri, $destination)\n        {\n                        /** @var \\Illuminate\\Routing\\Router $instance */\n                        return $instance->permanentRedirect($uri, $destination);\n        }\n\n        /**\n         * Register a new route that returns a view.\n         *\n         * @param string $uri\n         * @param string $view\n         * @param array $data\n         * @return \\Illuminate\\Routing\\Route\n         * @static\n         */        public static function view($uri, $view, $data = [])\n        {\n                        /** @var \\Illuminate\\Routing\\Router $instance */\n                        return $instance->view($uri, $view, $data);\n        }\n\n        /**\n         * Register a new route with the given verbs.\n         *\n         * @param array|string $methods\n         * @param string $uri\n         * @param array|string|callable|null $action\n         * @return \\Illuminate\\Routing\\Route\n         * @static\n         */        public static function match($methods, $uri, $action = null)\n        {\n                        /** @var \\Illuminate\\Routing\\Router $instance */\n                        return $instance->match($methods, $uri, $action);\n        }\n\n        /**\n         * Register an array of resource controllers.\n         *\n         * @param array $resources\n         * @param array $options\n         * @return void\n         * @static\n         */        public static function resources($resources, $options = [])\n        {\n                        /** @var \\Illuminate\\Routing\\Router $instance */\n                        $instance->resources($resources, $options);\n        }\n\n        /**\n         * Route a resource to a controller.\n         *\n         * @param string $name\n         * @param string $controller\n         * @param array $options\n         * @return \\Illuminate\\Routing\\PendingResourceRegistration\n         * @static\n         */        public static function resource($name, $controller, $options = [])\n        {\n                        /** @var \\Illuminate\\Routing\\Router $instance */\n                        return $instance->resource($name, $controller, $options);\n        }\n\n        /**\n         * Register an array of API resource controllers.\n         *\n         * @param array $resources\n         * @param array $options\n         * @return void\n         * @static\n         */        public static function apiResources($resources, $options = [])\n        {\n                        /** @var \\Illuminate\\Routing\\Router $instance */\n                        $instance->apiResources($resources, $options);\n        }\n\n        /**\n         * Route an API resource to a controller.\n         *\n         * @param string $name\n         * @param string $controller\n         * @param array $options\n         * @return \\Illuminate\\Routing\\PendingResourceRegistration\n         * @static\n         */        public static function apiResource($name, $controller, $options = [])\n        {\n                        /** @var \\Illuminate\\Routing\\Router $instance */\n                        return $instance->apiResource($name, $controller, $options);\n        }\n\n        /**\n         * Create a route group with shared attributes.\n         *\n         * @param array $attributes\n         * @param \\Closure|string $routes\n         * @return void\n         * @static\n         */        public static function group($attributes, $routes)\n        {\n                        /** @var \\Illuminate\\Routing\\Router $instance */\n                        $instance->group($attributes, $routes);\n        }\n\n        /**\n         * Merge the given array with the last group stack.\n         *\n         * @param array $new\n         * @param bool $prependExistingPrefix\n         * @return array\n         * @static\n         */        public static function mergeWithLastGroup($new, $prependExistingPrefix = true)\n        {\n                        /** @var \\Illuminate\\Routing\\Router $instance */\n                        return $instance->mergeWithLastGroup($new, $prependExistingPrefix);\n        }\n\n        /**\n         * Get the prefix from the last group on the stack.\n         *\n         * @return string\n         * @static\n         */        public static function getLastGroupPrefix()\n        {\n                        /** @var \\Illuminate\\Routing\\Router $instance */\n                        return $instance->getLastGroupPrefix();\n        }\n\n        /**\n         * Add a route to the underlying route collection.\n         *\n         * @param array|string $methods\n         * @param string $uri\n         * @param array|string|callable|null $action\n         * @return \\Illuminate\\Routing\\Route\n         * @static\n         */        public static function addRoute($methods, $uri, $action)\n        {\n                        /** @var \\Illuminate\\Routing\\Router $instance */\n                        return $instance->addRoute($methods, $uri, $action);\n        }\n\n        /**\n         * Create a new Route object.\n         *\n         * @param array|string $methods\n         * @param string $uri\n         * @param mixed $action\n         * @return \\Illuminate\\Routing\\Route\n         * @static\n         */        public static function newRoute($methods, $uri, $action)\n        {\n                        /** @var \\Illuminate\\Routing\\Router $instance */\n                        return $instance->newRoute($methods, $uri, $action);\n        }\n\n        /**\n         * Return the response returned by the given route.\n         *\n         * @param string $name\n         * @return \\Symfony\\Component\\HttpFoundation\\Response\n         * @static\n         */        public static function respondWithRoute($name)\n        {\n                        /** @var \\Illuminate\\Routing\\Router $instance */\n                        return $instance->respondWithRoute($name);\n        }\n\n        /**\n         * Dispatch the request to the application.\n         *\n         * @param \\Illuminate\\Http\\Request $request\n         * @return \\Symfony\\Component\\HttpFoundation\\Response\n         * @static\n         */        public static function dispatch($request)\n        {\n                        /** @var \\Illuminate\\Routing\\Router $instance */\n                        return $instance->dispatch($request);\n        }\n\n        /**\n         * Dispatch the request to a route and return the response.\n         *\n         * @param \\Illuminate\\Http\\Request $request\n         * @return \\Symfony\\Component\\HttpFoundation\\Response\n         * @static\n         */        public static function dispatchToRoute($request)\n        {\n                        /** @var \\Illuminate\\Routing\\Router $instance */\n                        return $instance->dispatchToRoute($request);\n        }\n\n        /**\n         * Gather the middleware for the given route with resolved class names.\n         *\n         * @param \\Illuminate\\Routing\\Route $route\n         * @return array\n         * @static\n         */        public static function gatherRouteMiddleware($route)\n        {\n                        /** @var \\Illuminate\\Routing\\Router $instance */\n                        return $instance->gatherRouteMiddleware($route);\n        }\n\n        /**\n         * Create a response instance from the given value.\n         *\n         * @param \\Symfony\\Component\\HttpFoundation\\Request $request\n         * @param mixed $response\n         * @return \\Symfony\\Component\\HttpFoundation\\Response\n         * @static\n         */        public static function prepareResponse($request, $response)\n        {\n                        /** @var \\Illuminate\\Routing\\Router $instance */\n                        return $instance->prepareResponse($request, $response);\n        }\n\n        /**\n         * Static version of prepareResponse.\n         *\n         * @param \\Symfony\\Component\\HttpFoundation\\Request $request\n         * @param mixed $response\n         * @return \\Symfony\\Component\\HttpFoundation\\Response\n         * @static\n         */        public static function toResponse($request, $response)\n        {\n                        return \\Illuminate\\Routing\\Router::toResponse($request, $response);\n        }\n\n        /**\n         * Substitute the route bindings onto the route.\n         *\n         * @param \\Illuminate\\Routing\\Route $route\n         * @return \\Illuminate\\Routing\\Route\n         * @throws \\Illuminate\\Database\\Eloquent\\ModelNotFoundException\n         * @static\n         */        public static function substituteBindings($route)\n        {\n                        /** @var \\Illuminate\\Routing\\Router $instance */\n                        return $instance->substituteBindings($route);\n        }\n\n        /**\n         * Substitute the implicit Eloquent model bindings for the route.\n         *\n         * @param \\Illuminate\\Routing\\Route $route\n         * @return void\n         * @throws \\Illuminate\\Database\\Eloquent\\ModelNotFoundException\n         * @static\n         */        public static function substituteImplicitBindings($route)\n        {\n                        /** @var \\Illuminate\\Routing\\Router $instance */\n                        $instance->substituteImplicitBindings($route);\n        }\n\n        /**\n         * Register a route matched event listener.\n         *\n         * @param string|callable $callback\n         * @return void\n         * @static\n         */        public static function matched($callback)\n        {\n                        /** @var \\Illuminate\\Routing\\Router $instance */\n                        $instance->matched($callback);\n        }\n\n        /**\n         * Get all of the defined middleware short-hand names.\n         *\n         * @return array\n         * @static\n         */        public static function getMiddleware()\n        {\n                        /** @var \\Illuminate\\Routing\\Router $instance */\n                        return $instance->getMiddleware();\n        }\n\n        /**\n         * Register a short-hand name for a middleware.\n         *\n         * @param string $name\n         * @param string $class\n         * @return \\Illuminate\\Routing\\Router\n         * @static\n         */        public static function aliasMiddleware($name, $class)\n        {\n                        /** @var \\Illuminate\\Routing\\Router $instance */\n                        return $instance->aliasMiddleware($name, $class);\n        }\n\n        /**\n         * Check if a middlewareGroup with the given name exists.\n         *\n         * @param string $name\n         * @return bool\n         * @static\n         */        public static function hasMiddlewareGroup($name)\n        {\n                        /** @var \\Illuminate\\Routing\\Router $instance */\n                        return $instance->hasMiddlewareGroup($name);\n        }\n\n        /**\n         * Get all of the defined middleware groups.\n         *\n         * @return array\n         * @static\n         */        public static function getMiddlewareGroups()\n        {\n                        /** @var \\Illuminate\\Routing\\Router $instance */\n                        return $instance->getMiddlewareGroups();\n        }\n\n        /**\n         * Register a group of middleware.\n         *\n         * @param string $name\n         * @param array $middleware\n         * @return \\Illuminate\\Routing\\Router\n         * @static\n         */        public static function middlewareGroup($name, $middleware)\n        {\n                        /** @var \\Illuminate\\Routing\\Router $instance */\n                        return $instance->middlewareGroup($name, $middleware);\n        }\n\n        /**\n         * Add a middleware to the beginning of a middleware group.\n         *\n         * If the middleware is already in the group, it will not be added again.\n         *\n         * @param string $group\n         * @param string $middleware\n         * @return \\Illuminate\\Routing\\Router\n         * @static\n         */        public static function prependMiddlewareToGroup($group, $middleware)\n        {\n                        /** @var \\Illuminate\\Routing\\Router $instance */\n                        return $instance->prependMiddlewareToGroup($group, $middleware);\n        }\n\n        /**\n         * Add a middleware to the end of a middleware group.\n         *\n         * If the middleware is already in the group, it will not be added again.\n         *\n         * @param string $group\n         * @param string $middleware\n         * @return \\Illuminate\\Routing\\Router\n         * @static\n         */        public static function pushMiddlewareToGroup($group, $middleware)\n        {\n                        /** @var \\Illuminate\\Routing\\Router $instance */\n                        return $instance->pushMiddlewareToGroup($group, $middleware);\n        }\n\n        /**\n         * Add a new route parameter binder.\n         *\n         * @param string $key\n         * @param string|callable $binder\n         * @return void\n         * @static\n         */        public static function bind($key, $binder)\n        {\n                        /** @var \\Illuminate\\Routing\\Router $instance */\n                        $instance->bind($key, $binder);\n        }\n\n        /**\n         * Register a model binder for a wildcard.\n         *\n         * @param string $key\n         * @param string $class\n         * @param \\Closure|null $callback\n         * @return void\n         * @static\n         */        public static function model($key, $class, $callback = null)\n        {\n                        /** @var \\Illuminate\\Routing\\Router $instance */\n                        $instance->model($key, $class, $callback);\n        }\n\n        /**\n         * Get the binding callback for a given binding.\n         *\n         * @param string $key\n         * @return \\Closure|null\n         * @static\n         */        public static function getBindingCallback($key)\n        {\n                        /** @var \\Illuminate\\Routing\\Router $instance */\n                        return $instance->getBindingCallback($key);\n        }\n\n        /**\n         * Get the global "where" patterns.\n         *\n         * @return array\n         * @static\n         */        public static function getPatterns()\n        {\n                        /** @var \\Illuminate\\Routing\\Router $instance */\n                        return $instance->getPatterns();\n        }\n\n        /**\n         * Set a global where pattern on all routes.\n         *\n         * @param string $key\n         * @param string $pattern\n         * @return void\n         * @static\n         */        public static function pattern($key, $pattern)\n        {\n                        /** @var \\Illuminate\\Routing\\Router $instance */\n                        $instance->pattern($key, $pattern);\n        }\n\n        /**\n         * Set a group of global where patterns on all routes.\n         *\n         * @param array $patterns\n         * @return void\n         * @static\n         */        public static function patterns($patterns)\n        {\n                        /** @var \\Illuminate\\Routing\\Router $instance */\n                        $instance->patterns($patterns);\n        }\n\n        /**\n         * Determine if the router currently has a group stack.\n         *\n         * @return bool\n         * @static\n         */        public static function hasGroupStack()\n        {\n                        /** @var \\Illuminate\\Routing\\Router $instance */\n                        return $instance->hasGroupStack();\n        }\n\n        /**\n         * Get the current group stack for the router.\n         *\n         * @return array\n         * @static\n         */        public static function getGroupStack()\n        {\n                        /** @var \\Illuminate\\Routing\\Router $instance */\n                        return $instance->getGroupStack();\n        }\n\n        /**\n         * Get a route parameter for the current route.\n         *\n         * @param string $key\n         * @param string|null $default\n         * @return mixed\n         * @static\n         */        public static function input($key, $default = null)\n        {\n                        /** @var \\Illuminate\\Routing\\Router $instance */\n                        return $instance->input($key, $default);\n        }\n\n        /**\n         * Get the request currently being dispatched.\n         *\n         * @return \\Illuminate\\Http\\Request\n         * @static\n         */        public static function getCurrentRequest()\n        {\n                        /** @var \\Illuminate\\Routing\\Router $instance */\n                        return $instance->getCurrentRequest();\n        }\n\n        /**\n         * Get the currently dispatched route instance.\n         *\n         * @return \\Illuminate\\Routing\\Route\n         * @static\n         */        public static function getCurrentRoute()\n        {\n                        /** @var \\Illuminate\\Routing\\Router $instance */\n                        return $instance->getCurrentRoute();\n        }\n\n        /**\n         * Get the currently dispatched route instance.\n         *\n         * @return \\Illuminate\\Routing\\Route|null\n         * @static\n         */        public static function current()\n        {\n                        /** @var \\Illuminate\\Routing\\Router $instance */\n                        return $instance->current();\n        }\n\n        /**\n         * Check if a route with the given name exists.\n         *\n         * @param string $name\n         * @return bool\n         * @static\n         */        public static function has($name)\n        {\n                        /** @var \\Illuminate\\Routing\\Router $instance */\n                        return $instance->has($name);\n        }\n\n        /**\n         * Get the current route name.\n         *\n         * @return string|null\n         * @static\n         */        public static function currentRouteName()\n        {\n                        /** @var \\Illuminate\\Routing\\Router $instance */\n                        return $instance->currentRouteName();\n        }\n\n        /**\n         * Alias for the "currentRouteNamed" method.\n         *\n         * @param mixed $patterns\n         * @return bool\n         * @static\n         */        public static function is(...$patterns)\n        {\n                        /** @var \\Illuminate\\Routing\\Router $instance */\n                        return $instance->is(...$patterns);\n        }\n\n        /**\n         * Determine if the current route matches a pattern.\n         *\n         * @param mixed $patterns\n         * @return bool\n         * @static\n         */        public static function currentRouteNamed(...$patterns)\n        {\n                        /** @var \\Illuminate\\Routing\\Router $instance */\n                        return $instance->currentRouteNamed(...$patterns);\n        }\n\n        /**\n         * Get the current route action.\n         *\n         * @return string|null\n         * @static\n         */        public static function currentRouteAction()\n        {\n                        /** @var \\Illuminate\\Routing\\Router $instance */\n                        return $instance->currentRouteAction();\n        }\n\n        /**\n         * Alias for the "currentRouteUses" method.\n         *\n         * @param array $patterns\n         * @return bool\n         * @static\n         */        public static function uses(...$patterns)\n        {\n                        /** @var \\Illuminate\\Routing\\Router $instance */\n                        return $instance->uses(...$patterns);\n        }\n\n        /**\n         * Determine if the current route action matches a given action.\n         *\n         * @param string $action\n         * @return bool\n         * @static\n         */        public static function currentRouteUses($action)\n        {\n                        /** @var \\Illuminate\\Routing\\Router $instance */\n                        return $instance->currentRouteUses($action);\n        }\n\n        /**\n         * Set the unmapped global resource parameters to singular.\n         *\n         * @param bool $singular\n         * @return void\n         * @static\n         */        public static function singularResourceParameters($singular = true)\n        {\n                        /** @var \\Illuminate\\Routing\\Router $instance */\n                        $instance->singularResourceParameters($singular);\n        }\n\n        /**\n         * Set the global resource parameter mapping.\n         *\n         * @param array $parameters\n         * @return void\n         * @static\n         */        public static function resourceParameters($parameters = [])\n        {\n                        /** @var \\Illuminate\\Routing\\Router $instance */\n                        $instance->resourceParameters($parameters);\n        }\n\n        /**\n         * Get or set the verbs used in the resource URIs.\n         *\n         * @param array $verbs\n         * @return array|null\n         * @static\n         */        public static function resourceVerbs($verbs = [])\n        {\n                        /** @var \\Illuminate\\Routing\\Router $instance */\n                        return $instance->resourceVerbs($verbs);\n        }\n\n        /**\n         * Get the underlying route collection.\n         *\n         * @return \\Illuminate\\Routing\\RouteCollectionInterface\n         * @static\n         */        public static function getRoutes()\n        {\n                        /** @var \\Illuminate\\Routing\\Router $instance */\n                        return $instance->getRoutes();\n        }\n\n        /**\n         * Set the route collection instance.\n         *\n         * @param \\Illuminate\\Routing\\RouteCollection $routes\n         * @return void\n         * @static\n         */        public static function setRoutes($routes)\n        {\n                        /** @var \\Illuminate\\Routing\\Router $instance */\n                        $instance->setRoutes($routes);\n        }\n\n        /**\n         * Set the compiled route collection instance.\n         *\n         * @param array $routes\n         * @return void\n         * @static\n         */        public static function setCompiledRoutes($routes)\n        {\n                        /** @var \\Illuminate\\Routing\\Router $instance */\n                        $instance->setCompiledRoutes($routes);\n        }\n\n        /**\n         * Register a custom macro.\n         *\n         * @param string $name\n         * @param object|callable $macro\n         * @return void\n         * @static\n         */        public static function macro($name, $macro)\n        {\n                        \\Illuminate\\Routing\\Router::macro($name, $macro);\n        }\n\n        /**\n         * Mix another object into the class.\n         *\n         * @param object $mixin\n         * @param bool $replace\n         * @return void\n         * @throws \\ReflectionException\n         * @static\n         */        public static function mixin($mixin, $replace = true)\n        {\n                        \\Illuminate\\Routing\\Router::mixin($mixin, $replace);\n        }\n\n        /**\n         * Checks if macro is registered.\n         *\n         * @param string $name\n         * @return bool\n         * @static\n         */        public static function hasMacro($name)\n        {\n                        return \\Illuminate\\Routing\\Router::hasMacro($name);\n        }\n\n        /**\n         * Dynamically handle calls to the class.\n         *\n         * @param string $method\n         * @param array $parameters\n         * @return mixed\n         * @throws \\BadMethodCallException\n         * @static\n         */        public static function macroCall($method, $parameters)\n        {\n                        /** @var \\Illuminate\\Routing\\Router $instance */\n                        return $instance->macroCall($method, $parameters);\n        }\n            }\n\n    /**\n     *\n     *\n     * @see \\Illuminate\\Database\\Schema\\Builder\n     */    class Schema {\n\n        /**\n         * Determine if the given table exists.\n         *\n         * @param string $table\n         * @return bool\n         * @static\n         */        public static function hasTable($table)\n        {\n                        /** @var \\Illuminate\\Database\\Schema\\MySqlBuilder $instance */\n                        return $instance->hasTable($table);\n        }\n\n        /**\n         * Get the column listing for a given table.\n         *\n         * @param string $table\n         * @return array\n         * @static\n         */        public static function getColumnListing($table)\n        {\n                        /** @var \\Illuminate\\Database\\Schema\\MySqlBuilder $instance */\n                        return $instance->getColumnListing($table);\n        }\n\n        /**\n         * Drop all tables from the database.\n         *\n         * @return void\n         * @static\n         */        public static function dropAllTables()\n        {\n                        /** @var \\Illuminate\\Database\\Schema\\MySqlBuilder $instance */\n                        $instance->dropAllTables();\n        }\n\n        /**\n         * Drop all views from the database.\n         *\n         * @return void\n         * @static\n         */        public static function dropAllViews()\n        {\n                        /** @var \\Illuminate\\Database\\Schema\\MySqlBuilder $instance */\n                        $instance->dropAllViews();\n        }\n\n        /**\n         * Get all of the table names for the database.\n         *\n         * @return array\n         * @static\n         */        public static function getAllTables()\n        {\n                        /** @var \\Illuminate\\Database\\Schema\\MySqlBuilder $instance */\n                        return $instance->getAllTables();\n        }\n\n        /**\n         * Get all of the view names for the database.\n         *\n         * @return array\n         * @static\n         */        public static function getAllViews()\n        {\n                        /** @var \\Illuminate\\Database\\Schema\\MySqlBuilder $instance */\n                        return $instance->getAllViews();\n        }\n\n        /**\n         * Set the default string length for migrations.\n         *\n         * @param int $length\n         * @return void\n         * @static\n         */        public static function defaultStringLength($length)\n        {\n            //Method inherited from \\Illuminate\\Database\\Schema\\Builder\n                        \\Illuminate\\Database\\Schema\\MySqlBuilder::defaultStringLength($length);\n        }\n\n        /**\n         * Determine if the given table has a given column.\n         *\n         * @param string $table\n         * @param string $column\n         * @return bool\n         * @static\n         */        public static function hasColumn($table, $column)\n        {\n            //Method inherited from \\Illuminate\\Database\\Schema\\Builder\n                        /** @var \\Illuminate\\Database\\Schema\\MySqlBuilder $instance */\n                        return $instance->hasColumn($table, $column);\n        }\n\n        /**\n         * Determine if the given table has given columns.\n         *\n         * @param string $table\n         * @param array $columns\n         * @return bool\n         * @static\n         */        public static function hasColumns($table, $columns)\n        {\n            //Method inherited from \\Illuminate\\Database\\Schema\\Builder\n                        /** @var \\Illuminate\\Database\\Schema\\MySqlBuilder $instance */\n                        return $instance->hasColumns($table, $columns);\n        }\n\n        /**\n         * Get the data type for the given column name.\n         *\n         * @param string $table\n         * @param string $column\n         * @return string\n         * @static\n         */        public static function getColumnType($table, $column)\n        {\n            //Method inherited from \\Illuminate\\Database\\Schema\\Builder\n                        /** @var \\Illuminate\\Database\\Schema\\MySqlBuilder $instance */\n                        return $instance->getColumnType($table, $column);\n        }\n\n        /**\n         * Modify a table on the schema.\n         *\n         * @param string $table\n         * @param \\Closure $callback\n         * @return void\n         * @static\n         */        public static function table($table, $callback)\n        {\n            //Method inherited from \\Illuminate\\Database\\Schema\\Builder\n                        /** @var \\Illuminate\\Database\\Schema\\MySqlBuilder $instance */\n                        $instance->table($table, $callback);\n        }\n\n        /**\n         * Create a new table on the schema.\n         *\n         * @param string $table\n         * @param \\Closure $callback\n         * @return void\n         * @static\n         */        public static function create($table, $callback)\n        {\n            //Method inherited from \\Illuminate\\Database\\Schema\\Builder\n                        /** @var \\Illuminate\\Database\\Schema\\MySqlBuilder $instance */\n                        $instance->create($table, $callback);\n        }\n\n        /**\n         * Drop a table from the schema.\n         *\n         * @param string $table\n         * @return void\n         * @static\n         */        public static function drop($table)\n        {\n            //Method inherited from \\Illuminate\\Database\\Schema\\Builder\n                        /** @var \\Illuminate\\Database\\Schema\\MySqlBuilder $instance */\n                        $instance->drop($table);\n        }\n\n        /**\n         * Drop a table from the schema if it exists.\n         *\n         * @param string $table\n         * @return void\n         * @static\n         */        public static function dropIfExists($table)\n        {\n            //Method inherited from \\Illuminate\\Database\\Schema\\Builder\n                        /** @var \\Illuminate\\Database\\Schema\\MySqlBuilder $instance */\n                        $instance->dropIfExists($table);\n        }\n\n        /**\n         * Drop all types from the database.\n         *\n         * @return void\n         * @throws \\LogicException\n         * @static\n         */        public static function dropAllTypes()\n        {\n            //Method inherited from \\Illuminate\\Database\\Schema\\Builder\n                        /** @var \\Illuminate\\Database\\Schema\\MySqlBuilder $instance */\n                        $instance->dropAllTypes();\n        }\n\n        /**\n         * Rename a table on the schema.\n         *\n         * @param string $from\n         * @param string $to\n         * @return void\n         * @static\n         */        public static function rename($from, $to)\n        {\n            //Method inherited from \\Illuminate\\Database\\Schema\\Builder\n                        /** @var \\Illuminate\\Database\\Schema\\MySqlBuilder $instance */\n                        $instance->rename($from, $to);\n        }\n\n        /**\n         * Enable foreign key constraints.\n         *\n         * @return bool\n         * @static\n         */        public static function enableForeignKeyConstraints()\n        {\n            //Method inherited from \\Illuminate\\Database\\Schema\\Builder\n                        /** @var \\Illuminate\\Database\\Schema\\MySqlBuilder $instance */\n                        return $instance->enableForeignKeyConstraints();\n        }\n\n        /**\n         * Disable foreign key constraints.\n         *\n         * @return bool\n         * @static\n         */        public static function disableForeignKeyConstraints()\n        {\n            //Method inherited from \\Illuminate\\Database\\Schema\\Builder\n                        /** @var \\Illuminate\\Database\\Schema\\MySqlBuilder $instance */\n                        return $instance->disableForeignKeyConstraints();\n        }\n\n        /**\n         * Register a custom Doctrine mapping type.\n         *\n         * @param string $class\n         * @param string $name\n         * @param string $type\n         * @return void\n         * @throws \\Doctrine\\DBAL\\DBALException\n         * @throws \\RuntimeException\n         * @static\n         */        public static function registerCustomDoctrineType($class, $name, $type)\n        {\n            //Method inherited from \\Illuminate\\Database\\Schema\\Builder\n                        /** @var \\Illuminate\\Database\\Schema\\MySqlBuilder $instance */\n                        $instance->registerCustomDoctrineType($class, $name, $type);\n        }\n\n        /**\n         * Get the database connection instance.\n         *\n         * @return \\Illuminate\\Database\\Connection\n         * @static\n         */        public static function getConnection()\n        {\n            //Method inherited from \\Illuminate\\Database\\Schema\\Builder\n                        /** @var \\Illuminate\\Database\\Schema\\MySqlBuilder $instance */\n                        return $instance->getConnection();\n        }\n\n        /**\n         * Set the database connection instance.\n         *\n         * @param \\Illuminate\\Database\\Connection $connection\n         * @return \\Illuminate\\Database\\Schema\\MySqlBuilder\n         * @static\n         */        public static function setConnection($connection)\n        {\n            //Method inherited from \\Illuminate\\Database\\Schema\\Builder\n                        /** @var \\Illuminate\\Database\\Schema\\MySqlBuilder $instance */\n                        return $instance->setConnection($connection);\n        }\n\n        /**\n         * Set the Schema Blueprint resolver callback.\n         *\n         * @param \\Closure $resolver\n         * @return void\n         * @static\n         */        public static function blueprintResolver($resolver)\n        {\n            //Method inherited from \\Illuminate\\Database\\Schema\\Builder\n                        /** @var \\Illuminate\\Database\\Schema\\MySqlBuilder $instance */\n                        $instance->blueprintResolver($resolver);\n        }\n            }\n\n    /**\n     *\n     *\n     * @see \\Illuminate\\Session\\SessionManager\n     * @see \\Illuminate\\Session\\Store\n     */    class Session {\n\n        /**\n         * Get the session configuration.\n         *\n         * @return array\n         * @static\n         */        public static function getSessionConfig()\n        {\n                        /** @var \\Illuminate\\Session\\SessionManager $instance */\n                        return $instance->getSessionConfig();\n        }\n\n        /**\n         * Get the default session driver name.\n         *\n         * @return string\n         * @static\n         */        public static function getDefaultDriver()\n        {\n                        /** @var \\Illuminate\\Session\\SessionManager $instance */\n                        return $instance->getDefaultDriver();\n        }\n\n        /**\n         * Set the default session driver name.\n         *\n         * @param string $name\n         * @return void\n         * @static\n         */        public static function setDefaultDriver($name)\n        {\n                        /** @var \\Illuminate\\Session\\SessionManager $instance */\n                        $instance->setDefaultDriver($name);\n        }\n\n        /**\n         * Get a driver instance.\n         *\n         * @param string|null $driver\n         * @return mixed\n         * @throws \\InvalidArgumentException\n         * @static\n         */        public static function driver($driver = null)\n        {\n            //Method inherited from \\Illuminate\\Support\\Manager\n                        /** @var \\Illuminate\\Session\\SessionManager $instance */\n                        return $instance->driver($driver);\n        }\n\n        /**\n         * Register a custom driver creator Closure.\n         *\n         * @param string $driver\n         * @param \\Closure $callback\n         * @return \\Illuminate\\Session\\SessionManager\n         * @static\n         */        public static function extend($driver, $callback)\n        {\n            //Method inherited from \\Illuminate\\Support\\Manager\n                        /** @var \\Illuminate\\Session\\SessionManager $instance */\n                        return $instance->extend($driver, $callback);\n        }\n\n        /**\n         * Get all of the created "drivers".\n         *\n         * @return array\n         * @static\n         */        public static function getDrivers()\n        {\n            //Method inherited from \\Illuminate\\Support\\Manager\n                        /** @var \\Illuminate\\Session\\SessionManager $instance */\n                        return $instance->getDrivers();\n        }\n\n        /**\n         * Start the session, reading the data from a handler.\n         *\n         * @return bool\n         * @static\n         */        public static function start()\n        {\n                        /** @var \\Illuminate\\Session\\Store $instance */\n                        return $instance->start();\n        }\n\n        /**\n         * Save the session data to storage.\n         *\n         * @return void\n         * @static\n         */        public static function save()\n        {\n                        /** @var \\Illuminate\\Session\\Store $instance */\n                        $instance->save();\n        }\n\n        /**\n         * Age the flash data for the session.\n         *\n         * @return void\n         * @static\n         */        public static function ageFlashData()\n        {\n                        /** @var \\Illuminate\\Session\\Store $instance */\n                        $instance->ageFlashData();\n        }\n\n        /**\n         * Get all of the session data.\n         *\n         * @return array\n         * @static\n         */        public static function all()\n        {\n                        /** @var \\Illuminate\\Session\\Store $instance */\n                        return $instance->all();\n        }\n\n        /**\n         * Get a subset of the session data.\n         *\n         * @param array $keys\n         * @return array\n         * @static\n         */        public static function only($keys)\n        {\n                        /** @var \\Illuminate\\Session\\Store $instance */\n                        return $instance->only($keys);\n        }\n\n        /**\n         * Checks if a key exists.\n         *\n         * @param string|array $key\n         * @return bool\n         * @static\n         */        public static function exists($key)\n        {\n                        /** @var \\Illuminate\\Session\\Store $instance */\n                        return $instance->exists($key);\n        }\n\n        /**\n         * Checks if a key is present and not null.\n         *\n         * @param string|array $key\n         * @return bool\n         * @static\n         */        public static function has($key)\n        {\n                        /** @var \\Illuminate\\Session\\Store $instance */\n                        return $instance->has($key);\n        }\n\n        /**\n         * Get an item from the session.\n         *\n         * @param string $key\n         * @param mixed $default\n         * @return mixed\n         * @static\n         */        public static function get($key, $default = null)\n        {\n                        /** @var \\Illuminate\\Session\\Store $instance */\n                        return $instance->get($key, $default);\n        }\n\n        /**\n         * Get the value of a given key and then forget it.\n         *\n         * @param string $key\n         * @param string|null $default\n         * @return mixed\n         * @static\n         */        public static function pull($key, $default = null)\n        {\n                        /** @var \\Illuminate\\Session\\Store $instance */\n                        return $instance->pull($key, $default);\n        }\n\n        /**\n         * Determine if the session contains old input.\n         *\n         * @param string|null $key\n         * @return bool\n         * @static\n         */        public static function hasOldInput($key = null)\n        {\n                        /** @var \\Illuminate\\Session\\Store $instance */\n                        return $instance->hasOldInput($key);\n        }\n\n        /**\n         * Get the requested item from the flashed input array.\n         *\n         * @param string|null $key\n         * @param mixed $default\n         * @return mixed\n         * @static\n         */        public static function getOldInput($key = null, $default = null)\n        {\n                        /** @var \\Illuminate\\Session\\Store $instance */\n                        return $instance->getOldInput($key, $default);\n        }\n\n        /**\n         * Replace the given session attributes entirely.\n         *\n         * @param array $attributes\n         * @return void\n         * @static\n         */        public static function replace($attributes)\n        {\n                        /** @var \\Illuminate\\Session\\Store $instance */\n                        $instance->replace($attributes);\n        }\n\n        /**\n         * Put a key / value pair or array of key / value pairs in the session.\n         *\n         * @param string|array $key\n         * @param mixed $value\n         * @return void\n         * @static\n         */        public static function put($key, $value = null)\n        {\n                        /** @var \\Illuminate\\Session\\Store $instance */\n                        $instance->put($key, $value);\n        }\n\n        /**\n         * Get an item from the session, or store the default value.\n         *\n         * @param string $key\n         * @param \\Closure $callback\n         * @return mixed\n         * @static\n         */        public static function remember($key, $callback)\n        {\n                        /** @var \\Illuminate\\Session\\Store $instance */\n                        return $instance->remember($key, $callback);\n        }\n\n        /**\n         * Push a value onto a session array.\n         *\n         * @param string $key\n         * @param mixed $value\n         * @return void\n         * @static\n         */        public static function push($key, $value)\n        {\n                        /** @var \\Illuminate\\Session\\Store $instance */\n                        $instance->push($key, $value);\n        }\n\n        /**\n         * Increment the value of an item in the session.\n         *\n         * @param string $key\n         * @param int $amount\n         * @return mixed\n         * @static\n         */        public static function increment($key, $amount = 1)\n        {\n                        /** @var \\Illuminate\\Session\\Store $instance */\n                        return $instance->increment($key, $amount);\n        }\n\n        /**\n         * Decrement the value of an item in the session.\n         *\n         * @param string $key\n         * @param int $amount\n         * @return int\n         * @static\n         */        public static function decrement($key, $amount = 1)\n        {\n                        /** @var \\Illuminate\\Session\\Store $instance */\n                        return $instance->decrement($key, $amount);\n        }\n\n        /**\n         * Flash a key / value pair to the session.\n         *\n         * @param string $key\n         * @param mixed $value\n         * @return void\n         * @static\n         */        public static function flash($key, $value = true)\n        {\n                        /** @var \\Illuminate\\Session\\Store $instance */\n                        $instance->flash($key, $value);\n        }\n\n        /**\n         * Flash a key / value pair to the session for immediate use.\n         *\n         * @param string $key\n         * @param mixed $value\n         * @return void\n         * @static\n         */        public static function now($key, $value)\n        {\n                        /** @var \\Illuminate\\Session\\Store $instance */\n                        $instance->now($key, $value);\n        }\n\n        /**\n         * Reflash all of the session flash data.\n         *\n         * @return void\n         * @static\n         */        public static function reflash()\n        {\n                        /** @var \\Illuminate\\Session\\Store $instance */\n                        $instance->reflash();\n        }\n\n        /**\n         * Reflash a subset of the current flash data.\n         *\n         * @param array|mixed $keys\n         * @return void\n         * @static\n         */        public static function keep($keys = null)\n        {\n                        /** @var \\Illuminate\\Session\\Store $instance */\n                        $instance->keep($keys);\n        }\n\n        /**\n         * Flash an input array to the session.\n         *\n         * @param array $value\n         * @return void\n         * @static\n         */        public static function flashInput($value)\n        {\n                        /** @var \\Illuminate\\Session\\Store $instance */\n                        $instance->flashInput($value);\n        }\n\n        /**\n         * Remove an item from the session, returning its value.\n         *\n         * @param string $key\n         * @return mixed\n         * @static\n         */        public static function remove($key)\n        {\n                        /** @var \\Illuminate\\Session\\Store $instance */\n                        return $instance->remove($key);\n        }\n\n        /**\n         * Remove one or many items from the session.\n         *\n         * @param string|array $keys\n         * @return void\n         * @static\n         */        public static function forget($keys)\n        {\n                        /** @var \\Illuminate\\Session\\Store $instance */\n                        $instance->forget($keys);\n        }\n\n        /**\n         * Remove all of the items from the session.\n         *\n         * @return void\n         * @static\n         */        public static function flush()\n        {\n                        /** @var \\Illuminate\\Session\\Store $instance */\n                        $instance->flush();\n        }\n\n        /**\n         * Flush the session data and regenerate the ID.\n         *\n         * @return bool\n         * @static\n         */        public static function invalidate()\n        {\n                        /** @var \\Illuminate\\Session\\Store $instance */\n                        return $instance->invalidate();\n        }\n\n        /**\n         * Generate a new session identifier.\n         *\n         * @param bool $destroy\n         * @return bool\n         * @static\n         */        public static function regenerate($destroy = false)\n        {\n                        /** @var \\Illuminate\\Session\\Store $instance */\n                        return $instance->regenerate($destroy);\n        }\n\n        /**\n         * Generate a new session ID for the session.\n         *\n         * @param bool $destroy\n         * @return bool\n         * @static\n         */        public static function migrate($destroy = false)\n        {\n                        /** @var \\Illuminate\\Session\\Store $instance */\n                        return $instance->migrate($destroy);\n        }\n\n        /**\n         * Determine if the session has been started.\n         *\n         * @return bool\n         * @static\n         */        public static function isStarted()\n        {\n                        /** @var \\Illuminate\\Session\\Store $instance */\n                        return $instance->isStarted();\n        }\n\n        /**\n         * Get the name of the session.\n         *\n         * @return string\n         * @static\n         */        public static function getName()\n        {\n                        /** @var \\Illuminate\\Session\\Store $instance */\n                        return $instance->getName();\n        }\n\n        /**\n         * Set the name of the session.\n         *\n         * @param string $name\n         * @return void\n         * @static\n         */        public static function setName($name)\n        {\n                        /** @var \\Illuminate\\Session\\Store $instance */\n                        $instance->setName($name);\n        }\n\n        /**\n         * Get the current session ID.\n         *\n         * @return string\n         * @static\n         */        public static function getId()\n        {\n                        /** @var \\Illuminate\\Session\\Store $instance */\n                        return $instance->getId();\n        }\n\n        /**\n         * Set the session ID.\n         *\n         * @param string $id\n         * @return void\n         * @static\n         */        public static function setId($id)\n        {\n                        /** @var \\Illuminate\\Session\\Store $instance */\n                        $instance->setId($id);\n        }\n\n        /**\n         * Determine if this is a valid session ID.\n         *\n         * @param string $id\n         * @return bool\n         * @static\n         */        public static function isValidId($id)\n        {\n                        /** @var \\Illuminate\\Session\\Store $instance */\n                        return $instance->isValidId($id);\n        }\n\n        /**\n         * Set the existence of the session on the handler if applicable.\n         *\n         * @param bool $value\n         * @return void\n         * @static\n         */        public static function setExists($value)\n        {\n                        /** @var \\Illuminate\\Session\\Store $instance */\n                        $instance->setExists($value);\n        }\n\n        /**\n         * Get the CSRF token value.\n         *\n         * @return string\n         * @static\n         */        public static function token()\n        {\n                        /** @var \\Illuminate\\Session\\Store $instance */\n                        return $instance->token();\n        }\n\n        /**\n         * Regenerate the CSRF token value.\n         *\n         * @return void\n         * @static\n         */        public static function regenerateToken()\n        {\n                        /** @var \\Illuminate\\Session\\Store $instance */\n                        $instance->regenerateToken();\n        }\n\n        /**\n         * Get the previous URL from the session.\n         *\n         * @return string|null\n         * @static\n         */        public static function previousUrl()\n        {\n                        /** @var \\Illuminate\\Session\\Store $instance */\n                        return $instance->previousUrl();\n        }\n\n        /**\n         * Set the "previous" URL in the session.\n         *\n         * @param string $url\n         * @return void\n         * @static\n         */        public static function setPreviousUrl($url)\n        {\n                        /** @var \\Illuminate\\Session\\Store $instance */\n                        $instance->setPreviousUrl($url);\n        }\n\n        /**\n         * Get the underlying session handler implementation.\n         *\n         * @return \\SessionHandlerInterface\n         * @static\n         */        public static function getHandler()\n        {\n                        /** @var \\Illuminate\\Session\\Store $instance */\n                        return $instance->getHandler();\n        }\n\n        /**\n         * Determine if the session handler needs a request.\n         *\n         * @return bool\n         * @static\n         */        public static function handlerNeedsRequest()\n        {\n                        /** @var \\Illuminate\\Session\\Store $instance */\n                        return $instance->handlerNeedsRequest();\n        }\n\n        /**\n         * Set the request on the handler instance.\n         *\n         * @param \\Illuminate\\Http\\Request $request\n         * @return void\n         * @static\n         */        public static function setRequestOnHandler($request)\n        {\n                        /** @var \\Illuminate\\Session\\Store $instance */\n                        $instance->setRequestOnHandler($request);\n        }\n            }\n\n    /**\n     *\n     *\n     * @see \\Illuminate\\Filesystem\\FilesystemManager\n     */    class Storage {\n\n        /**\n         * Get a filesystem instance.\n         *\n         * @param string|null $name\n         * @return \\Illuminate\\Filesystem\\FilesystemAdapter\n         * @static\n         */        public static function drive($name = null)\n        {\n                        /** @var \\Illuminate\\Filesystem\\FilesystemManager $instance */\n                        return $instance->drive($name);\n        }\n\n        /**\n         * Get a filesystem instance.\n         *\n         * @param string|null $name\n         * @return \\Illuminate\\Filesystem\\FilesystemAdapter\n         * @static\n         */        public static function disk($name = null)\n        {\n                        /** @var \\Illuminate\\Filesystem\\FilesystemManager $instance */\n                        return $instance->disk($name);\n        }\n\n        /**\n         * Get a default cloud filesystem instance.\n         *\n         * @return \\Illuminate\\Filesystem\\FilesystemAdapter\n         * @static\n         */        public static function cloud()\n        {\n                        /** @var \\Illuminate\\Filesystem\\FilesystemManager $instance */\n                        return $instance->cloud();\n        }\n\n        /**\n         * Create an instance of the local driver.\n         *\n         * @param array $config\n         * @return \\Illuminate\\Filesystem\\FilesystemAdapter\n         * @static\n         */        public static function createLocalDriver($config)\n        {\n                        /** @var \\Illuminate\\Filesystem\\FilesystemManager $instance */\n                        return $instance->createLocalDriver($config);\n        }\n\n        /**\n         * Create an instance of the ftp driver.\n         *\n         * @param array $config\n         * @return \\Illuminate\\Filesystem\\FilesystemAdapter\n         * @static\n         */        public static function createFtpDriver($config)\n        {\n                        /** @var \\Illuminate\\Filesystem\\FilesystemManager $instance */\n                        return $instance->createFtpDriver($config);\n        }\n\n        /**\n         * Create an instance of the sftp driver.\n         *\n         * @param array $config\n         * @return \\Illuminate\\Filesystem\\FilesystemAdapter\n         * @static\n         */        public static function createSftpDriver($config)\n        {\n                        /** @var \\Illuminate\\Filesystem\\FilesystemManager $instance */\n                        return $instance->createSftpDriver($config);\n        }\n\n        /**\n         * Create an instance of the Amazon S3 driver.\n         *\n         * @param array $config\n         * @return \\Illuminate\\Contracts\\Filesystem\\Cloud\n         * @static\n         */        public static function createS3Driver($config)\n        {\n                        /** @var \\Illuminate\\Filesystem\\FilesystemManager $instance */\n                        return $instance->createS3Driver($config);\n        }\n\n        /**\n         * Set the given disk instance.\n         *\n         * @param string $name\n         * @param mixed $disk\n         * @return \\Illuminate\\Filesystem\\FilesystemManager\n         * @static\n         */        public static function set($name, $disk)\n        {\n                        /** @var \\Illuminate\\Filesystem\\FilesystemManager $instance */\n                        return $instance->set($name, $disk);\n        }\n\n        /**\n         * Get the default driver name.\n         *\n         * @return string\n         * @static\n         */        public static function getDefaultDriver()\n        {\n                        /** @var \\Illuminate\\Filesystem\\FilesystemManager $instance */\n                        return $instance->getDefaultDriver();\n        }\n\n        /**\n         * Get the default cloud driver name.\n         *\n         * @return string\n         * @static\n         */        public static function getDefaultCloudDriver()\n        {\n                        /** @var \\Illuminate\\Filesystem\\FilesystemManager $instance */\n                        return $instance->getDefaultCloudDriver();\n        }\n\n        /**\n         * Unset the given disk instances.\n         *\n         * @param array|string $disk\n         * @return \\Illuminate\\Filesystem\\FilesystemManager\n         * @static\n         */        public static function forgetDisk($disk)\n        {\n                        /** @var \\Illuminate\\Filesystem\\FilesystemManager $instance */\n                        return $instance->forgetDisk($disk);\n        }\n\n        /**\n         * Register a custom driver creator Closure.\n         *\n         * @param string $driver\n         * @param \\Closure $callback\n         * @return \\Illuminate\\Filesystem\\FilesystemManager\n         * @static\n         */        public static function extend($driver, $callback)\n        {\n                        /** @var \\Illuminate\\Filesystem\\FilesystemManager $instance */\n                        return $instance->extend($driver, $callback);\n        }\n\n        /**\n         * Assert that the given file exists.\n         *\n         * @param string|array $path\n         * @return \\Illuminate\\Filesystem\\FilesystemAdapter\n         * @static\n         */        public static function assertExists($path)\n        {\n                        /** @var \\Illuminate\\Filesystem\\FilesystemAdapter $instance */\n                        return $instance->assertExists($path);\n        }\n\n        /**\n         * Assert that the given file does not exist.\n         *\n         * @param string|array $path\n         * @return \\Illuminate\\Filesystem\\FilesystemAdapter\n         * @static\n         */        public static function assertMissing($path)\n        {\n                        /** @var \\Illuminate\\Filesystem\\FilesystemAdapter $instance */\n                        return $instance->assertMissing($path);\n        }\n\n        /**\n         * Determine if a file exists.\n         *\n         * @param string $path\n         * @return bool\n         * @static\n         */        public static function exists($path)\n        {\n                        /** @var \\Illuminate\\Filesystem\\FilesystemAdapter $instance */\n                        return $instance->exists($path);\n        }\n\n        /**\n         * Determine if a file or directory is missing.\n         *\n         * @param string $path\n         * @return bool\n         * @static\n         */        public static function missing($path)\n        {\n                        /** @var \\Illuminate\\Filesystem\\FilesystemAdapter $instance */\n                        return $instance->missing($path);\n        }\n\n        /**\n         * Get the full path for the file at the given "short" path.\n         *\n         * @param string $path\n         * @return string\n         * @static\n         */        public static function path($path)\n        {\n                        /** @var \\Illuminate\\Filesystem\\FilesystemAdapter $instance */\n                        return $instance->path($path);\n        }\n\n        /**\n         * Get the contents of a file.\n         *\n         * @param string $path\n         * @return string\n         * @throws \\Illuminate\\Contracts\\Filesystem\\FileNotFoundException\n         * @static\n         */        public static function get($path)\n        {\n                        /** @var \\Illuminate\\Filesystem\\FilesystemAdapter $instance */\n                        return $instance->get($path);\n        }\n\n        /**\n         * Create a streamed response for a given file.\n         *\n         * @param string $path\n         * @param string|null $name\n         * @param array|null $headers\n         * @param string|null $disposition\n         * @return \\Symfony\\Component\\HttpFoundation\\StreamedResponse\n         * @static\n         */        public static function response($path, $name = null, $headers = [], $disposition = \'inline\')\n        {\n                        /** @var \\Illuminate\\Filesystem\\FilesystemAdapter $instance */\n                        return $instance->response($path, $name, $headers, $disposition);\n        }\n\n        /**\n         * Create a streamed download response for a given file.\n         *\n         * @param string $path\n         * @param string|null $name\n         * @param array|null $headers\n         * @return \\Symfony\\Component\\HttpFoundation\\StreamedResponse\n         * @static\n         */        public static function download($path, $name = null, $headers = [])\n        {\n                        /** @var \\Illuminate\\Filesystem\\FilesystemAdapter $instance */\n                        return $instance->download($path, $name, $headers);\n        }\n\n        /**\n         * Write the contents of a file.\n         *\n         * @param string $path\n         * @param string|resource $contents\n         * @param mixed $options\n         * @return bool\n         * @static\n         */        public static function put($path, $contents, $options = [])\n        {\n                        /** @var \\Illuminate\\Filesystem\\FilesystemAdapter $instance */\n                        return $instance->put($path, $contents, $options);\n        }\n\n        /**\n         * Store the uploaded file on the disk.\n         *\n         * @param string $path\n         * @param \\Illuminate\\Http\\File|\\Illuminate\\Http\\UploadedFile|string $file\n         * @param array $options\n         * @return string|false\n         * @static\n         */        public static function putFile($path, $file, $options = [])\n        {\n                        /** @var \\Illuminate\\Filesystem\\FilesystemAdapter $instance */\n                        return $instance->putFile($path, $file, $options);\n        }\n\n        /**\n         * Store the uploaded file on the disk with a given name.\n         *\n         * @param string $path\n         * @param \\Illuminate\\Http\\File|\\Illuminate\\Http\\UploadedFile|string $file\n         * @param string $name\n         * @param array $options\n         * @return string|false\n         * @static\n         */        public static function putFileAs($path, $file, $name, $options = [])\n        {\n                        /** @var \\Illuminate\\Filesystem\\FilesystemAdapter $instance */\n                        return $instance->putFileAs($path, $file, $name, $options);\n        }\n\n        /**\n         * Get the visibility for the given path.\n         *\n         * @param string $path\n         * @return string\n         * @static\n         */        public static function getVisibility($path)\n        {\n                        /** @var \\Illuminate\\Filesystem\\FilesystemAdapter $instance */\n                        return $instance->getVisibility($path);\n        }\n\n        /**\n         * Set the visibility for the given path.\n         *\n         * @param string $path\n         * @param string $visibility\n         * @return bool\n         * @static\n         */        public static function setVisibility($path, $visibility)\n        {\n                        /** @var \\Illuminate\\Filesystem\\FilesystemAdapter $instance */\n                        return $instance->setVisibility($path, $visibility);\n        }\n\n        /**\n         * Prepend to a file.\n         *\n         * @param string $path\n         * @param string $data\n         * @param string $separator\n         * @return bool\n         * @static\n         */        public static function prepend($path, $data, $separator = \'\n\')\n        {\n                        /** @var \\Illuminate\\Filesystem\\FilesystemAdapter $instance */\n                        return $instance->prepend($path, $data, $separator);\n        }\n\n        /**\n         * Append to a file.\n         *\n         * @param string $path\n         * @param string $data\n         * @param string $separator\n         * @return bool\n         * @static\n         */        public static function append($path, $data, $separator = \'\n\')\n        {\n                        /** @var \\Illuminate\\Filesystem\\FilesystemAdapter $instance */\n                        return $instance->append($path, $data, $separator);\n        }\n\n        /**\n         * Delete the file at a given path.\n         *\n         * @param string|array $paths\n         * @return bool\n         * @static\n         */        public static function delete($paths)\n        {\n                        /** @var \\Illuminate\\Filesystem\\FilesystemAdapter $instance */\n                        return $instance->delete($paths);\n        }\n\n        /**\n         * Copy a file to a new location.\n         *\n         * @param string $from\n         * @param string $to\n         * @return bool\n         * @static\n         */        public static function copy($from, $to)\n        {\n                        /** @var \\Illuminate\\Filesystem\\FilesystemAdapter $instance */\n                        return $instance->copy($from, $to);\n        }\n\n        /**\n         * Move a file to a new location.\n         *\n         * @param string $from\n         * @param string $to\n         * @return bool\n         * @static\n         */        public static function move($from, $to)\n        {\n                        /** @var \\Illuminate\\Filesystem\\FilesystemAdapter $instance */\n                        return $instance->move($from, $to);\n        }\n\n        /**\n         * Get the file size of a given file.\n         *\n         * @param string $path\n         * @return int\n         * @static\n         */        public static function size($path)\n        {\n                        /** @var \\Illuminate\\Filesystem\\FilesystemAdapter $instance */\n                        return $instance->size($path);\n        }\n\n        /**\n         * Get the mime-type of a given file.\n         *\n         * @param string $path\n         * @return string|false\n         * @static\n         */        public static function mimeType($path)\n        {\n                        /** @var \\Illuminate\\Filesystem\\FilesystemAdapter $instance */\n                        return $instance->mimeType($path);\n        }\n\n        /**\n         * Get the file\'s last modification time.\n         *\n         * @param string $path\n         * @return int\n         * @static\n         */        public static function lastModified($path)\n        {\n                        /** @var \\Illuminate\\Filesystem\\FilesystemAdapter $instance */\n                        return $instance->lastModified($path);\n        }\n\n        /**\n         * Get the URL for the file at the given path.\n         *\n         * @param string $path\n         * @return string\n         * @throws \\RuntimeException\n         * @static\n         */        public static function url($path)\n        {\n                        /** @var \\Illuminate\\Filesystem\\FilesystemAdapter $instance */\n                        return $instance->url($path);\n        }\n\n        /**\n         * Get a resource to read the file.\n         *\n         * @param string $path\n         * @return resource|null The path resource or null on failure.\n         * @throws \\Illuminate\\Contracts\\Filesystem\\FileNotFoundException\n         * @static\n         */        public static function readStream($path)\n        {\n                        /** @var \\Illuminate\\Filesystem\\FilesystemAdapter $instance */\n                        return $instance->readStream($path);\n        }\n\n        /**\n         * Write a new file using a stream.\n         *\n         * @param string $path\n         * @param resource $resource\n         * @param array $options\n         * @return bool\n         * @throws \\InvalidArgumentException If $resource is not a file handle.\n         * @throws \\Illuminate\\Contracts\\Filesystem\\FileExistsException\n         * @static\n         */        public static function writeStream($path, $resource, $options = [])\n        {\n                        /** @var \\Illuminate\\Filesystem\\FilesystemAdapter $instance */\n                        return $instance->writeStream($path, $resource, $options);\n        }\n\n        /**\n         * Get a temporary URL for the file at the given path.\n         *\n         * @param string $path\n         * @param \\DateTimeInterface $expiration\n         * @param array $options\n         * @return string\n         * @throws \\RuntimeException\n         * @static\n         */        public static function temporaryUrl($path, $expiration, $options = [])\n        {\n                        /** @var \\Illuminate\\Filesystem\\FilesystemAdapter $instance */\n                        return $instance->temporaryUrl($path, $expiration, $options);\n        }\n\n        /**\n         * Get a temporary URL for the file at the given path.\n         *\n         * @param \\League\\Flysystem\\AwsS3v3\\AwsS3Adapter $adapter\n         * @param string $path\n         * @param \\DateTimeInterface $expiration\n         * @param array $options\n         * @return string\n         * @static\n         */        public static function getAwsTemporaryUrl($adapter, $path, $expiration, $options)\n        {\n                        /** @var \\Illuminate\\Filesystem\\FilesystemAdapter $instance */\n                        return $instance->getAwsTemporaryUrl($adapter, $path, $expiration, $options);\n        }\n\n        /**\n         * Get an array of all files in a directory.\n         *\n         * @param string|null $directory\n         * @param bool $recursive\n         * @return array\n         * @static\n         */        public static function files($directory = null, $recursive = false)\n        {\n                        /** @var \\Illuminate\\Filesystem\\FilesystemAdapter $instance */\n                        return $instance->files($directory, $recursive);\n        }\n\n        /**\n         * Get all of the files from the given directory (recursive).\n         *\n         * @param string|null $directory\n         * @return array\n         * @static\n         */        public static function allFiles($directory = null)\n        {\n                        /** @var \\Illuminate\\Filesystem\\FilesystemAdapter $instance */\n                        return $instance->allFiles($directory);\n        }\n\n        /**\n         * Get all of the directories within a given directory.\n         *\n         * @param string|null $directory\n         * @param bool $recursive\n         * @return array\n         * @static\n         */        public static function directories($directory = null, $recursive = false)\n        {\n                        /** @var \\Illuminate\\Filesystem\\FilesystemAdapter $instance */\n                        return $instance->directories($directory, $recursive);\n        }\n\n        /**\n         * Get all (recursive) of the directories within a given directory.\n         *\n         * @param string|null $directory\n         * @return array\n         * @static\n         */        public static function allDirectories($directory = null)\n        {\n                        /** @var \\Illuminate\\Filesystem\\FilesystemAdapter $instance */\n                        return $instance->allDirectories($directory);\n        }\n\n        /**\n         * Create a directory.\n         *\n         * @param string $path\n         * @return bool\n         * @static\n         */        public static function makeDirectory($path)\n        {\n                        /** @var \\Illuminate\\Filesystem\\FilesystemAdapter $instance */\n                        return $instance->makeDirectory($path);\n        }\n\n        /**\n         * Recursively delete a directory.\n         *\n         * @param string $directory\n         * @return bool\n         * @static\n         */        public static function deleteDirectory($directory)\n        {\n                        /** @var \\Illuminate\\Filesystem\\FilesystemAdapter $instance */\n                        return $instance->deleteDirectory($directory);\n        }\n\n        /**\n         * Flush the Flysystem cache.\n         *\n         * @return void\n         * @static\n         */        public static function flushCache()\n        {\n                        /** @var \\Illuminate\\Filesystem\\FilesystemAdapter $instance */\n                        $instance->flushCache();\n        }\n\n        /**\n         * Get the Flysystem driver.\n         *\n         * @return \\League\\Flysystem\\FilesystemInterface\n         * @static\n         */        public static function getDriver()\n        {\n                        /** @var \\Illuminate\\Filesystem\\FilesystemAdapter $instance */\n                        return $instance->getDriver();\n        }\n            }\n\n    /**\n     *\n     *\n     * @see \\Illuminate\\Routing\\UrlGenerator\n     */    class URL {\n\n        /**\n         * Get the full URL for the current request.\n         *\n         * @return string\n         * @static\n         */        public static function full()\n        {\n                        /** @var \\Illuminate\\Routing\\UrlGenerator $instance */\n                        return $instance->full();\n        }\n\n        /**\n         * Get the current URL for the request.\n         *\n         * @return string\n         * @static\n         */        public static function current()\n        {\n                        /** @var \\Illuminate\\Routing\\UrlGenerator $instance */\n                        return $instance->current();\n        }\n\n        /**\n         * Get the URL for the previous request.\n         *\n         * @param mixed $fallback\n         * @return string\n         * @static\n         */        public static function previous($fallback = false)\n        {\n                        /** @var \\Illuminate\\Routing\\UrlGenerator $instance */\n                        return $instance->previous($fallback);\n        }\n\n        /**\n         * Generate an absolute URL to the given path.\n         *\n         * @param string $path\n         * @param mixed $extra\n         * @param bool|null $secure\n         * @return string\n         * @static\n         */        public static function to($path, $extra = [], $secure = null)\n        {\n                        /** @var \\Illuminate\\Routing\\UrlGenerator $instance */\n                        return $instance->to($path, $extra, $secure);\n        }\n\n        /**\n         * Generate a secure, absolute URL to the given path.\n         *\n         * @param string $path\n         * @param array $parameters\n         * @return string\n         * @static\n         */        public static function secure($path, $parameters = [])\n        {\n                        /** @var \\Illuminate\\Routing\\UrlGenerator $instance */\n                        return $instance->secure($path, $parameters);\n        }\n\n        /**\n         * Generate the URL to an application asset.\n         *\n         * @param string $path\n         * @param bool|null $secure\n         * @return string\n         * @static\n         */        public static function asset($path, $secure = null)\n        {\n                        /** @var \\Illuminate\\Routing\\UrlGenerator $instance */\n                        return $instance->asset($path, $secure);\n        }\n\n        /**\n         * Generate the URL to a secure asset.\n         *\n         * @param string $path\n         * @return string\n         * @static\n         */        public static function secureAsset($path)\n        {\n                        /** @var \\Illuminate\\Routing\\UrlGenerator $instance */\n                        return $instance->secureAsset($path);\n        }\n\n        /**\n         * Generate the URL to an asset from a custom root domain such as CDN, etc.\n         *\n         * @param string $root\n         * @param string $path\n         * @param bool|null $secure\n         * @return string\n         * @static\n         */        public static function assetFrom($root, $path, $secure = null)\n        {\n                        /** @var \\Illuminate\\Routing\\UrlGenerator $instance */\n                        return $instance->assetFrom($root, $path, $secure);\n        }\n\n        /**\n         * Get the default scheme for a raw URL.\n         *\n         * @param bool|null $secure\n         * @return string\n         * @static\n         */        public static function formatScheme($secure = null)\n        {\n                        /** @var \\Illuminate\\Routing\\UrlGenerator $instance */\n                        return $instance->formatScheme($secure);\n        }\n\n        /**\n         * Create a signed route URL for a named route.\n         *\n         * @param string $name\n         * @param array $parameters\n         * @param \\DateTimeInterface|\\DateInterval|int|null $expiration\n         * @param bool $absolute\n         * @return string\n         * @throws \\InvalidArgumentException\n         * @static\n         */        public static function signedRoute($name, $parameters = [], $expiration = null, $absolute = true)\n        {\n                        /** @var \\Illuminate\\Routing\\UrlGenerator $instance */\n                        return $instance->signedRoute($name, $parameters, $expiration, $absolute);\n        }\n\n        /**\n         * Create a temporary signed route URL for a named route.\n         *\n         * @param string $name\n         * @param \\DateTimeInterface|\\DateInterval|int $expiration\n         * @param array $parameters\n         * @param bool $absolute\n         * @return string\n         * @static\n         */        public static function temporarySignedRoute($name, $expiration, $parameters = [], $absolute = true)\n        {\n                        /** @var \\Illuminate\\Routing\\UrlGenerator $instance */\n                        return $instance->temporarySignedRoute($name, $expiration, $parameters, $absolute);\n        }\n\n        /**\n         * Determine if the given request has a valid signature.\n         *\n         * @param \\Illuminate\\Http\\Request $request\n         * @param bool $absolute\n         * @return bool\n         * @static\n         */        public static function hasValidSignature($request, $absolute = true)\n        {\n                        /** @var \\Illuminate\\Routing\\UrlGenerator $instance */\n                        return $instance->hasValidSignature($request, $absolute);\n        }\n\n        /**\n         * Determine if the signature from the given request matches the URL.\n         *\n         * @param \\Illuminate\\Http\\Request $request\n         * @param bool $absolute\n         * @return bool\n         * @static\n         */        public static function hasCorrectSignature($request, $absolute = true)\n        {\n                        /** @var \\Illuminate\\Routing\\UrlGenerator $instance */\n                        return $instance->hasCorrectSignature($request, $absolute);\n        }\n\n        /**\n         * Determine if the expires timestamp from the given request is not from the past.\n         *\n         * @param \\Illuminate\\Http\\Request $request\n         * @return bool\n         * @static\n         */        public static function signatureHasNotExpired($request)\n        {\n                        /** @var \\Illuminate\\Routing\\UrlGenerator $instance */\n                        return $instance->signatureHasNotExpired($request);\n        }\n\n        /**\n         * Get the URL to a named route.\n         *\n         * @param string $name\n         * @param mixed $parameters\n         * @param bool $absolute\n         * @return string\n         * @throws \\Symfony\\Component\\Routing\\Exception\\RouteNotFoundException\n         * @static\n         */        public static function route($name, $parameters = [], $absolute = true)\n        {\n                        /** @var \\Illuminate\\Routing\\UrlGenerator $instance */\n                        return $instance->route($name, $parameters, $absolute);\n        }\n\n        /**\n         * Get the URL for a given route instance.\n         *\n         * @param \\Illuminate\\Routing\\Route $route\n         * @param mixed $parameters\n         * @param bool $absolute\n         * @return string\n         * @throws \\Illuminate\\Routing\\Exceptions\\UrlGenerationException\n         * @static\n         */        public static function toRoute($route, $parameters, $absolute)\n        {\n                        /** @var \\Illuminate\\Routing\\UrlGenerator $instance */\n                        return $instance->toRoute($route, $parameters, $absolute);\n        }\n\n        /**\n         * Get the URL to a controller action.\n         *\n         * @param string|array $action\n         * @param mixed $parameters\n         * @param bool $absolute\n         * @return string\n         * @throws \\InvalidArgumentException\n         * @static\n         */        public static function action($action, $parameters = [], $absolute = true)\n        {\n                        /** @var \\Illuminate\\Routing\\UrlGenerator $instance */\n                        return $instance->action($action, $parameters, $absolute);\n        }\n\n        /**\n         * Format the array of URL parameters.\n         *\n         * @param mixed|array $parameters\n         * @return array\n         * @static\n         */        public static function formatParameters($parameters)\n        {\n                        /** @var \\Illuminate\\Routing\\UrlGenerator $instance */\n                        return $instance->formatParameters($parameters);\n        }\n\n        /**\n         * Get the base URL for the request.\n         *\n         * @param string $scheme\n         * @param string|null $root\n         * @return string\n         * @static\n         */        public static function formatRoot($scheme, $root = null)\n        {\n                        /** @var \\Illuminate\\Routing\\UrlGenerator $instance */\n                        return $instance->formatRoot($scheme, $root);\n        }\n\n        /**\n         * Format the given URL segments into a single URL.\n         *\n         * @param string $root\n         * @param string $path\n         * @param \\Illuminate\\Routing\\Route|null $route\n         * @return string\n         * @static\n         */        public static function format($root, $path, $route = null)\n        {\n                        /** @var \\Illuminate\\Routing\\UrlGenerator $instance */\n                        return $instance->format($root, $path, $route);\n        }\n\n        /**\n         * Determine if the given path is a valid URL.\n         *\n         * @param string $path\n         * @return bool\n         * @static\n         */        public static function isValidUrl($path)\n        {\n                        /** @var \\Illuminate\\Routing\\UrlGenerator $instance */\n                        return $instance->isValidUrl($path);\n        }\n\n        /**\n         * Set the default named parameters used by the URL generator.\n         *\n         * @param array $defaults\n         * @return void\n         * @static\n         */        public static function defaults($defaults)\n        {\n                        /** @var \\Illuminate\\Routing\\UrlGenerator $instance */\n                        $instance->defaults($defaults);\n        }\n\n        /**\n         * Get the default named parameters used by the URL generator.\n         *\n         * @return array\n         * @static\n         */        public static function getDefaultParameters()\n        {\n                        /** @var \\Illuminate\\Routing\\UrlGenerator $instance */\n                        return $instance->getDefaultParameters();\n        }\n\n        /**\n         * Force the scheme for URLs.\n         *\n         * @param string $scheme\n         * @return void\n         * @static\n         */        public static function forceScheme($scheme)\n        {\n                        /** @var \\Illuminate\\Routing\\UrlGenerator $instance */\n                        $instance->forceScheme($scheme);\n        }\n\n        /**\n         * Set the forced root URL.\n         *\n         * @param string $root\n         * @return void\n         * @static\n         */        public static function forceRootUrl($root)\n        {\n                        /** @var \\Illuminate\\Routing\\UrlGenerator $instance */\n                        $instance->forceRootUrl($root);\n        }\n\n        /**\n         * Set a callback to be used to format the host of generated URLs.\n         *\n         * @param \\Closure $callback\n         * @return \\Illuminate\\Routing\\UrlGenerator\n         * @static\n         */        public static function formatHostUsing($callback)\n        {\n                        /** @var \\Illuminate\\Routing\\UrlGenerator $instance */\n                        return $instance->formatHostUsing($callback);\n        }\n\n        /**\n         * Set a callback to be used to format the path of generated URLs.\n         *\n         * @param \\Closure $callback\n         * @return \\Illuminate\\Routing\\UrlGenerator\n         * @static\n         */        public static function formatPathUsing($callback)\n        {\n                        /** @var \\Illuminate\\Routing\\UrlGenerator $instance */\n                        return $instance->formatPathUsing($callback);\n        }\n\n        /**\n         * Get the path formatter being used by the URL generator.\n         *\n         * @return \\Closure\n         * @static\n         */        public static function pathFormatter()\n        {\n                        /** @var \\Illuminate\\Routing\\UrlGenerator $instance */\n                        return $instance->pathFormatter();\n        }\n\n        /**\n         * Get the request instance.\n         *\n         * @return \\Illuminate\\Http\\Request\n         * @static\n         */        public static function getRequest()\n        {\n                        /** @var \\Illuminate\\Routing\\UrlGenerator $instance */\n                        return $instance->getRequest();\n        }\n\n        /**\n         * Set the current request instance.\n         *\n         * @param \\Illuminate\\Http\\Request $request\n         * @return void\n         * @static\n         */        public static function setRequest($request)\n        {\n                        /** @var \\Illuminate\\Routing\\UrlGenerator $instance */\n                        $instance->setRequest($request);\n        }\n\n        /**\n         * Set the route collection.\n         *\n         * @param \\Illuminate\\Routing\\RouteCollectionInterface $routes\n         * @return \\Illuminate\\Routing\\UrlGenerator\n         * @static\n         */        public static function setRoutes($routes)\n        {\n                        /** @var \\Illuminate\\Routing\\UrlGenerator $instance */\n                        return $instance->setRoutes($routes);\n        }\n\n        /**\n         * Set the session resolver for the generator.\n         *\n         * @param callable $sessionResolver\n         * @return \\Illuminate\\Routing\\UrlGenerator\n         * @static\n         */        public static function setSessionResolver($sessionResolver)\n        {\n                        /** @var \\Illuminate\\Routing\\UrlGenerator $instance */\n                        return $instance->setSessionResolver($sessionResolver);\n        }\n\n        /**\n         * Set the encryption key resolver.\n         *\n         * @param callable $keyResolver\n         * @return \\Illuminate\\Routing\\UrlGenerator\n         * @static\n         */        public static function setKeyResolver($keyResolver)\n        {\n                        /** @var \\Illuminate\\Routing\\UrlGenerator $instance */\n                        return $instance->setKeyResolver($keyResolver);\n        }\n\n        /**\n         * Set the root controller namespace.\n         *\n         * @param string $rootNamespace\n         * @return \\Illuminate\\Routing\\UrlGenerator\n         * @static\n         */        public static function setRootControllerNamespace($rootNamespace)\n        {\n                        /** @var \\Illuminate\\Routing\\UrlGenerator $instance */\n                        return $instance->setRootControllerNamespace($rootNamespace);\n        }\n\n        /**\n         * Register a custom macro.\n         *\n         * @param string $name\n         * @param object|callable $macro\n         * @return void\n         * @static\n         */        public static function macro($name, $macro)\n        {\n                        \\Illuminate\\Routing\\UrlGenerator::macro($name, $macro);\n        }\n\n        /**\n         * Mix another object into the class.\n         *\n         * @param object $mixin\n         * @param bool $replace\n         * @return void\n         * @throws \\ReflectionException\n         * @static\n         */        public static function mixin($mixin, $replace = true)\n        {\n                        \\Illuminate\\Routing\\UrlGenerator::mixin($mixin, $replace);\n        }\n\n        /**\n         * Checks if macro is registered.\n         *\n         * @param string $name\n         * @return bool\n         * @static\n         */        public static function hasMacro($name)\n        {\n                        return \\Illuminate\\Routing\\UrlGenerator::hasMacro($name);\n        }\n            }\n\n    /**\n     *\n     *\n     * @see \\Illuminate\\Validation\\Factory\n     */    class Validator {\n\n        /**\n         * Create a new Validator instance.\n         *\n         * @param array $data\n         * @param array $rules\n         * @param array $messages\n         * @param array $customAttributes\n         * @return \\Illuminate\\Validation\\Validator\n         * @static\n         */        public static function make($data, $rules, $messages = [], $customAttributes = [])\n        {\n                        /** @var \\Illuminate\\Validation\\Factory $instance */\n                        return $instance->make($data, $rules, $messages, $customAttributes);\n        }\n\n        /**\n         * Validate the given data against the provided rules.\n         *\n         * @param array $data\n         * @param array $rules\n         * @param array $messages\n         * @param array $customAttributes\n         * @return array\n         * @throws \\Illuminate\\Validation\\ValidationException\n         * @static\n         */        public static function validate($data, $rules, $messages = [], $customAttributes = [])\n        {\n                        /** @var \\Illuminate\\Validation\\Factory $instance */\n                        return $instance->validate($data, $rules, $messages, $customAttributes);\n        }\n\n        /**\n         * Register a custom validator extension.\n         *\n         * @param string $rule\n         * @param \\Closure|string $extension\n         * @param string|null $message\n         * @return void\n         * @static\n         */        public static function extend($rule, $extension, $message = null)\n        {\n                        /** @var \\Illuminate\\Validation\\Factory $instance */\n                        $instance->extend($rule, $extension, $message);\n        }\n\n        /**\n         * Register a custom implicit validator extension.\n         *\n         * @param string $rule\n         * @param \\Closure|string $extension\n         * @param string|null $message\n         * @return void\n         * @static\n         */        public static function extendImplicit($rule, $extension, $message = null)\n        {\n                        /** @var \\Illuminate\\Validation\\Factory $instance */\n                        $instance->extendImplicit($rule, $extension, $message);\n        }\n\n        /**\n         * Register a custom dependent validator extension.\n         *\n         * @param string $rule\n         * @param \\Closure|string $extension\n         * @param string|null $message\n         * @return void\n         * @static\n         */        public static function extendDependent($rule, $extension, $message = null)\n        {\n                        /** @var \\Illuminate\\Validation\\Factory $instance */\n                        $instance->extendDependent($rule, $extension, $message);\n        }\n\n        /**\n         * Register a custom validator message replacer.\n         *\n         * @param string $rule\n         * @param \\Closure|string $replacer\n         * @return void\n         * @static\n         */        public static function replacer($rule, $replacer)\n        {\n                        /** @var \\Illuminate\\Validation\\Factory $instance */\n                        $instance->replacer($rule, $replacer);\n        }\n\n        /**\n         * Set the Validator instance resolver.\n         *\n         * @param \\Closure $resolver\n         * @return void\n         * @static\n         */        public static function resolver($resolver)\n        {\n                        /** @var \\Illuminate\\Validation\\Factory $instance */\n                        $instance->resolver($resolver);\n        }\n\n        /**\n         * Get the Translator implementation.\n         *\n         * @return \\Illuminate\\Contracts\\Translation\\Translator\n         * @static\n         */        public static function getTranslator()\n        {\n                        /** @var \\Illuminate\\Validation\\Factory $instance */\n                        return $instance->getTranslator();\n        }\n\n        /**\n         * Get the Presence Verifier implementation.\n         *\n         * @return \\Illuminate\\Validation\\PresenceVerifierInterface\n         * @static\n         */        public static function getPresenceVerifier()\n        {\n                        /** @var \\Illuminate\\Validation\\Factory $instance */\n                        return $instance->getPresenceVerifier();\n        }\n\n        /**\n         * Set the Presence Verifier implementation.\n         *\n         * @param \\Illuminate\\Validation\\PresenceVerifierInterface $presenceVerifier\n         * @return void\n         * @static\n         */        public static function setPresenceVerifier($presenceVerifier)\n        {\n                        /** @var \\Illuminate\\Validation\\Factory $instance */\n                        $instance->setPresenceVerifier($presenceVerifier);\n        }\n            }\n\n    /**\n     *\n     *\n     * @see \\Illuminate\\View\\Factory\n     */    class View {\n\n        /**\n         * Get the evaluated view contents for the given view.\n         *\n         * @param string $path\n         * @param \\Illuminate\\Contracts\\Support\\Arrayable|array $data\n         * @param array $mergeData\n         * @return \\Illuminate\\Contracts\\View\\View\n         * @static\n         */        public static function file($path, $data = [], $mergeData = [])\n        {\n                        /** @var \\Illuminate\\View\\Factory $instance */\n                        return $instance->file($path, $data, $mergeData);\n        }\n\n        /**\n         * Get the evaluated view contents for the given view.\n         *\n         * @param string $view\n         * @param \\Illuminate\\Contracts\\Support\\Arrayable|array $data\n         * @param array $mergeData\n         * @return \\Illuminate\\Contracts\\View\\View\n         * @static\n         */        public static function make($view, $data = [], $mergeData = [])\n        {\n                        /** @var \\Illuminate\\View\\Factory $instance */\n                        return $instance->make($view, $data, $mergeData);\n        }\n\n        /**\n         * Get the first view that actually exists from the given list.\n         *\n         * @param array $views\n         * @param \\Illuminate\\Contracts\\Support\\Arrayable|array $data\n         * @param array $mergeData\n         * @return \\Illuminate\\Contracts\\View\\View\n         * @throws \\InvalidArgumentException\n         * @static\n         */        public static function first($views, $data = [], $mergeData = [])\n        {\n                        /** @var \\Illuminate\\View\\Factory $instance */\n                        return $instance->first($views, $data, $mergeData);\n        }\n\n        /**\n         * Get the rendered content of the view based on a given condition.\n         *\n         * @param bool $condition\n         * @param string $view\n         * @param \\Illuminate\\Contracts\\Support\\Arrayable|array $data\n         * @param array $mergeData\n         * @return string\n         * @static\n         */        public static function renderWhen($condition, $view, $data = [], $mergeData = [])\n        {\n                        /** @var \\Illuminate\\View\\Factory $instance */\n                        return $instance->renderWhen($condition, $view, $data, $mergeData);\n        }\n\n        /**\n         * Get the rendered contents of a partial from a loop.\n         *\n         * @param string $view\n         * @param array $data\n         * @param string $iterator\n         * @param string $empty\n         * @return string\n         * @static\n         */        public static function renderEach($view, $data, $iterator, $empty = \'raw|\')\n        {\n                        /** @var \\Illuminate\\View\\Factory $instance */\n                        return $instance->renderEach($view, $data, $iterator, $empty);\n        }\n\n        /**\n         * Determine if a given view exists.\n         *\n         * @param string $view\n         * @return bool\n         * @static\n         */        public static function exists($view)\n        {\n                        /** @var \\Illuminate\\View\\Factory $instance */\n                        return $instance->exists($view);\n        }\n\n        /**\n         * Get the appropriate view engine for the given path.\n         *\n         * @param string $path\n         * @return \\Illuminate\\Contracts\\View\\Engine\n         * @throws \\InvalidArgumentException\n         * @static\n         */        public static function getEngineFromPath($path)\n        {\n                        /** @var \\Illuminate\\View\\Factory $instance */\n                        return $instance->getEngineFromPath($path);\n        }\n\n        /**\n         * Add a piece of shared data to the environment.\n         *\n         * @param array|string $key\n         * @param mixed|null $value\n         * @return mixed\n         * @static\n         */        public static function share($key, $value = null)\n        {\n                        /** @var \\Illuminate\\View\\Factory $instance */\n                        return $instance->share($key, $value);\n        }\n\n        /**\n         * Increment the rendering counter.\n         *\n         * @return void\n         * @static\n         */        public static function incrementRender()\n        {\n                        /** @var \\Illuminate\\View\\Factory $instance */\n                        $instance->incrementRender();\n        }\n\n        /**\n         * Decrement the rendering counter.\n         *\n         * @return void\n         * @static\n         */        public static function decrementRender()\n        {\n                        /** @var \\Illuminate\\View\\Factory $instance */\n                        $instance->decrementRender();\n        }\n\n        /**\n         * Check if there are no active render operations.\n         *\n         * @return bool\n         * @static\n         */        public static function doneRendering()\n        {\n                        /** @var \\Illuminate\\View\\Factory $instance */\n                        return $instance->doneRendering();\n        }\n\n        /**\n         * Add a location to the array of view locations.\n         *\n         * @param string $location\n         * @return void\n         * @static\n         */        public static function addLocation($location)\n        {\n                        /** @var \\Illuminate\\View\\Factory $instance */\n                        $instance->addLocation($location);\n        }\n\n        /**\n         * Add a new namespace to the loader.\n         *\n         * @param string $namespace\n         * @param string|array $hints\n         * @return \\Illuminate\\View\\Factory\n         * @static\n         */        public static function addNamespace($namespace, $hints)\n        {\n                        /** @var \\Illuminate\\View\\Factory $instance */\n                        return $instance->addNamespace($namespace, $hints);\n        }\n\n        /**\n         * Prepend a new namespace to the loader.\n         *\n         * @param string $namespace\n         * @param string|array $hints\n         * @return \\Illuminate\\View\\Factory\n         * @static\n         */        public static function prependNamespace($namespace, $hints)\n        {\n                        /** @var \\Illuminate\\View\\Factory $instance */\n                        return $instance->prependNamespace($namespace, $hints);\n        }\n\n        /**\n         * Replace the namespace hints for the given namespace.\n         *\n         * @param string $namespace\n         * @param string|array $hints\n         * @return \\Illuminate\\View\\Factory\n         * @static\n         */        public static function replaceNamespace($namespace, $hints)\n        {\n                        /** @var \\Illuminate\\View\\Factory $instance */\n                        return $instance->replaceNamespace($namespace, $hints);\n        }\n\n        /**\n         * Register a valid view extension and its engine.\n         *\n         * @param string $extension\n         * @param string $engine\n         * @param \\Closure|null $resolver\n         * @return void\n         * @static\n         */        public static function addExtension($extension, $engine, $resolver = null)\n        {\n                        /** @var \\Illuminate\\View\\Factory $instance */\n                        $instance->addExtension($extension, $engine, $resolver);\n        }\n\n        /**\n         * Flush all of the factory state like sections and stacks.\n         *\n         * @return void\n         * @static\n         */        public static function flushState()\n        {\n                        /** @var \\Illuminate\\View\\Factory $instance */\n                        $instance->flushState();\n        }\n\n        /**\n         * Flush all of the section contents if done rendering.\n         *\n         * @return void\n         * @static\n         */        public static function flushStateIfDoneRendering()\n        {\n                        /** @var \\Illuminate\\View\\Factory $instance */\n                        $instance->flushStateIfDoneRendering();\n        }\n\n        /**\n         * Get the extension to engine bindings.\n         *\n         * @return array\n         * @static\n         */        public static function getExtensions()\n        {\n                        /** @var \\Illuminate\\View\\Factory $instance */\n                        return $instance->getExtensions();\n        }\n\n        /**\n         * Get the engine resolver instance.\n         *\n         * @return \\Illuminate\\View\\Engines\\EngineResolver\n         * @static\n         */        public static function getEngineResolver()\n        {\n                        /** @var \\Illuminate\\View\\Factory $instance */\n                        return $instance->getEngineResolver();\n        }\n\n        /**\n         * Get the view finder instance.\n         *\n         * @return \\Illuminate\\View\\ViewFinderInterface\n         * @static\n         */        public static function getFinder()\n        {\n                        /** @var \\Illuminate\\View\\Factory $instance */\n                        return $instance->getFinder();\n        }\n\n        /**\n         * Set the view finder instance.\n         *\n         * @param \\Illuminate\\View\\ViewFinderInterface $finder\n         * @return void\n         * @static\n         */        public static function setFinder($finder)\n        {\n                        /** @var \\Illuminate\\View\\Factory $instance */\n                        $instance->setFinder($finder);\n        }\n\n        /**\n         * Flush the cache of views located by the finder.\n         *\n         * @return void\n         * @static\n         */        public static function flushFinderCache()\n        {\n                        /** @var \\Illuminate\\View\\Factory $instance */\n                        $instance->flushFinderCache();\n        }\n\n        /**\n         * Get the event dispatcher instance.\n         *\n         * @return \\Illuminate\\Contracts\\Events\\Dispatcher\n         * @static\n         */        public static function getDispatcher()\n        {\n                        /** @var \\Illuminate\\View\\Factory $instance */\n                        return $instance->getDispatcher();\n        }\n\n        /**\n         * Set the event dispatcher instance.\n         *\n         * @param \\Illuminate\\Contracts\\Events\\Dispatcher $events\n         * @return void\n         * @static\n         */        public static function setDispatcher($events)\n        {\n                        /** @var \\Illuminate\\View\\Factory $instance */\n                        $instance->setDispatcher($events);\n        }\n\n        /**\n         * Get the IoC container instance.\n         *\n         * @return \\Illuminate\\Contracts\\Container\\Container\n         * @static\n         */        public static function getContainer()\n        {\n                        /** @var \\Illuminate\\View\\Factory $instance */\n                        return $instance->getContainer();\n        }\n\n        /**\n         * Set the IoC container instance.\n         *\n         * @param \\Illuminate\\Contracts\\Container\\Container $container\n         * @return void\n         * @static\n         */        public static function setContainer($container)\n        {\n                        /** @var \\Illuminate\\View\\Factory $instance */\n                        $instance->setContainer($container);\n        }\n\n        /**\n         * Get an item from the shared data.\n         *\n         * @param string $key\n         * @param mixed $default\n         * @return mixed\n         * @static\n         */        public static function shared($key, $default = null)\n        {\n                        /** @var \\Illuminate\\View\\Factory $instance */\n                        return $instance->shared($key, $default);\n        }\n\n        /**\n         * Get all of the shared data for the environment.\n         *\n         * @return array\n         * @static\n         */        public static function getShared()\n        {\n                        /** @var \\Illuminate\\View\\Factory $instance */\n                        return $instance->getShared();\n        }\n\n        /**\n         * Register a custom macro.\n         *\n         * @param string $name\n         * @param object|callable $macro\n         * @return void\n         * @static\n         */        public static function macro($name, $macro)\n        {\n                        \\Illuminate\\View\\Factory::macro($name, $macro);\n        }\n\n        /**\n         * Mix another object into the class.\n         *\n         * @param object $mixin\n         * @param bool $replace\n         * @return void\n         * @throws \\ReflectionException\n         * @static\n         */        public static function mixin($mixin, $replace = true)\n        {\n                        \\Illuminate\\View\\Factory::mixin($mixin, $replace);\n        }\n\n        /**\n         * Checks if macro is registered.\n         *\n         * @param string $name\n         * @return bool\n         * @static\n         */        public static function hasMacro($name)\n        {\n                        return \\Illuminate\\View\\Factory::hasMacro($name);\n        }\n\n        /**\n         * Start a component rendering process.\n         *\n         * @param \\Illuminate\\View\\View|string $view\n         * @param array $data\n         * @return void\n         * @static\n         */        public static function startComponent($view, $data = [])\n        {\n                        /** @var \\Illuminate\\View\\Factory $instance */\n                        $instance->startComponent($view, $data);\n        }\n\n        /**\n         * Get the first view that actually exists from the given list, and start a component.\n         *\n         * @param array $names\n         * @param array $data\n         * @return void\n         * @static\n         */        public static function startComponentFirst($names, $data = [])\n        {\n                        /** @var \\Illuminate\\View\\Factory $instance */\n                        $instance->startComponentFirst($names, $data);\n        }\n\n        /**\n         * Render the current component.\n         *\n         * @return string\n         * @static\n         */        public static function renderComponent()\n        {\n                        /** @var \\Illuminate\\View\\Factory $instance */\n                        return $instance->renderComponent();\n        }\n\n        /**\n         * Start the slot rendering process.\n         *\n         * @param string $name\n         * @param string|null $content\n         * @return void\n         * @static\n         */        public static function slot($name, $content = null)\n        {\n                        /** @var \\Illuminate\\View\\Factory $instance */\n                        $instance->slot($name, $content);\n        }\n\n        /**\n         * Save the slot content for rendering.\n         *\n         * @return void\n         * @static\n         */        public static function endSlot()\n        {\n                        /** @var \\Illuminate\\View\\Factory $instance */\n                        $instance->endSlot();\n        }\n\n        /**\n         * Register a view creator event.\n         *\n         * @param array|string $views\n         * @param \\Closure|string $callback\n         * @return array\n         * @static\n         */        public static function creator($views, $callback)\n        {\n                        /** @var \\Illuminate\\View\\Factory $instance */\n                        return $instance->creator($views, $callback);\n        }\n\n        /**\n         * Register multiple view composers via an array.\n         *\n         * @param array $composers\n         * @return array\n         * @static\n         */        public static function composers($composers)\n        {\n                        /** @var \\Illuminate\\View\\Factory $instance */\n                        return $instance->composers($composers);\n        }\n\n        /**\n         * Register a view composer event.\n         *\n         * @param array|string $views\n         * @param \\Closure|string $callback\n         * @return array\n         * @static\n         */        public static function composer($views, $callback)\n        {\n                        /** @var \\Illuminate\\View\\Factory $instance */\n                        return $instance->composer($views, $callback);\n        }\n\n        /**\n         * Call the composer for a given view.\n         *\n         * @param \\Illuminate\\Contracts\\View\\View $view\n         * @return void\n         * @static\n         */        public static function callComposer($view)\n        {\n                        /** @var \\Illuminate\\View\\Factory $instance */\n                        $instance->callComposer($view);\n        }\n\n        /**\n         * Call the creator for a given view.\n         *\n         * @param \\Illuminate\\Contracts\\View\\View $view\n         * @return void\n         * @static\n         */        public static function callCreator($view)\n        {\n                        /** @var \\Illuminate\\View\\Factory $instance */\n                        $instance->callCreator($view);\n        }\n\n        /**\n         * Start injecting content into a section.\n         *\n         * @param string $section\n         * @param string|null $content\n         * @return void\n         * @static\n         */        public static function startSection($section, $content = null)\n        {\n                        /** @var \\Illuminate\\View\\Factory $instance */\n                        $instance->startSection($section, $content);\n        }\n\n        /**\n         * Inject inline content into a section.\n         *\n         * @param string $section\n         * @param string $content\n         * @return void\n         * @static\n         */        public static function inject($section, $content)\n        {\n                        /** @var \\Illuminate\\View\\Factory $instance */\n                        $instance->inject($section, $content);\n        }\n\n        /**\n         * Stop injecting content into a section and return its contents.\n         *\n         * @return string\n         * @static\n         */        public static function yieldSection()\n        {\n                        /** @var \\Illuminate\\View\\Factory $instance */\n                        return $instance->yieldSection();\n        }\n\n        /**\n         * Stop injecting content into a section.\n         *\n         * @param bool $overwrite\n         * @return string\n         * @throws \\InvalidArgumentException\n         * @static\n         */        public static function stopSection($overwrite = false)\n        {\n                        /** @var \\Illuminate\\View\\Factory $instance */\n                        return $instance->stopSection($overwrite);\n        }\n\n        /**\n         * Stop injecting content into a section and append it.\n         *\n         * @return string\n         * @throws \\InvalidArgumentException\n         * @static\n         */        public static function appendSection()\n        {\n                        /** @var \\Illuminate\\View\\Factory $instance */\n                        return $instance->appendSection();\n        }\n\n        /**\n         * Get the string contents of a section.\n         *\n         * @param string $section\n         * @param string $default\n         * @return string\n         * @static\n         */        public static function yieldContent($section, $default = \'\')\n        {\n                        /** @var \\Illuminate\\View\\Factory $instance */\n                        return $instance->yieldContent($section, $default);\n        }\n\n        /**\n         * Get the parent placeholder for the current request.\n         *\n         * @param string $section\n         * @return string\n         * @static\n         */        public static function parentPlaceholder($section = \'\')\n        {\n                        return \\Illuminate\\View\\Factory::parentPlaceholder($section);\n        }\n\n        /**\n         * Check if section exists.\n         *\n         * @param string $name\n         * @return bool\n         * @static\n         */        public static function hasSection($name)\n        {\n                        /** @var \\Illuminate\\View\\Factory $instance */\n                        return $instance->hasSection($name);\n        }\n\n        /**\n         * Get the contents of a section.\n         *\n         * @param string $name\n         * @param string|null $default\n         * @return mixed\n         * @static\n         */        public static function getSection($name, $default = null)\n        {\n                        /** @var \\Illuminate\\View\\Factory $instance */\n                        return $instance->getSection($name, $default);\n        }\n\n        /**\n         * Get the entire array of sections.\n         *\n         * @return array\n         * @static\n         */        public static function getSections()\n        {\n                        /** @var \\Illuminate\\View\\Factory $instance */\n                        return $instance->getSections();\n        }\n\n        /**\n         * Flush all of the sections.\n         *\n         * @return void\n         * @static\n         */        public static function flushSections()\n        {\n                        /** @var \\Illuminate\\View\\Factory $instance */\n                        $instance->flushSections();\n        }\n\n        /**\n         * Add new loop to the stack.\n         *\n         * @param \\Countable|array $data\n         * @return void\n         * @static\n         */        public static function addLoop($data)\n        {\n                        /** @var \\Illuminate\\View\\Factory $instance */\n                        $instance->addLoop($data);\n        }\n\n        /**\n         * Increment the top loop\'s indices.\n         *\n         * @return void\n         * @static\n         */        public static function incrementLoopIndices()\n        {\n                        /** @var \\Illuminate\\View\\Factory $instance */\n                        $instance->incrementLoopIndices();\n        }\n\n        /**\n         * Pop a loop from the top of the loop stack.\n         *\n         * @return void\n         * @static\n         */        public static function popLoop()\n        {\n                        /** @var \\Illuminate\\View\\Factory $instance */\n                        $instance->popLoop();\n        }\n\n        /**\n         * Get an instance of the last loop in the stack.\n         *\n         * @return \\stdClass|null\n         * @static\n         */        public static function getLastLoop()\n        {\n                        /** @var \\Illuminate\\View\\Factory $instance */\n                        return $instance->getLastLoop();\n        }\n\n        /**\n         * Get the entire loop stack.\n         *\n         * @return array\n         * @static\n         */        public static function getLoopStack()\n        {\n                        /** @var \\Illuminate\\View\\Factory $instance */\n                        return $instance->getLoopStack();\n        }\n\n        /**\n         * Start injecting content into a push section.\n         *\n         * @param string $section\n         * @param string $content\n         * @return void\n         * @static\n         */        public static function startPush($section, $content = \'\')\n        {\n                        /** @var \\Illuminate\\View\\Factory $instance */\n                        $instance->startPush($section, $content);\n        }\n\n        /**\n         * Stop injecting content into a push section.\n         *\n         * @return string\n         * @throws \\InvalidArgumentException\n         * @static\n         */        public static function stopPush()\n        {\n                        /** @var \\Illuminate\\View\\Factory $instance */\n                        return $instance->stopPush();\n        }\n\n        /**\n         * Start prepending content into a push section.\n         *\n         * @param string $section\n         * @param string $content\n         * @return void\n         * @static\n         */        public static function startPrepend($section, $content = \'\')\n        {\n                        /** @var \\Illuminate\\View\\Factory $instance */\n                        $instance->startPrepend($section, $content);\n        }\n\n        /**\n         * Stop prepending content into a push section.\n         *\n         * @return string\n         * @throws \\InvalidArgumentException\n         * @static\n         */        public static function stopPrepend()\n        {\n                        /** @var \\Illuminate\\View\\Factory $instance */\n                        return $instance->stopPrepend();\n        }\n\n        /**\n         * Get the string contents of a push section.\n         *\n         * @param string $section\n         * @param string $default\n         * @return string\n         * @static\n         */        public static function yieldPushContent($section, $default = \'\')\n        {\n                        /** @var \\Illuminate\\View\\Factory $instance */\n                        return $instance->yieldPushContent($section, $default);\n        }\n\n        /**\n         * Flush all of the stacks.\n         *\n         * @return void\n         * @static\n         */        public static function flushStacks()\n        {\n                        /** @var \\Illuminate\\View\\Factory $instance */\n                        $instance->flushStacks();\n        }\n\n        /**\n         * Start a translation block.\n         *\n         * @param array $replacements\n         * @return void\n         * @static\n         */        public static function startTranslation($replacements = [])\n        {\n                        /** @var \\Illuminate\\View\\Factory $instance */\n                        $instance->startTranslation($replacements);\n        }\n\n        /**\n         * Render the current translation.\n         *\n         * @return string\n         * @static\n         */        public static function renderTranslation()\n        {\n                        /** @var \\Illuminate\\View\\Factory $instance */\n                        return $instance->renderTranslation();\n        }\n            }\n}\n\nnamespace Illuminate\\Support {\n\n    /**\n     *\n     *\n     */    class Arr {\n            }\n\n    /**\n     *\n     *\n     */    class Str {\n            }\n}\n\nnamespace Barryvdh\\Debugbar {\n\n    /**\n     *\n     *\n     * @method static void alert(string $message)\n     * @method static void critical(string $message)\n     * @method static void debug(string $message)\n     * @method static void emergency(string $message)\n     * @method static void error(string $message)\n     * @method static void info(string $message)\n     * @method static void log(string $message)\n     * @method static void notice(string $message)\n     * @method static void warning(string $message)\n     * @see \\Barryvdh\\Debugbar\\LaravelDebugbar\n     */    class Facade {\n\n        /**\n         * Enable the Debugbar and boot, if not already booted.\n         *\n         * @static\n         */        public static function enable()\n        {\n                        /** @var \\Barryvdh\\Debugbar\\LaravelDebugbar $instance */\n                        return $instance->enable();\n        }\n\n        /**\n         * Boot the debugbar (add collectors, renderer and listener)\n         *\n         * @static\n         */        public static function boot()\n        {\n                        /** @var \\Barryvdh\\Debugbar\\LaravelDebugbar $instance */\n                        return $instance->boot();\n        }\n\n        /**\n         *\n         *\n         * @static\n         */        public static function shouldCollect($name, $default = false)\n        {\n                        /** @var \\Barryvdh\\Debugbar\\LaravelDebugbar $instance */\n                        return $instance->shouldCollect($name, $default);\n        }\n\n        /**\n         * Adds a data collector\n         *\n         * @param \\Barryvdh\\Debugbar\\DataCollectorInterface $collector\n         * @throws DebugBarException\n         * @return \\Barryvdh\\Debugbar\\LaravelDebugbar\n         * @static\n         */        public static function addCollector($collector)\n        {\n                        /** @var \\Barryvdh\\Debugbar\\LaravelDebugbar $instance */\n                        return $instance->addCollector($collector);\n        }\n\n        /**\n         * Handle silenced errors\n         *\n         * @param $level\n         * @param $message\n         * @param string $file\n         * @param int $line\n         * @param array $context\n         * @throws \\ErrorException\n         * @static\n         */        public static function handleError($level, $message, $file = \'\', $line = 0, $context = [])\n        {\n                        /** @var \\Barryvdh\\Debugbar\\LaravelDebugbar $instance */\n                        return $instance->handleError($level, $message, $file, $line, $context);\n        }\n\n        /**\n         * Starts a measure\n         *\n         * @param string $name Internal name, used to stop the measure\n         * @param string $label Public name\n         * @static\n         */        public static function startMeasure($name, $label = null)\n        {\n                        /** @var \\Barryvdh\\Debugbar\\LaravelDebugbar $instance */\n                        return $instance->startMeasure($name, $label);\n        }\n\n        /**\n         * Stops a measure\n         *\n         * @param string $name\n         * @static\n         */        public static function stopMeasure($name)\n        {\n                        /** @var \\Barryvdh\\Debugbar\\LaravelDebugbar $instance */\n                        return $instance->stopMeasure($name);\n        }\n\n        /**\n         * Adds an exception to be profiled in the debug bar\n         *\n         * @param \\Exception $e\n         * @deprecated in favor of addThrowable\n         * @static\n         */        public static function addException($e)\n        {\n                        /** @var \\Barryvdh\\Debugbar\\LaravelDebugbar $instance */\n                        return $instance->addException($e);\n        }\n\n        /**\n         * Adds an exception to be profiled in the debug bar\n         *\n         * @param \\Exception $e\n         * @static\n         */        public static function addThrowable($e)\n        {\n                        /** @var \\Barryvdh\\Debugbar\\LaravelDebugbar $instance */\n                        return $instance->addThrowable($e);\n        }\n\n        /**\n         * Returns a JavascriptRenderer for this instance\n         *\n         * @param string $baseUrl\n         * @param string $basePathng\n         * @return \\Barryvdh\\Debugbar\\JavascriptRenderer\n         * @static\n         */        public static function getJavascriptRenderer($baseUrl = null, $basePath = null)\n        {\n                        /** @var \\Barryvdh\\Debugbar\\LaravelDebugbar $instance */\n                        return $instance->getJavascriptRenderer($baseUrl, $basePath);\n        }\n\n        /**\n         * Modify the response and inject the debugbar (or data in headers)\n         *\n         * @param \\Symfony\\Component\\HttpFoundation\\Request $request\n         * @param \\Symfony\\Component\\HttpFoundation\\Response $response\n         * @return \\Symfony\\Component\\HttpFoundation\\Response\n         * @static\n         */        public static function modifyResponse($request, $response)\n        {\n                        /** @var \\Barryvdh\\Debugbar\\LaravelDebugbar $instance */\n                        return $instance->modifyResponse($request, $response);\n        }\n\n        /**\n         * Check if the Debugbar is enabled\n         *\n         * @return boolean\n         * @static\n         */        public static function isEnabled()\n        {\n                        /** @var \\Barryvdh\\Debugbar\\LaravelDebugbar $instance */\n                        return $instance->isEnabled();\n        }\n\n        /**\n         * Collects the data from the collectors\n         *\n         * @return array\n         * @static\n         */        public static function collect()\n        {\n                        /** @var \\Barryvdh\\Debugbar\\LaravelDebugbar $instance */\n                        return $instance->collect();\n        }\n\n        /**\n         * Injects the web debug toolbar into the given Response.\n         *\n         * @param \\Symfony\\Component\\HttpFoundation\\Response $response A Response instance\n         * Based on https://github.com/symfony/WebProfilerBundle/blob/master/EventListener/WebDebugToolbarListener.php\n         * @static\n         */        public static function injectDebugbar($response)\n        {\n                        /** @var \\Barryvdh\\Debugbar\\LaravelDebugbar $instance */\n                        return $instance->injectDebugbar($response);\n        }\n\n        /**\n         * Disable the Debugbar\n         *\n         * @static\n         */        public static function disable()\n        {\n                        /** @var \\Barryvdh\\Debugbar\\LaravelDebugbar $instance */\n                        return $instance->disable();\n        }\n\n        /**\n         * Adds a measure\n         *\n         * @param string $label\n         * @param float $start\n         * @param float $end\n         * @static\n         */        public static function addMeasure($label, $start, $end)\n        {\n                        /** @var \\Barryvdh\\Debugbar\\LaravelDebugbar $instance */\n                        return $instance->addMeasure($label, $start, $end);\n        }\n\n        /**\n         * Utility function to measure the execution of a Closure\n         *\n         * @param string $label\n         * @param \\Closure $closure\n         * @static\n         */        public static function measure($label, $closure)\n        {\n                        /** @var \\Barryvdh\\Debugbar\\LaravelDebugbar $instance */\n                        return $instance->measure($label, $closure);\n        }\n\n        /**\n         * Collect data in a CLI request\n         *\n         * @return array\n         * @static\n         */        public static function collectConsole()\n        {\n                        /** @var \\Barryvdh\\Debugbar\\LaravelDebugbar $instance */\n                        return $instance->collectConsole();\n        }\n\n        /**\n         * Adds a message to the MessagesCollector\n         *\n         * A message can be anything from an object to a string\n         *\n         * @param mixed $message\n         * @param string $label\n         * @static\n         */        public static function addMessage($message, $label = \'info\')\n        {\n                        /** @var \\Barryvdh\\Debugbar\\LaravelDebugbar $instance */\n                        return $instance->addMessage($message, $label);\n        }\n\n        /**\n         * Checks if a data collector has been added\n         *\n         * @param string $name\n         * @return boolean\n         * @static\n         */        public static function hasCollector($name)\n        {\n            //Method inherited from \\DebugBar\\DebugBar\n                        /** @var \\Barryvdh\\Debugbar\\LaravelDebugbar $instance */\n                        return $instance->hasCollector($name);\n        }\n\n        /**\n         * Returns a data collector\n         *\n         * @param string $name\n         * @return \\DebugBar\\DataCollectorInterface\n         * @throws DebugBarException\n         * @static\n         */        public static function getCollector($name)\n        {\n            //Method inherited from \\DebugBar\\DebugBar\n                        /** @var \\Barryvdh\\Debugbar\\LaravelDebugbar $instance */\n                        return $instance->getCollector($name);\n        }\n\n        /**\n         * Returns an array of all data collectors\n         *\n         * @return \\DebugBar\\array[DataCollectorInterface]\n         * @static\n         */        public static function getCollectors()\n        {\n            //Method inherited from \\DebugBar\\DebugBar\n                        /** @var \\Barryvdh\\Debugbar\\LaravelDebugbar $instance */\n                        return $instance->getCollectors();\n        }\n\n        /**\n         * Sets the request id generator\n         *\n         * @param \\DebugBar\\RequestIdGeneratorInterface $generator\n         * @return \\Barryvdh\\Debugbar\\LaravelDebugbar\n         * @static\n         */        public static function setRequestIdGenerator($generator)\n        {\n            //Method inherited from \\DebugBar\\DebugBar\n                        /** @var \\Barryvdh\\Debugbar\\LaravelDebugbar $instance */\n                        return $instance->setRequestIdGenerator($generator);\n        }\n\n        /**\n         *\n         *\n         * @return \\DebugBar\\RequestIdGeneratorInterface\n         * @static\n         */        public static function getRequestIdGenerator()\n        {\n            //Method inherited from \\DebugBar\\DebugBar\n                        /** @var \\Barryvdh\\Debugbar\\LaravelDebugbar $instance */\n                        return $instance->getRequestIdGenerator();\n        }\n\n        /**\n         * Returns the id of the current request\n         *\n         * @return string\n         * @static\n         */        public static function getCurrentRequestId()\n        {\n            //Method inherited from \\DebugBar\\DebugBar\n                        /** @var \\Barryvdh\\Debugbar\\LaravelDebugbar $instance */\n                        return $instance->getCurrentRequestId();\n        }\n\n        /**\n         * Sets the storage backend to use to store the collected data\n         *\n         * @param \\DebugBar\\StorageInterface $storage\n         * @return \\Barryvdh\\Debugbar\\LaravelDebugbar\n         * @static\n         */        public static function setStorage($storage = null)\n        {\n            //Method inherited from \\DebugBar\\DebugBar\n                        /** @var \\Barryvdh\\Debugbar\\LaravelDebugbar $instance */\n                        return $instance->setStorage($storage);\n        }\n\n        /**\n         *\n         *\n         * @return \\DebugBar\\StorageInterface\n         * @static\n         */        public static function getStorage()\n        {\n            //Method inherited from \\DebugBar\\DebugBar\n                        /** @var \\Barryvdh\\Debugbar\\LaravelDebugbar $instance */\n                        return $instance->getStorage();\n        }\n\n        /**\n         * Checks if the data will be persisted\n         *\n         * @return boolean\n         * @static\n         */        public static function isDataPersisted()\n        {\n            //Method inherited from \\DebugBar\\DebugBar\n                        /** @var \\Barryvdh\\Debugbar\\LaravelDebugbar $instance */\n                        return $instance->isDataPersisted();\n        }\n\n        /**\n         * Sets the HTTP driver\n         *\n         * @param \\DebugBar\\HttpDriverInterface $driver\n         * @return \\Barryvdh\\Debugbar\\LaravelDebugbar\n         * @static\n         */        public static function setHttpDriver($driver)\n        {\n            //Method inherited from \\DebugBar\\DebugBar\n                        /** @var \\Barryvdh\\Debugbar\\LaravelDebugbar $instance */\n                        return $instance->setHttpDriver($driver);\n        }\n\n        /**\n         * Returns the HTTP driver\n         *\n         * If no http driver where defined, a PhpHttpDriver is automatically created\n         *\n         * @return \\DebugBar\\HttpDriverInterface\n         * @static\n         */        public static function getHttpDriver()\n        {\n            //Method inherited from \\DebugBar\\DebugBar\n                        /** @var \\Barryvdh\\Debugbar\\LaravelDebugbar $instance */\n                        return $instance->getHttpDriver();\n        }\n\n        /**\n         * Returns collected data\n         *\n         * Will collect the data if none have been collected yet\n         *\n         * @return array\n         * @static\n         */        public static function getData()\n        {\n            //Method inherited from \\DebugBar\\DebugBar\n                        /** @var \\Barryvdh\\Debugbar\\LaravelDebugbar $instance */\n                        return $instance->getData();\n        }\n\n        /**\n         * Returns an array of HTTP headers containing the data\n         *\n         * @param string $headerName\n         * @param integer $maxHeaderLength\n         * @return array\n         * @static\n         */        public static function getDataAsHeaders($headerName = \'phpdebugbar\', $maxHeaderLength = 4096, $maxTotalHeaderLength = 250000)\n        {\n            //Method inherited from \\DebugBar\\DebugBar\n                        /** @var \\Barryvdh\\Debugbar\\LaravelDebugbar $instance */\n                        return $instance->getDataAsHeaders($headerName, $maxHeaderLength, $maxTotalHeaderLength);\n        }\n\n        /**\n         * Sends the data through the HTTP headers\n         *\n         * @param bool $useOpenHandler\n         * @param string $headerName\n         * @param integer $maxHeaderLength\n         * @return \\Barryvdh\\Debugbar\\LaravelDebugbar\n         * @static\n         */        public static function sendDataInHeaders($useOpenHandler = null, $headerName = \'phpdebugbar\', $maxHeaderLength = 4096)\n        {\n            //Method inherited from \\DebugBar\\DebugBar\n                        /** @var \\Barryvdh\\Debugbar\\LaravelDebugbar $instance */\n                        return $instance->sendDataInHeaders($useOpenHandler, $headerName, $maxHeaderLength);\n        }\n\n        /**\n         * Stacks the data in the session for later rendering\n         *\n         * @static\n         */        public static function stackData()\n        {\n            //Method inherited from \\DebugBar\\DebugBar\n                        /** @var \\Barryvdh\\Debugbar\\LaravelDebugbar $instance */\n                        return $instance->stackData();\n        }\n\n        /**\n         * Checks if there is stacked data in the session\n         *\n         * @return boolean\n         * @static\n         */        public static function hasStackedData()\n        {\n            //Method inherited from \\DebugBar\\DebugBar\n                        /** @var \\Barryvdh\\Debugbar\\LaravelDebugbar $instance */\n                        return $instance->hasStackedData();\n        }\n\n        /**\n         * Returns the data stacked in the session\n         *\n         * @param boolean $delete Whether to delete the data in the session\n         * @return array\n         * @static\n         */        public static function getStackedData($delete = true)\n        {\n            //Method inherited from \\DebugBar\\DebugBar\n                        /** @var \\Barryvdh\\Debugbar\\LaravelDebugbar $instance */\n                        return $instance->getStackedData($delete);\n        }\n\n        /**\n         * Sets the key to use in the $_SESSION array\n         *\n         * @param string $ns\n         * @return \\Barryvdh\\Debugbar\\LaravelDebugbar\n         * @static\n         */        public static function setStackDataSessionNamespace($ns)\n        {\n            //Method inherited from \\DebugBar\\DebugBar\n                        /** @var \\Barryvdh\\Debugbar\\LaravelDebugbar $instance */\n                        return $instance->setStackDataSessionNamespace($ns);\n        }\n\n        /**\n         * Returns the key used in the $_SESSION array\n         *\n         * @return string\n         * @static\n         */        public static function getStackDataSessionNamespace()\n        {\n            //Method inherited from \\DebugBar\\DebugBar\n                        /** @var \\Barryvdh\\Debugbar\\LaravelDebugbar $instance */\n                        return $instance->getStackDataSessionNamespace();\n        }\n\n        /**\n         * Sets whether to only use the session to store stacked data even\n         * if a storage is enabled\n         *\n         * @param boolean $enabled\n         * @return \\Barryvdh\\Debugbar\\LaravelDebugbar\n         * @static\n         */        public static function setStackAlwaysUseSessionStorage($enabled = true)\n        {\n            //Method inherited from \\DebugBar\\DebugBar\n                        /** @var \\Barryvdh\\Debugbar\\LaravelDebugbar $instance */\n                        return $instance->setStackAlwaysUseSessionStorage($enabled);\n        }\n\n        /**\n         * Checks if the session is always used to store stacked data\n         * even if a storage is enabled\n         *\n         * @return boolean\n         * @static\n         */        public static function isStackAlwaysUseSessionStorage()\n        {\n            //Method inherited from \\DebugBar\\DebugBar\n                        /** @var \\Barryvdh\\Debugbar\\LaravelDebugbar $instance */\n                        return $instance->isStackAlwaysUseSessionStorage();\n        }\n\n        /**\n         *\n         *\n         * @static\n         */        public static function offsetSet($key, $value)\n        {\n            //Method inherited from \\DebugBar\\DebugBar\n                        /** @var \\Barryvdh\\Debugbar\\LaravelDebugbar $instance */\n                        return $instance->offsetSet($key, $value);\n        }\n\n        /**\n         *\n         *\n         * @static\n         */        public static function offsetGet($key)\n        {\n            //Method inherited from \\DebugBar\\DebugBar\n                        /** @var \\Barryvdh\\Debugbar\\LaravelDebugbar $instance */\n                        return $instance->offsetGet($key);\n        }\n\n        /**\n         *\n         *\n         * @static\n         */        public static function offsetExists($key)\n        {\n            //Method inherited from \\DebugBar\\DebugBar\n                        /** @var \\Barryvdh\\Debugbar\\LaravelDebugbar $instance */\n                        return $instance->offsetExists($key);\n        }\n\n        /**\n         *\n         *\n         * @static\n         */        public static function offsetUnset($key)\n        {\n            //Method inherited from \\DebugBar\\DebugBar\n                        /** @var \\Barryvdh\\Debugbar\\LaravelDebugbar $instance */\n                        return $instance->offsetUnset($key);\n        }\n            }\n}\n\nnamespace Facade\\Ignition\\Facades {\n\n    /**\n     * Class Flare.\n     *\n     * @see \\Facade\\FlareClient\\Flare\n     */    class Flare {\n\n        /**\n         *\n         *\n         * @static\n         */        public static function register($apiKey, $apiSecret = null, $contextDetector = null, $container = null)\n        {\n                        return \\Facade\\FlareClient\\Flare::register($apiKey, $apiSecret, $contextDetector, $container);\n        }\n\n        /**\n         *\n         *\n         * @static\n         */        public static function getMiddleware()\n        {\n                        /** @var \\Facade\\FlareClient\\Flare $instance */\n                        return $instance->getMiddleware();\n        }\n\n        /**\n         *\n         *\n         * @static\n         */        public static function registerFlareHandlers()\n        {\n                        /** @var \\Facade\\FlareClient\\Flare $instance */\n                        return $instance->registerFlareHandlers();\n        }\n\n        /**\n         *\n         *\n         * @static\n         */        public static function registerExceptionHandler()\n        {\n                        /** @var \\Facade\\FlareClient\\Flare $instance */\n                        return $instance->registerExceptionHandler();\n        }\n\n        /**\n         *\n         *\n         * @static\n         */        public static function registerErrorHandler()\n        {\n                        /** @var \\Facade\\FlareClient\\Flare $instance */\n                        return $instance->registerErrorHandler();\n        }\n\n        /**\n         *\n         *\n         * @static\n         */        public static function registerMiddleware($callable)\n        {\n                        /** @var \\Facade\\FlareClient\\Flare $instance */\n                        return $instance->registerMiddleware($callable);\n        }\n\n        /**\n         *\n         *\n         * @static\n         */        public static function getMiddlewares()\n        {\n                        /** @var \\Facade\\FlareClient\\Flare $instance */\n                        return $instance->getMiddlewares();\n        }\n\n        /**\n         *\n         *\n         * @static\n         */        public static function glow($name, $messageLevel = \'info\', $metaData = [])\n        {\n                        /** @var \\Facade\\FlareClient\\Flare $instance */\n                        return $instance->glow($name, $messageLevel, $metaData);\n        }\n\n        /**\n         *\n         *\n         * @static\n         */        public static function handleException($throwable)\n        {\n                        /** @var \\Facade\\FlareClient\\Flare $instance */\n                        return $instance->handleException($throwable);\n        }\n\n        /**\n         *\n         *\n         * @static\n         */        public static function handleError($code, $message, $file = \'\', $line = 0)\n        {\n                        /** @var \\Facade\\FlareClient\\Flare $instance */\n                        return $instance->handleError($code, $message, $file, $line);\n        }\n\n        /**\n         *\n         *\n         * @static\n         */        public static function applicationPath($applicationPath)\n        {\n                        /** @var \\Facade\\FlareClient\\Flare $instance */\n                        return $instance->applicationPath($applicationPath);\n        }\n\n        /**\n         *\n         *\n         * @static\n         */        public static function report($throwable, $callback = null)\n        {\n                        /** @var \\Facade\\FlareClient\\Flare $instance */\n                        return $instance->report($throwable, $callback);\n        }\n\n        /**\n         *\n         *\n         * @static\n         */        public static function reportMessage($message, $logLevel, $callback = null)\n        {\n                        /** @var \\Facade\\FlareClient\\Flare $instance */\n                        return $instance->reportMessage($message, $logLevel, $callback);\n        }\n\n        /**\n         *\n         *\n         * @static\n         */        public static function sendTestReport($throwable)\n        {\n                        /** @var \\Facade\\FlareClient\\Flare $instance */\n                        return $instance->sendTestReport($throwable);\n        }\n\n        /**\n         *\n         *\n         * @static\n         */        public static function reset()\n        {\n                        /** @var \\Facade\\FlareClient\\Flare $instance */\n                        return $instance->reset();\n        }\n\n        /**\n         *\n         *\n         * @static\n         */        public static function anonymizeIp()\n        {\n                        /** @var \\Facade\\FlareClient\\Flare $instance */\n                        return $instance->anonymizeIp();\n        }\n\n        /**\n         *\n         *\n         * @static\n         */        public static function createReport($throwable)\n        {\n                        /** @var \\Facade\\FlareClient\\Flare $instance */\n                        return $instance->createReport($throwable);\n        }\n\n        /**\n         *\n         *\n         * @static\n         */        public static function createReportFromMessage($message, $logLevel)\n        {\n                        /** @var \\Facade\\FlareClient\\Flare $instance */\n                        return $instance->createReportFromMessage($message, $logLevel);\n        }\n\n        /**\n         *\n         *\n         * @static\n         */        public static function stage($stage)\n        {\n                        /** @var \\Facade\\FlareClient\\Flare $instance */\n                        return $instance->stage($stage);\n        }\n\n        /**\n         *\n         *\n         * @static\n         */        public static function messageLevel($messageLevel)\n        {\n                        /** @var \\Facade\\FlareClient\\Flare $instance */\n                        return $instance->messageLevel($messageLevel);\n        }\n\n        /**\n         *\n         *\n         * @static\n         */        public static function getGroup($groupName = \'context\', $default = [])\n        {\n                        /** @var \\Facade\\FlareClient\\Flare $instance */\n                        return $instance->getGroup($groupName, $default);\n        }\n\n        /**\n         *\n         *\n         * @static\n         */        public static function context($key, $value)\n        {\n                        /** @var \\Facade\\FlareClient\\Flare $instance */\n                        return $instance->context($key, $value);\n        }\n\n        /**\n         *\n         *\n         * @static\n         */        public static function group($groupName, $properties)\n        {\n                        /** @var \\Facade\\FlareClient\\Flare $instance */\n                        return $instance->group($groupName, $properties);\n        }\n            }\n}\n\n\nnamespace  {\n\n    class App extends \\Illuminate\\Support\\Facades\\App {}\n\n    class Arr extends \\Illuminate\\Support\\Arr {}\n\n    class Artisan extends \\Illuminate\\Support\\Facades\\Artisan {}\n\n    class Auth extends \\Illuminate\\Support\\Facades\\Auth {}\n\n    class Blade extends \\Illuminate\\Support\\Facades\\Blade {}\n\n    class Broadcast extends \\Illuminate\\Support\\Facades\\Broadcast {}\n\n    class Bus extends \\Illuminate\\Support\\Facades\\Bus {}\n\n    class Cache extends \\Illuminate\\Support\\Facades\\Cache {}\n\n    class Config extends \\Illuminate\\Support\\Facades\\Config {}\n\n    class Cookie extends \\Illuminate\\Support\\Facades\\Cookie {}\n\n    class Crypt extends \\Illuminate\\Support\\Facades\\Crypt {}\n\n    class DB extends \\Illuminate\\Support\\Facades\\DB {}\n\n    class Eloquent extends \\Illuminate\\Database\\Eloquent\\Model {                    /**\n             * Create and return an un-saved model instance.\n             *\n             * @param array $attributes\n             * @return \\Illuminate\\Database\\Eloquent\\Model|static\n             * @static\n             */            public static function make($attributes = [])\n            {\n                                /** @var \\Illuminate\\Database\\Eloquent\\Builder $instance */\n                                return $instance->make($attributes);\n            }\n                    /**\n             * Register a new global scope.\n             *\n             * @param string $identifier\n             * @param \\Illuminate\\Database\\Eloquent\\Scope|\\Closure $scope\n             * @return \\Illuminate\\Database\\Eloquent\\Builder\n             * @static\n             */            public static function withGlobalScope($identifier, $scope)\n            {\n                                /** @var \\Illuminate\\Database\\Eloquent\\Builder $instance */\n                                return $instance->withGlobalScope($identifier, $scope);\n            }\n                    /**\n             * Remove a registered global scope.\n             *\n             * @param \\Illuminate\\Database\\Eloquent\\Scope|string $scope\n             * @return \\Illuminate\\Database\\Eloquent\\Builder\n             * @static\n             */            public static function withoutGlobalScope($scope)\n            {\n                                /** @var \\Illuminate\\Database\\Eloquent\\Builder $instance */\n                                return $instance->withoutGlobalScope($scope);\n            }\n                    /**\n             * Remove all or passed registered global scopes.\n             *\n             * @param array|null $scopes\n             * @return \\Illuminate\\Database\\Eloquent\\Builder\n             * @static\n             */            public static function withoutGlobalScopes($scopes = null)\n            {\n                                /** @var \\Illuminate\\Database\\Eloquent\\Builder $instance */\n                                return $instance->withoutGlobalScopes($scopes);\n            }\n                    /**\n             * Get an array of global scopes that were removed from the query.\n             *\n             * @return array\n             * @static\n             */            public static function removedScopes()\n            {\n                                /** @var \\Illuminate\\Database\\Eloquent\\Builder $instance */\n                                return $instance->removedScopes();\n            }\n                    /**\n             * Add a where clause on the primary key to the query.\n             *\n             * @param mixed $id\n             * @return \\Illuminate\\Database\\Eloquent\\Builder\n             * @static\n             */            public static function whereKey($id)\n            {\n                                /** @var \\Illuminate\\Database\\Eloquent\\Builder $instance */\n                                return $instance->whereKey($id);\n            }\n                    /**\n             * Add a where clause on the primary key to the query.\n             *\n             * @param mixed $id\n             * @return \\Illuminate\\Database\\Eloquent\\Builder\n             * @static\n             */            public static function whereKeyNot($id)\n            {\n                                /** @var \\Illuminate\\Database\\Eloquent\\Builder $instance */\n                                return $instance->whereKeyNot($id);\n            }\n                    /**\n             * Add a basic where clause to the query.\n             *\n             * @param \\Closure|string|array $column\n             * @param mixed $operator\n             * @param mixed $value\n             * @param string $boolean\n             * @return \\Illuminate\\Database\\Eloquent\\Builder\n             * @static\n             */            public static function where($column, $operator = null, $value = null, $boolean = \'and\')\n            {\n                                /** @var \\Illuminate\\Database\\Eloquent\\Builder $instance */\n                                return $instance->where($column, $operator, $value, $boolean);\n            }\n                    /**\n             * Add a basic where clause to the query, and return the first result.\n             *\n             * @param \\Closure|string|array $column\n             * @param mixed $operator\n             * @param mixed $value\n             * @param string $boolean\n             * @return \\Illuminate\\Database\\Eloquent\\Model|static\n             * @static\n             */            public static function firstWhere($column, $operator = null, $value = null, $boolean = \'and\')\n            {\n                                /** @var \\Illuminate\\Database\\Eloquent\\Builder $instance */\n                                return $instance->firstWhere($column, $operator, $value, $boolean);\n            }\n                    /**\n             * Add an "or where" clause to the query.\n             *\n             * @param \\Closure|array|string $column\n             * @param mixed $operator\n             * @param mixed $value\n             * @return \\Illuminate\\Database\\Eloquent\\Builder\n             * @static\n             */            public static function orWhere($column, $operator = null, $value = null)\n            {\n                                /** @var \\Illuminate\\Database\\Eloquent\\Builder $instance */\n                                return $instance->orWhere($column, $operator, $value);\n            }\n                    /**\n             * Add an "order by" clause for a timestamp to the query.\n             *\n             * @param string $column\n             * @return \\Illuminate\\Database\\Eloquent\\Builder\n             * @static\n             */            public static function latest($column = null)\n            {\n                                /** @var \\Illuminate\\Database\\Eloquent\\Builder $instance */\n                                return $instance->latest($column);\n            }\n                    /**\n             * Add an "order by" clause for a timestamp to the query.\n             *\n             * @param string $column\n             * @return \\Illuminate\\Database\\Eloquent\\Builder\n             * @static\n             */            public static function oldest($column = null)\n            {\n                                /** @var \\Illuminate\\Database\\Eloquent\\Builder $instance */\n                                return $instance->oldest($column);\n            }\n                    /**\n             * Create a collection of models from plain arrays.\n             *\n             * @param array $items\n             * @return \\Illuminate\\Database\\Eloquent\\Collection\n             * @static\n             */            public static function hydrate($items)\n            {\n                                /** @var \\Illuminate\\Database\\Eloquent\\Builder $instance */\n                                return $instance->hydrate($items);\n            }\n                    /**\n             * Create a collection of models from a raw query.\n             *\n             * @param string $query\n             * @param array $bindings\n             * @return \\Illuminate\\Database\\Eloquent\\Collection\n             * @static\n             */            public static function fromQuery($query, $bindings = [])\n            {\n                                /** @var \\Illuminate\\Database\\Eloquent\\Builder $instance */\n                                return $instance->fromQuery($query, $bindings);\n            }\n                    /**\n             * Find a model by its primary key.\n             *\n             * @param mixed $id\n             * @param array $columns\n             * @return \\Illuminate\\Database\\Eloquent\\Model|\\Illuminate\\Database\\Eloquent\\Collection|static[]|static|null\n             * @static\n             */            public static function find($id, $columns = [])\n            {\n                                /** @var \\Illuminate\\Database\\Eloquent\\Builder $instance */\n                                return $instance->find($id, $columns);\n            }\n                    /**\n             * Find multiple models by their primary keys.\n             *\n             * @param \\Illuminate\\Contracts\\Support\\Arrayable|array $ids\n             * @param array $columns\n             * @return \\Illuminate\\Database\\Eloquent\\Collection\n             * @static\n             */            public static function findMany($ids, $columns = [])\n            {\n                                /** @var \\Illuminate\\Database\\Eloquent\\Builder $instance */\n                                return $instance->findMany($ids, $columns);\n            }\n                    /**\n             * Find a model by its primary key or throw an exception.\n             *\n             * @param mixed $id\n             * @param array $columns\n             * @return \\Illuminate\\Database\\Eloquent\\Model|\\Illuminate\\Database\\Eloquent\\Collection|static|static[]\n             * @throws \\Illuminate\\Database\\Eloquent\\ModelNotFoundException\n             * @static\n             */            public static function findOrFail($id, $columns = [])\n            {\n                                /** @var \\Illuminate\\Database\\Eloquent\\Builder $instance */\n                                return $instance->findOrFail($id, $columns);\n            }\n                    /**\n             * Find a model by its primary key or return fresh model instance.\n             *\n             * @param mixed $id\n             * @param array $columns\n             * @return \\Illuminate\\Database\\Eloquent\\Model|static\n             * @static\n             */            public static function findOrNew($id, $columns = [])\n            {\n                                /** @var \\Illuminate\\Database\\Eloquent\\Builder $instance */\n                                return $instance->findOrNew($id, $columns);\n            }\n                    /**\n             * Get the first record matching the attributes or instantiate it.\n             *\n             * @param array $attributes\n             * @param array $values\n             * @return \\Illuminate\\Database\\Eloquent\\Model|static\n             * @static\n             */            public static function firstOrNew($attributes = [], $values = [])\n            {\n                                /** @var \\Illuminate\\Database\\Eloquent\\Builder $instance */\n                                return $instance->firstOrNew($attributes, $values);\n            }\n                    /**\n             * Get the first record matching the attributes or create it.\n             *\n             * @param array $attributes\n             * @param array $values\n             * @return \\Illuminate\\Database\\Eloquent\\Model|static\n             * @static\n             */            public static function firstOrCreate($attributes, $values = [])\n            {\n                                /** @var \\Illuminate\\Database\\Eloquent\\Builder $instance */\n                                return $instance->firstOrCreate($attributes, $values);\n            }\n                    /**\n             * Create or update a record matching the attributes, and fill it with values.\n             *\n             * @param array $attributes\n             * @param array $values\n             * @return \\Illuminate\\Database\\Eloquent\\Model|static\n             * @static\n             */            public static function updateOrCreate($attributes, $values = [])\n            {\n                                /** @var \\Illuminate\\Database\\Eloquent\\Builder $instance */\n                                return $instance->updateOrCreate($attributes, $values);\n            }\n                    /**\n             * Execute the query and get the first result or throw an exception.\n             *\n             * @param array $columns\n             * @return \\Illuminate\\Database\\Eloquent\\Model|static\n             * @throws \\Illuminate\\Database\\Eloquent\\ModelNotFoundException\n             * @static\n             */            public static function firstOrFail($columns = [])\n            {\n                                /** @var \\Illuminate\\Database\\Eloquent\\Builder $instance */\n                                return $instance->firstOrFail($columns);\n            }\n                    /**\n             * Execute the query and get the first result or call a callback.\n             *\n             * @param \\Closure|array $columns\n             * @param \\Closure|null $callback\n             * @return \\Illuminate\\Database\\Eloquent\\Model|static|mixed\n             * @static\n             */            public static function firstOr($columns = [], $callback = null)\n            {\n                                /** @var \\Illuminate\\Database\\Eloquent\\Builder $instance */\n                                return $instance->firstOr($columns, $callback);\n            }\n                    /**\n             * Get a single column\'s value from the first result of a query.\n             *\n             * @param string $column\n             * @return mixed\n             * @static\n             */            public static function value($column)\n            {\n                                /** @var \\Illuminate\\Database\\Eloquent\\Builder $instance */\n                                return $instance->value($column);\n            }\n                    /**\n             * Execute the query as a "select" statement.\n             *\n             * @param array|string $columns\n             * @return \\Illuminate\\Database\\Eloquent\\Collection|static[]\n             * @static\n             */            public static function get($columns = [])\n            {\n                                /** @var \\Illuminate\\Database\\Eloquent\\Builder $instance */\n                                return $instance->get($columns);\n            }\n                    /**\n             * Get the hydrated models without eager loading.\n             *\n             * @param array|string $columns\n             * @return \\Illuminate\\Database\\Eloquent\\Model[]|static[]\n             * @static\n             */            public static function getModels($columns = [])\n            {\n                                /** @var \\Illuminate\\Database\\Eloquent\\Builder $instance */\n                                return $instance->getModels($columns);\n            }\n                    /**\n             * Eager load the relationships for the models.\n             *\n             * @param array $models\n             * @return array\n             * @static\n             */            public static function eagerLoadRelations($models)\n            {\n                                /** @var \\Illuminate\\Database\\Eloquent\\Builder $instance */\n                                return $instance->eagerLoadRelations($models);\n            }\n                    /**\n             * Get a lazy collection for the given query.\n             *\n             * @return \\Illuminate\\Support\\LazyCollection\n             * @static\n             */            public static function cursor()\n            {\n                                /** @var \\Illuminate\\Database\\Eloquent\\Builder $instance */\n                                return $instance->cursor();\n            }\n                    /**\n             * Get an array with the values of a given column.\n             *\n             * @param string $column\n             * @param string|null $key\n             * @return \\Illuminate\\Support\\Collection\n             * @static\n             */            public static function pluck($column, $key = null)\n            {\n                                /** @var \\Illuminate\\Database\\Eloquent\\Builder $instance */\n                                return $instance->pluck($column, $key);\n            }\n                    /**\n             * Paginate the given query.\n             *\n             * @param int|null $perPage\n             * @param array $columns\n             * @param string $pageName\n             * @param int|null $page\n             * @return \\Illuminate\\Contracts\\Pagination\\LengthAwarePaginator\n             * @throws \\InvalidArgumentException\n             * @static\n             */            public static function paginate($perPage = null, $columns = [], $pageName = \'page\', $page = null)\n            {\n                                /** @var \\Illuminate\\Database\\Eloquent\\Builder $instance */\n                                return $instance->paginate($perPage, $columns, $pageName, $page);\n            }\n                    /**\n             * Paginate the given query into a simple paginator.\n             *\n             * @param int|null $perPage\n             * @param array $columns\n             * @param string $pageName\n             * @param int|null $page\n             * @return \\Illuminate\\Contracts\\Pagination\\Paginator\n             * @static\n             */            public static function simplePaginate($perPage = null, $columns = [], $pageName = \'page\', $page = null)\n            {\n                                /** @var \\Illuminate\\Database\\Eloquent\\Builder $instance */\n                                return $instance->simplePaginate($perPage, $columns, $pageName, $page);\n            }\n                    /**\n             * Save a new model and return the instance.\n             *\n             * @param array $attributes\n             * @return \\Illuminate\\Database\\Eloquent\\Model|$this\n             * @static\n             */            public static function create($attributes = [])\n            {\n                                /** @var \\Illuminate\\Database\\Eloquent\\Builder $instance */\n                                return $instance->create($attributes);\n            }\n                    /**\n             * Save a new model and return the instance. Allow mass-assignment.\n             *\n             * @param array $attributes\n             * @return \\Illuminate\\Database\\Eloquent\\Model|$this\n             * @static\n             */            public static function forceCreate($attributes)\n            {\n                                /** @var \\Illuminate\\Database\\Eloquent\\Builder $instance */\n                                return $instance->forceCreate($attributes);\n            }\n                    /**\n             * Register a replacement for the default delete function.\n             *\n             * @param \\Closure $callback\n             * @return void\n             * @static\n             */            public static function onDelete($callback)\n            {\n                                /** @var \\Illuminate\\Database\\Eloquent\\Builder $instance */\n                                $instance->onDelete($callback);\n            }\n                    /**\n             * Call the given local model scopes.\n             *\n             * @param array|string $scopes\n             * @return static|mixed\n             * @static\n             */            public static function scopes($scopes)\n            {\n                                /** @var \\Illuminate\\Database\\Eloquent\\Builder $instance */\n                                return $instance->scopes($scopes);\n            }\n                    /**\n             * Apply the scopes to the Eloquent builder instance and return it.\n             *\n             * @return static\n             * @static\n             */            public static function applyScopes()\n            {\n                                /** @var \\Illuminate\\Database\\Eloquent\\Builder $instance */\n                                return $instance->applyScopes();\n            }\n                    /**\n             * Prevent the specified relations from being eager loaded.\n             *\n             * @param mixed $relations\n             * @return \\Illuminate\\Database\\Eloquent\\Builder\n             * @static\n             */            public static function without($relations)\n            {\n                                /** @var \\Illuminate\\Database\\Eloquent\\Builder $instance */\n                                return $instance->without($relations);\n            }\n                    /**\n             * Create a new instance of the model being queried.\n             *\n             * @param array $attributes\n             * @return \\Illuminate\\Database\\Eloquent\\Model|static\n             * @static\n             */            public static function newModelInstance($attributes = [])\n            {\n                                /** @var \\Illuminate\\Database\\Eloquent\\Builder $instance */\n                                return $instance->newModelInstance($attributes);\n            }\n                    /**\n             * Apply query-time casts to the model instance.\n             *\n             * @param array $casts\n             * @return \\Illuminate\\Database\\Eloquent\\Builder\n             * @static\n             */            public static function withCasts($casts)\n            {\n                                /** @var \\Illuminate\\Database\\Eloquent\\Builder $instance */\n                                return $instance->withCasts($casts);\n            }\n                    /**\n             * Get the underlying query builder instance.\n             *\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @static\n             */            public static function getQuery()\n            {\n                                /** @var \\Illuminate\\Database\\Eloquent\\Builder $instance */\n                                return $instance->getQuery();\n            }\n                    /**\n             * Set the underlying query builder instance.\n             *\n             * @param \\Illuminate\\Database\\Query\\Builder $query\n             * @return \\Illuminate\\Database\\Eloquent\\Builder\n             * @static\n             */            public static function setQuery($query)\n            {\n                                /** @var \\Illuminate\\Database\\Eloquent\\Builder $instance */\n                                return $instance->setQuery($query);\n            }\n                    /**\n             * Get a base query builder instance.\n             *\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @static\n             */            public static function toBase()\n            {\n                                /** @var \\Illuminate\\Database\\Eloquent\\Builder $instance */\n                                return $instance->toBase();\n            }\n                    /**\n             * Get the relationships being eagerly loaded.\n             *\n             * @return array\n             * @static\n             */            public static function getEagerLoads()\n            {\n                                /** @var \\Illuminate\\Database\\Eloquent\\Builder $instance */\n                                return $instance->getEagerLoads();\n            }\n                    /**\n             * Set the relationships being eagerly loaded.\n             *\n             * @param array $eagerLoad\n             * @return \\Illuminate\\Database\\Eloquent\\Builder\n             * @static\n             */            public static function setEagerLoads($eagerLoad)\n            {\n                                /** @var \\Illuminate\\Database\\Eloquent\\Builder $instance */\n                                return $instance->setEagerLoads($eagerLoad);\n            }\n                    /**\n             * Get the model instance being queried.\n             *\n             * @return \\Illuminate\\Database\\Eloquent\\Model|static\n             * @static\n             */            public static function getModel()\n            {\n                                /** @var \\Illuminate\\Database\\Eloquent\\Builder $instance */\n                                return $instance->getModel();\n            }\n                    /**\n             * Set a model instance for the model being queried.\n             *\n             * @param \\Illuminate\\Database\\Eloquent\\Model $model\n             * @return \\Illuminate\\Database\\Eloquent\\Builder\n             * @static\n             */            public static function setModel($model)\n            {\n                                /** @var \\Illuminate\\Database\\Eloquent\\Builder $instance */\n                                return $instance->setModel($model);\n            }\n                    /**\n             * Get the given macro by name.\n             *\n             * @param string $name\n             * @return \\Closure\n             * @static\n             */            public static function getMacro($name)\n            {\n                                /** @var \\Illuminate\\Database\\Eloquent\\Builder $instance */\n                                return $instance->getMacro($name);\n            }\n                    /**\n             * Checks if a macro is registered.\n             *\n             * @param string $name\n             * @return bool\n             * @static\n             */            public static function hasMacro($name)\n            {\n                                /** @var \\Illuminate\\Database\\Eloquent\\Builder $instance */\n                                return $instance->hasMacro($name);\n            }\n                    /**\n             * Get the given global macro by name.\n             *\n             * @param string $name\n             * @return \\Closure\n             * @static\n             */            public static function getGlobalMacro($name)\n            {\n                                return \\Illuminate\\Database\\Eloquent\\Builder::getGlobalMacro($name);\n            }\n                    /**\n             * Checks if a global macro is registered.\n             *\n             * @param string $name\n             * @return bool\n             * @static\n             */            public static function hasGlobalMacro($name)\n            {\n                                return \\Illuminate\\Database\\Eloquent\\Builder::hasGlobalMacro($name);\n            }\n                    /**\n             * Chunk the results of the query.\n             *\n             * @param int $count\n             * @param callable $callback\n             * @return bool\n             * @static\n             */            public static function chunk($count, $callback)\n            {\n                                /** @var \\Illuminate\\Database\\Eloquent\\Builder $instance */\n                                return $instance->chunk($count, $callback);\n            }\n                    /**\n             * Execute a callback over each item while chunking.\n             *\n             * @param callable $callback\n             * @param int $count\n             * @return bool\n             * @static\n             */            public static function each($callback, $count = 1000)\n            {\n                                /** @var \\Illuminate\\Database\\Eloquent\\Builder $instance */\n                                return $instance->each($callback, $count);\n            }\n                    /**\n             * Chunk the results of a query by comparing IDs.\n             *\n             * @param int $count\n             * @param callable $callback\n             * @param string|null $column\n             * @param string|null $alias\n             * @return bool\n             * @static\n             */            public static function chunkById($count, $callback, $column = null, $alias = null)\n            {\n                                /** @var \\Illuminate\\Database\\Eloquent\\Builder $instance */\n                                return $instance->chunkById($count, $callback, $column, $alias);\n            }\n                    /**\n             * Execute a callback over each item while chunking by id.\n             *\n             * @param callable $callback\n             * @param int $count\n             * @param string|null $column\n             * @param string|null $alias\n             * @return bool\n             * @static\n             */            public static function eachById($callback, $count = 1000, $column = null, $alias = null)\n            {\n                                /** @var \\Illuminate\\Database\\Eloquent\\Builder $instance */\n                                return $instance->eachById($callback, $count, $column, $alias);\n            }\n                    /**\n             * Execute the query and get the first result.\n             *\n             * @param array|string $columns\n             * @return \\Illuminate\\Database\\Eloquent\\Model|object|static|null\n             * @static\n             */            public static function first($columns = [])\n            {\n                                /** @var \\Illuminate\\Database\\Eloquent\\Builder $instance */\n                                return $instance->first($columns);\n            }\n                    /**\n             * Apply the callback\'s query changes if the given "value" is true.\n             *\n             * @param mixed $value\n             * @param callable $callback\n             * @param callable|null $default\n             * @return mixed|$this\n             * @static\n             */            public static function when($value, $callback, $default = null)\n            {\n                                /** @var \\Illuminate\\Database\\Eloquent\\Builder $instance */\n                                return $instance->when($value, $callback, $default);\n            }\n                    /**\n             * Pass the query to a given callback.\n             *\n             * @param callable $callback\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @static\n             */            public static function tap($callback)\n            {\n                                /** @var \\Illuminate\\Database\\Eloquent\\Builder $instance */\n                                return $instance->tap($callback);\n            }\n                    /**\n             * Apply the callback\'s query changes if the given "value" is false.\n             *\n             * @param mixed $value\n             * @param callable $callback\n             * @param callable|null $default\n             * @return mixed|$this\n             * @static\n             */            public static function unless($value, $callback, $default = null)\n            {\n                                /** @var \\Illuminate\\Database\\Eloquent\\Builder $instance */\n                                return $instance->unless($value, $callback, $default);\n            }\n                    /**\n             * Add a relationship count / exists condition to the query.\n             *\n             * @param \\Illuminate\\Database\\Eloquent\\Relations\\Relation|string $relation\n             * @param string $operator\n             * @param int $count\n             * @param string $boolean\n             * @param \\Closure|null $callback\n             * @return \\Illuminate\\Database\\Eloquent\\Builder|static\n             * @throws \\RuntimeException\n             * @static\n             */            public static function has($relation, $operator = \'>=\', $count = 1, $boolean = \'and\', $callback = null)\n            {\n                                /** @var \\Illuminate\\Database\\Eloquent\\Builder $instance */\n                                return $instance->has($relation, $operator, $count, $boolean, $callback);\n            }\n                    /**\n             * Add a relationship count / exists condition to the query with an "or".\n             *\n             * @param string $relation\n             * @param string $operator\n             * @param int $count\n             * @return \\Illuminate\\Database\\Eloquent\\Builder|static\n             * @static\n             */            public static function orHas($relation, $operator = \'>=\', $count = 1)\n            {\n                                /** @var \\Illuminate\\Database\\Eloquent\\Builder $instance */\n                                return $instance->orHas($relation, $operator, $count);\n            }\n                    /**\n             * Add a relationship count / exists condition to the query.\n             *\n             * @param string $relation\n             * @param string $boolean\n             * @param \\Closure|null $callback\n             * @return \\Illuminate\\Database\\Eloquent\\Builder|static\n             * @static\n             */            public static function doesntHave($relation, $boolean = \'and\', $callback = null)\n            {\n                                /** @var \\Illuminate\\Database\\Eloquent\\Builder $instance */\n                                return $instance->doesntHave($relation, $boolean, $callback);\n            }\n                    /**\n             * Add a relationship count / exists condition to the query with an "or".\n             *\n             * @param string $relation\n             * @return \\Illuminate\\Database\\Eloquent\\Builder|static\n             * @static\n             */            public static function orDoesntHave($relation)\n            {\n                                /** @var \\Illuminate\\Database\\Eloquent\\Builder $instance */\n                                return $instance->orDoesntHave($relation);\n            }\n                    /**\n             * Add a relationship count / exists condition to the query with where clauses.\n             *\n             * @param string $relation\n             * @param \\Closure|null $callback\n             * @param string $operator\n             * @param int $count\n             * @return \\Illuminate\\Database\\Eloquent\\Builder|static\n             * @static\n             */            public static function whereHas($relation, $callback = null, $operator = \'>=\', $count = 1)\n            {\n                                /** @var \\Illuminate\\Database\\Eloquent\\Builder $instance */\n                                return $instance->whereHas($relation, $callback, $operator, $count);\n            }\n                    /**\n             * Add a relationship count / exists condition to the query with where clauses and an "or".\n             *\n             * @param string $relation\n             * @param \\Closure|null $callback\n             * @param string $operator\n             * @param int $count\n             * @return \\Illuminate\\Database\\Eloquent\\Builder|static\n             * @static\n             */            public static function orWhereHas($relation, $callback = null, $operator = \'>=\', $count = 1)\n            {\n                                /** @var \\Illuminate\\Database\\Eloquent\\Builder $instance */\n                                return $instance->orWhereHas($relation, $callback, $operator, $count);\n            }\n                    /**\n             * Add a relationship count / exists condition to the query with where clauses.\n             *\n             * @param string $relation\n             * @param \\Closure|null $callback\n             * @return \\Illuminate\\Database\\Eloquent\\Builder|static\n             * @static\n             */            public static function whereDoesntHave($relation, $callback = null)\n            {\n                                /** @var \\Illuminate\\Database\\Eloquent\\Builder $instance */\n                                return $instance->whereDoesntHave($relation, $callback);\n            }\n                    /**\n             * Add a relationship count / exists condition to the query with where clauses and an "or".\n             *\n             * @param string $relation\n             * @param \\Closure|null $callback\n             * @return \\Illuminate\\Database\\Eloquent\\Builder|static\n             * @static\n             */            public static function orWhereDoesntHave($relation, $callback = null)\n            {\n                                /** @var \\Illuminate\\Database\\Eloquent\\Builder $instance */\n                                return $instance->orWhereDoesntHave($relation, $callback);\n            }\n                    /**\n             * Add a polymorphic relationship count / exists condition to the query.\n             *\n             * @param string $relation\n             * @param string|array $types\n             * @param string $operator\n             * @param int $count\n             * @param string $boolean\n             * @param \\Closure|null $callback\n             * @return \\Illuminate\\Database\\Eloquent\\Builder|static\n             * @static\n             */            public static function hasMorph($relation, $types, $operator = \'>=\', $count = 1, $boolean = \'and\', $callback = null)\n            {\n                                /** @var \\Illuminate\\Database\\Eloquent\\Builder $instance */\n                                return $instance->hasMorph($relation, $types, $operator, $count, $boolean, $callback);\n            }\n                    /**\n             * Add a polymorphic relationship count / exists condition to the query with an "or".\n             *\n             * @param string $relation\n             * @param string|array $types\n             * @param string $operator\n             * @param int $count\n             * @return \\Illuminate\\Database\\Eloquent\\Builder|static\n             * @static\n             */            public static function orHasMorph($relation, $types, $operator = \'>=\', $count = 1)\n            {\n                                /** @var \\Illuminate\\Database\\Eloquent\\Builder $instance */\n                                return $instance->orHasMorph($relation, $types, $operator, $count);\n            }\n                    /**\n             * Add a polymorphic relationship count / exists condition to the query.\n             *\n             * @param string $relation\n             * @param string|array $types\n             * @param string $boolean\n             * @param \\Closure|null $callback\n             * @return \\Illuminate\\Database\\Eloquent\\Builder|static\n             * @static\n             */            public static function doesntHaveMorph($relation, $types, $boolean = \'and\', $callback = null)\n            {\n                                /** @var \\Illuminate\\Database\\Eloquent\\Builder $instance */\n                                return $instance->doesntHaveMorph($relation, $types, $boolean, $callback);\n            }\n                    /**\n             * Add a polymorphic relationship count / exists condition to the query with an "or".\n             *\n             * @param string $relation\n             * @param string|array $types\n             * @return \\Illuminate\\Database\\Eloquent\\Builder|static\n             * @static\n             */            public static function orDoesntHaveMorph($relation, $types)\n            {\n                                /** @var \\Illuminate\\Database\\Eloquent\\Builder $instance */\n                                return $instance->orDoesntHaveMorph($relation, $types);\n            }\n                    /**\n             * Add a polymorphic relationship count / exists condition to the query with where clauses.\n             *\n             * @param string $relation\n             * @param string|array $types\n             * @param \\Closure|null $callback\n             * @param string $operator\n             * @param int $count\n             * @return \\Illuminate\\Database\\Eloquent\\Builder|static\n             * @static\n             */            public static function whereHasMorph($relation, $types, $callback = null, $operator = \'>=\', $count = 1)\n            {\n                                /** @var \\Illuminate\\Database\\Eloquent\\Builder $instance */\n                                return $instance->whereHasMorph($relation, $types, $callback, $operator, $count);\n            }\n                    /**\n             * Add a polymorphic relationship count / exists condition to the query with where clauses and an "or".\n             *\n             * @param string $relation\n             * @param string|array $types\n             * @param \\Closure|null $callback\n             * @param string $operator\n             * @param int $count\n             * @return \\Illuminate\\Database\\Eloquent\\Builder|static\n             * @static\n             */            public static function orWhereHasMorph($relation, $types, $callback = null, $operator = \'>=\', $count = 1)\n            {\n                                /** @var \\Illuminate\\Database\\Eloquent\\Builder $instance */\n                                return $instance->orWhereHasMorph($relation, $types, $callback, $operator, $count);\n            }\n                    /**\n             * Add a polymorphic relationship count / exists condition to the query with where clauses.\n             *\n             * @param string $relation\n             * @param string|array $types\n             * @param \\Closure|null $callback\n             * @return \\Illuminate\\Database\\Eloquent\\Builder|static\n             * @static\n             */            public static function whereDoesntHaveMorph($relation, $types, $callback = null)\n            {\n                                /** @var \\Illuminate\\Database\\Eloquent\\Builder $instance */\n                                return $instance->whereDoesntHaveMorph($relation, $types, $callback);\n            }\n                    /**\n             * Add a polymorphic relationship count / exists condition to the query with where clauses and an "or".\n             *\n             * @param string $relation\n             * @param string|array $types\n             * @param \\Closure|null $callback\n             * @return \\Illuminate\\Database\\Eloquent\\Builder|static\n             * @static\n             */            public static function orWhereDoesntHaveMorph($relation, $types, $callback = null)\n            {\n                                /** @var \\Illuminate\\Database\\Eloquent\\Builder $instance */\n                                return $instance->orWhereDoesntHaveMorph($relation, $types, $callback);\n            }\n                    /**\n             * Add subselect queries to count the relations.\n             *\n             * @param mixed $relations\n             * @return \\Illuminate\\Database\\Eloquent\\Builder\n             * @static\n             */            public static function withCount($relations)\n            {\n                                /** @var \\Illuminate\\Database\\Eloquent\\Builder $instance */\n                                return $instance->withCount($relations);\n            }\n                    /**\n             * Merge the where constraints from another query to the current query.\n             *\n             * @param \\Illuminate\\Database\\Eloquent\\Builder $from\n             * @return \\Illuminate\\Database\\Eloquent\\Builder|static\n             * @static\n             */            public static function mergeConstraintsFrom($from)\n            {\n                                /** @var \\Illuminate\\Database\\Eloquent\\Builder $instance */\n                                return $instance->mergeConstraintsFrom($from);\n            }\n                    /**\n             * Set the columns to be selected.\n             *\n             * @param array|mixed $columns\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @static\n             */            public static function select($columns = [])\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->select($columns);\n            }\n                    /**\n             * Add a subselect expression to the query.\n             *\n             * @param \\Closure|\\Illuminate\\Database\\Query\\Builder|string $query\n             * @param string $as\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @throws \\InvalidArgumentException\n             * @static\n             */            public static function selectSub($query, $as)\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->selectSub($query, $as);\n            }\n                    /**\n             * Add a new "raw" select expression to the query.\n             *\n             * @param string $expression\n             * @param array $bindings\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @static\n             */            public static function selectRaw($expression, $bindings = [])\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->selectRaw($expression, $bindings);\n            }\n                    /**\n             * Makes "from" fetch from a subquery.\n             *\n             * @param \\Closure|\\Illuminate\\Database\\Query\\Builder|string $query\n             * @param string $as\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @throws \\InvalidArgumentException\n             * @static\n             */            public static function fromSub($query, $as)\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->fromSub($query, $as);\n            }\n                    /**\n             * Add a raw from clause to the query.\n             *\n             * @param string $expression\n             * @param mixed $bindings\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @static\n             */            public static function fromRaw($expression, $bindings = [])\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->fromRaw($expression, $bindings);\n            }\n                    /**\n             * Add a new select column to the query.\n             *\n             * @param array|mixed $column\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @static\n             */            public static function addSelect($column)\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->addSelect($column);\n            }\n                    /**\n             * Force the query to only return distinct results.\n             *\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @static\n             */            public static function distinct()\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->distinct();\n            }\n                    /**\n             * Set the table which the query is targeting.\n             *\n             * @param \\Closure|\\Illuminate\\Database\\Query\\Builder|string $table\n             * @param string|null $as\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @static\n             */            public static function from($table, $as = null)\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->from($table, $as);\n            }\n                    /**\n             * Add a join clause to the query.\n             *\n             * @param string $table\n             * @param \\Closure|string $first\n             * @param string|null $operator\n             * @param string|null $second\n             * @param string $type\n             * @param bool $where\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @static\n             */            public static function join($table, $first, $operator = null, $second = null, $type = \'inner\', $where = false)\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->join($table, $first, $operator, $second, $type, $where);\n            }\n                    /**\n             * Add a "join where" clause to the query.\n             *\n             * @param string $table\n             * @param \\Closure|string $first\n             * @param string $operator\n             * @param string $second\n             * @param string $type\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @static\n             */            public static function joinWhere($table, $first, $operator, $second, $type = \'inner\')\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->joinWhere($table, $first, $operator, $second, $type);\n            }\n                    /**\n             * Add a subquery join clause to the query.\n             *\n             * @param \\Closure|\\Illuminate\\Database\\Query\\Builder|string $query\n             * @param string $as\n             * @param \\Closure|string $first\n             * @param string|null $operator\n             * @param string|null $second\n             * @param string $type\n             * @param bool $where\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @throws \\InvalidArgumentException\n             * @static\n             */            public static function joinSub($query, $as, $first, $operator = null, $second = null, $type = \'inner\', $where = false)\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->joinSub($query, $as, $first, $operator, $second, $type, $where);\n            }\n                    /**\n             * Add a left join to the query.\n             *\n             * @param string $table\n             * @param \\Closure|string $first\n             * @param string|null $operator\n             * @param string|null $second\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @static\n             */            public static function leftJoin($table, $first, $operator = null, $second = null)\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->leftJoin($table, $first, $operator, $second);\n            }\n                    /**\n             * Add a "join where" clause to the query.\n             *\n             * @param string $table\n             * @param \\Closure|string $first\n             * @param string $operator\n             * @param string $second\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @static\n             */            public static function leftJoinWhere($table, $first, $operator, $second)\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->leftJoinWhere($table, $first, $operator, $second);\n            }\n                    /**\n             * Add a subquery left join to the query.\n             *\n             * @param \\Closure|\\Illuminate\\Database\\Query\\Builder|string $query\n             * @param string $as\n             * @param \\Closure|string $first\n             * @param string|null $operator\n             * @param string|null $second\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @static\n             */            public static function leftJoinSub($query, $as, $first, $operator = null, $second = null)\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->leftJoinSub($query, $as, $first, $operator, $second);\n            }\n                    /**\n             * Add a right join to the query.\n             *\n             * @param string $table\n             * @param \\Closure|string $first\n             * @param string|null $operator\n             * @param string|null $second\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @static\n             */            public static function rightJoin($table, $first, $operator = null, $second = null)\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->rightJoin($table, $first, $operator, $second);\n            }\n                    /**\n             * Add a "right join where" clause to the query.\n             *\n             * @param string $table\n             * @param \\Closure|string $first\n             * @param string $operator\n             * @param string $second\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @static\n             */            public static function rightJoinWhere($table, $first, $operator, $second)\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->rightJoinWhere($table, $first, $operator, $second);\n            }\n                    /**\n             * Add a subquery right join to the query.\n             *\n             * @param \\Closure|\\Illuminate\\Database\\Query\\Builder|string $query\n             * @param string $as\n             * @param \\Closure|string $first\n             * @param string|null $operator\n             * @param string|null $second\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @static\n             */            public static function rightJoinSub($query, $as, $first, $operator = null, $second = null)\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->rightJoinSub($query, $as, $first, $operator, $second);\n            }\n                    /**\n             * Add a "cross join" clause to the query.\n             *\n             * @param string $table\n             * @param \\Closure|string|null $first\n             * @param string|null $operator\n             * @param string|null $second\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @static\n             */            public static function crossJoin($table, $first = null, $operator = null, $second = null)\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->crossJoin($table, $first, $operator, $second);\n            }\n                    /**\n             * Merge an array of where clauses and bindings.\n             *\n             * @param array $wheres\n             * @param array $bindings\n             * @return void\n             * @static\n             */            public static function mergeWheres($wheres, $bindings)\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                $instance->mergeWheres($wheres, $bindings);\n            }\n                    /**\n             * Prepare the value and operator for a where clause.\n             *\n             * @param string $value\n             * @param string $operator\n             * @param bool $useDefault\n             * @return array\n             * @throws \\InvalidArgumentException\n             * @static\n             */            public static function prepareValueAndOperator($value, $operator, $useDefault = false)\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->prepareValueAndOperator($value, $operator, $useDefault);\n            }\n                    /**\n             * Add a "where" clause comparing two columns to the query.\n             *\n             * @param string|array $first\n             * @param string|null $operator\n             * @param string|null $second\n             * @param string|null $boolean\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @static\n             */            public static function whereColumn($first, $operator = null, $second = null, $boolean = \'and\')\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->whereColumn($first, $operator, $second, $boolean);\n            }\n                    /**\n             * Add an "or where" clause comparing two columns to the query.\n             *\n             * @param string|array $first\n             * @param string|null $operator\n             * @param string|null $second\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @static\n             */            public static function orWhereColumn($first, $operator = null, $second = null)\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->orWhereColumn($first, $operator, $second);\n            }\n                    /**\n             * Add a raw where clause to the query.\n             *\n             * @param string $sql\n             * @param mixed $bindings\n             * @param string $boolean\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @static\n             */            public static function whereRaw($sql, $bindings = [], $boolean = \'and\')\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->whereRaw($sql, $bindings, $boolean);\n            }\n                    /**\n             * Add a raw or where clause to the query.\n             *\n             * @param string $sql\n             * @param mixed $bindings\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @static\n             */            public static function orWhereRaw($sql, $bindings = [])\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->orWhereRaw($sql, $bindings);\n            }\n                    /**\n             * Add a "where in" clause to the query.\n             *\n             * @param string $column\n             * @param mixed $values\n             * @param string $boolean\n             * @param bool $not\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @static\n             */            public static function whereIn($column, $values, $boolean = \'and\', $not = false)\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->whereIn($column, $values, $boolean, $not);\n            }\n                    /**\n             * Add an "or where in" clause to the query.\n             *\n             * @param string $column\n             * @param mixed $values\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @static\n             */            public static function orWhereIn($column, $values)\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->orWhereIn($column, $values);\n            }\n                    /**\n             * Add a "where not in" clause to the query.\n             *\n             * @param string $column\n             * @param mixed $values\n             * @param string $boolean\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @static\n             */            public static function whereNotIn($column, $values, $boolean = \'and\')\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->whereNotIn($column, $values, $boolean);\n            }\n                    /**\n             * Add an "or where not in" clause to the query.\n             *\n             * @param string $column\n             * @param mixed $values\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @static\n             */            public static function orWhereNotIn($column, $values)\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->orWhereNotIn($column, $values);\n            }\n                    /**\n             * Add a "where in raw" clause for integer values to the query.\n             *\n             * @param string $column\n             * @param \\Illuminate\\Contracts\\Support\\Arrayable|array $values\n             * @param string $boolean\n             * @param bool $not\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @static\n             */            public static function whereIntegerInRaw($column, $values, $boolean = \'and\', $not = false)\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->whereIntegerInRaw($column, $values, $boolean, $not);\n            }\n                    /**\n             * Add a "where not in raw" clause for integer values to the query.\n             *\n             * @param string $column\n             * @param \\Illuminate\\Contracts\\Support\\Arrayable|array $values\n             * @param string $boolean\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @static\n             */            public static function whereIntegerNotInRaw($column, $values, $boolean = \'and\')\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->whereIntegerNotInRaw($column, $values, $boolean);\n            }\n                    /**\n             * Add a "where null" clause to the query.\n             *\n             * @param string|array $columns\n             * @param string $boolean\n             * @param bool $not\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @static\n             */            public static function whereNull($columns, $boolean = \'and\', $not = false)\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->whereNull($columns, $boolean, $not);\n            }\n                    /**\n             * Add an "or where null" clause to the query.\n             *\n             * @param string $column\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @static\n             */            public static function orWhereNull($column)\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->orWhereNull($column);\n            }\n                    /**\n             * Add a "where not null" clause to the query.\n             *\n             * @param string|array $columns\n             * @param string $boolean\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @static\n             */            public static function whereNotNull($columns, $boolean = \'and\')\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->whereNotNull($columns, $boolean);\n            }\n                    /**\n             * Add a where between statement to the query.\n             *\n             * @param string $column\n             * @param array $values\n             * @param string $boolean\n             * @param bool $not\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @static\n             */            public static function whereBetween($column, $values, $boolean = \'and\', $not = false)\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->whereBetween($column, $values, $boolean, $not);\n            }\n                    /**\n             * Add an or where between statement to the query.\n             *\n             * @param string $column\n             * @param array $values\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @static\n             */            public static function orWhereBetween($column, $values)\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->orWhereBetween($column, $values);\n            }\n                    /**\n             * Add a where not between statement to the query.\n             *\n             * @param string $column\n             * @param array $values\n             * @param string $boolean\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @static\n             */            public static function whereNotBetween($column, $values, $boolean = \'and\')\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->whereNotBetween($column, $values, $boolean);\n            }\n                    /**\n             * Add an or where not between statement to the query.\n             *\n             * @param string $column\n             * @param array $values\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @static\n             */            public static function orWhereNotBetween($column, $values)\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->orWhereNotBetween($column, $values);\n            }\n                    /**\n             * Add an "or where not null" clause to the query.\n             *\n             * @param string $column\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @static\n             */            public static function orWhereNotNull($column)\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->orWhereNotNull($column);\n            }\n                    /**\n             * Add a "where date" statement to the query.\n             *\n             * @param string $column\n             * @param string $operator\n             * @param \\DateTimeInterface|string|null $value\n             * @param string $boolean\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @static\n             */            public static function whereDate($column, $operator, $value = null, $boolean = \'and\')\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->whereDate($column, $operator, $value, $boolean);\n            }\n                    /**\n             * Add an "or where date" statement to the query.\n             *\n             * @param string $column\n             * @param string $operator\n             * @param \\DateTimeInterface|string|null $value\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @static\n             */            public static function orWhereDate($column, $operator, $value = null)\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->orWhereDate($column, $operator, $value);\n            }\n                    /**\n             * Add a "where time" statement to the query.\n             *\n             * @param string $column\n             * @param string $operator\n             * @param \\DateTimeInterface|string|null $value\n             * @param string $boolean\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @static\n             */            public static function whereTime($column, $operator, $value = null, $boolean = \'and\')\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->whereTime($column, $operator, $value, $boolean);\n            }\n                    /**\n             * Add an "or where time" statement to the query.\n             *\n             * @param string $column\n             * @param string $operator\n             * @param \\DateTimeInterface|string|null $value\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @static\n             */            public static function orWhereTime($column, $operator, $value = null)\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->orWhereTime($column, $operator, $value);\n            }\n                    /**\n             * Add a "where day" statement to the query.\n             *\n             * @param string $column\n             * @param string $operator\n             * @param \\DateTimeInterface|string|null $value\n             * @param string $boolean\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @static\n             */            public static function whereDay($column, $operator, $value = null, $boolean = \'and\')\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->whereDay($column, $operator, $value, $boolean);\n            }\n                    /**\n             * Add an "or where day" statement to the query.\n             *\n             * @param string $column\n             * @param string $operator\n             * @param \\DateTimeInterface|string|null $value\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @static\n             */            public static function orWhereDay($column, $operator, $value = null)\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->orWhereDay($column, $operator, $value);\n            }\n                    /**\n             * Add a "where month" statement to the query.\n             *\n             * @param string $column\n             * @param string $operator\n             * @param \\DateTimeInterface|string|null $value\n             * @param string $boolean\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @static\n             */            public static function whereMonth($column, $operator, $value = null, $boolean = \'and\')\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->whereMonth($column, $operator, $value, $boolean);\n            }\n                    /**\n             * Add an "or where month" statement to the query.\n             *\n             * @param string $column\n             * @param string $operator\n             * @param \\DateTimeInterface|string|null $value\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @static\n             */            public static function orWhereMonth($column, $operator, $value = null)\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->orWhereMonth($column, $operator, $value);\n            }\n                    /**\n             * Add a "where year" statement to the query.\n             *\n             * @param string $column\n             * @param string $operator\n             * @param \\DateTimeInterface|string|int|null $value\n             * @param string $boolean\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @static\n             */            public static function whereYear($column, $operator, $value = null, $boolean = \'and\')\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->whereYear($column, $operator, $value, $boolean);\n            }\n                    /**\n             * Add an "or where year" statement to the query.\n             *\n             * @param string $column\n             * @param string $operator\n             * @param \\DateTimeInterface|string|int|null $value\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @static\n             */            public static function orWhereYear($column, $operator, $value = null)\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->orWhereYear($column, $operator, $value);\n            }\n                    /**\n             * Add a nested where statement to the query.\n             *\n             * @param \\Closure $callback\n             * @param string $boolean\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @static\n             */            public static function whereNested($callback, $boolean = \'and\')\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->whereNested($callback, $boolean);\n            }\n                    /**\n             * Create a new query instance for nested where condition.\n             *\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @static\n             */            public static function forNestedWhere()\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->forNestedWhere();\n            }\n                    /**\n             * Add another query builder as a nested where to the query builder.\n             *\n             * @param $this $query\n             * @param string $boolean\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @static\n             */            public static function addNestedWhereQuery($query, $boolean = \'and\')\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->addNestedWhereQuery($query, $boolean);\n            }\n                    /**\n             * Add an exists clause to the query.\n             *\n             * @param \\Closure $callback\n             * @param string $boolean\n             * @param bool $not\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @static\n             */            public static function whereExists($callback, $boolean = \'and\', $not = false)\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->whereExists($callback, $boolean, $not);\n            }\n                    /**\n             * Add an or exists clause to the query.\n             *\n             * @param \\Closure $callback\n             * @param bool $not\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @static\n             */            public static function orWhereExists($callback, $not = false)\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->orWhereExists($callback, $not);\n            }\n                    /**\n             * Add a where not exists clause to the query.\n             *\n             * @param \\Closure $callback\n             * @param string $boolean\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @static\n             */            public static function whereNotExists($callback, $boolean = \'and\')\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->whereNotExists($callback, $boolean);\n            }\n                    /**\n             * Add a where not exists clause to the query.\n             *\n             * @param \\Closure $callback\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @static\n             */            public static function orWhereNotExists($callback)\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->orWhereNotExists($callback);\n            }\n                    /**\n             * Add an exists clause to the query.\n             *\n             * @param \\Illuminate\\Database\\Query\\Builder $query\n             * @param string $boolean\n             * @param bool $not\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @static\n             */            public static function addWhereExistsQuery($query, $boolean = \'and\', $not = false)\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->addWhereExistsQuery($query, $boolean, $not);\n            }\n                    /**\n             * Adds a where condition using row values.\n             *\n             * @param array $columns\n             * @param string $operator\n             * @param array $values\n             * @param string $boolean\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @throws \\InvalidArgumentException\n             * @static\n             */            public static function whereRowValues($columns, $operator, $values, $boolean = \'and\')\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->whereRowValues($columns, $operator, $values, $boolean);\n            }\n                    /**\n             * Adds a or where condition using row values.\n             *\n             * @param array $columns\n             * @param string $operator\n             * @param array $values\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @static\n             */            public static function orWhereRowValues($columns, $operator, $values)\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->orWhereRowValues($columns, $operator, $values);\n            }\n                    /**\n             * Add a "where JSON contains" clause to the query.\n             *\n             * @param string $column\n             * @param mixed $value\n             * @param string $boolean\n             * @param bool $not\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @static\n             */            public static function whereJsonContains($column, $value, $boolean = \'and\', $not = false)\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->whereJsonContains($column, $value, $boolean, $not);\n            }\n                    /**\n             * Add a "or where JSON contains" clause to the query.\n             *\n             * @param string $column\n             * @param mixed $value\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @static\n             */            public static function orWhereJsonContains($column, $value)\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->orWhereJsonContains($column, $value);\n            }\n                    /**\n             * Add a "where JSON not contains" clause to the query.\n             *\n             * @param string $column\n             * @param mixed $value\n             * @param string $boolean\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @static\n             */            public static function whereJsonDoesntContain($column, $value, $boolean = \'and\')\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->whereJsonDoesntContain($column, $value, $boolean);\n            }\n                    /**\n             * Add a "or where JSON not contains" clause to the query.\n             *\n             * @param string $column\n             * @param mixed $value\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @static\n             */            public static function orWhereJsonDoesntContain($column, $value)\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->orWhereJsonDoesntContain($column, $value);\n            }\n                    /**\n             * Add a "where JSON length" clause to the query.\n             *\n             * @param string $column\n             * @param mixed $operator\n             * @param mixed $value\n             * @param string $boolean\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @static\n             */            public static function whereJsonLength($column, $operator, $value = null, $boolean = \'and\')\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->whereJsonLength($column, $operator, $value, $boolean);\n            }\n                    /**\n             * Add a "or where JSON length" clause to the query.\n             *\n             * @param string $column\n             * @param mixed $operator\n             * @param mixed $value\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @static\n             */            public static function orWhereJsonLength($column, $operator, $value = null)\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->orWhereJsonLength($column, $operator, $value);\n            }\n                    /**\n             * Handles dynamic "where" clauses to the query.\n             *\n             * @param string $method\n             * @param array $parameters\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @static\n             */            public static function dynamicWhere($method, $parameters)\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->dynamicWhere($method, $parameters);\n            }\n                    /**\n             * Add a "group by" clause to the query.\n             *\n             * @param array|string $groups\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @static\n             */            public static function groupBy(...$groups)\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->groupBy(...$groups);\n            }\n                    /**\n             * Add a raw groupBy clause to the query.\n             *\n             * @param string $sql\n             * @param array $bindings\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @static\n             */            public static function groupByRaw($sql, $bindings = [])\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->groupByRaw($sql, $bindings);\n            }\n                    /**\n             * Add a "having" clause to the query.\n             *\n             * @param string $column\n             * @param string|null $operator\n             * @param string|null $value\n             * @param string $boolean\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @static\n             */            public static function having($column, $operator = null, $value = null, $boolean = \'and\')\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->having($column, $operator, $value, $boolean);\n            }\n                    /**\n             * Add a "or having" clause to the query.\n             *\n             * @param string $column\n             * @param string|null $operator\n             * @param string|null $value\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @static\n             */            public static function orHaving($column, $operator = null, $value = null)\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->orHaving($column, $operator, $value);\n            }\n                    /**\n             * Add a "having between " clause to the query.\n             *\n             * @param string $column\n             * @param array $values\n             * @param string $boolean\n             * @param bool $not\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @static\n             */            public static function havingBetween($column, $values, $boolean = \'and\', $not = false)\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->havingBetween($column, $values, $boolean, $not);\n            }\n                    /**\n             * Add a raw having clause to the query.\n             *\n             * @param string $sql\n             * @param array $bindings\n             * @param string $boolean\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @static\n             */            public static function havingRaw($sql, $bindings = [], $boolean = \'and\')\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->havingRaw($sql, $bindings, $boolean);\n            }\n                    /**\n             * Add a raw or having clause to the query.\n             *\n             * @param string $sql\n             * @param array $bindings\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @static\n             */            public static function orHavingRaw($sql, $bindings = [])\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->orHavingRaw($sql, $bindings);\n            }\n                    /**\n             * Add an "order by" clause to the query.\n             *\n             * @param \\Closure|\\Illuminate\\Database\\Query\\Builder|\\Illuminate\\Database\\Query\\Expression|string $column\n             * @param string $direction\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @throws \\InvalidArgumentException\n             * @static\n             */            public static function orderBy($column, $direction = \'asc\')\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->orderBy($column, $direction);\n            }\n                    /**\n             * Add a descending "order by" clause to the query.\n             *\n             * @param string $column\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @static\n             */            public static function orderByDesc($column)\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->orderByDesc($column);\n            }\n                    /**\n             * Put the query\'s results in random order.\n             *\n             * @param string $seed\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @static\n             */            public static function inRandomOrder($seed = \'\')\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->inRandomOrder($seed);\n            }\n                    /**\n             * Add a raw "order by" clause to the query.\n             *\n             * @param string $sql\n             * @param array $bindings\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @static\n             */            public static function orderByRaw($sql, $bindings = [])\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->orderByRaw($sql, $bindings);\n            }\n                    /**\n             * Alias to set the "offset" value of the query.\n             *\n             * @param int $value\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @static\n             */            public static function skip($value)\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->skip($value);\n            }\n                    /**\n             * Set the "offset" value of the query.\n             *\n             * @param int $value\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @static\n             */            public static function offset($value)\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->offset($value);\n            }\n                    /**\n             * Alias to set the "limit" value of the query.\n             *\n             * @param int $value\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @static\n             */            public static function take($value)\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->take($value);\n            }\n                    /**\n             * Set the "limit" value of the query.\n             *\n             * @param int $value\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @static\n             */            public static function limit($value)\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->limit($value);\n            }\n                    /**\n             * Set the limit and offset for a given page.\n             *\n             * @param int $page\n             * @param int $perPage\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @static\n             */            public static function forPage($page, $perPage = 15)\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->forPage($page, $perPage);\n            }\n                    /**\n             * Constrain the query to the previous "page" of results before a given ID.\n             *\n             * @param int $perPage\n             * @param int|null $lastId\n             * @param string $column\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @static\n             */            public static function forPageBeforeId($perPage = 15, $lastId = 0, $column = \'id\')\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->forPageBeforeId($perPage, $lastId, $column);\n            }\n                    /**\n             * Constrain the query to the next "page" of results after a given ID.\n             *\n             * @param int $perPage\n             * @param int|null $lastId\n             * @param string $column\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @static\n             */            public static function forPageAfterId($perPage = 15, $lastId = 0, $column = \'id\')\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->forPageAfterId($perPage, $lastId, $column);\n            }\n                    /**\n             * Remove all existing orders and optionally add a new order.\n             *\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @static\n             */            public static function reorder($column = null, $direction = \'asc\')\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->reorder($column, $direction);\n            }\n                    /**\n             * Add a union statement to the query.\n             *\n             * @param \\Illuminate\\Database\\Query\\Builder|\\Closure $query\n             * @param bool $all\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @static\n             */            public static function union($query, $all = false)\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->union($query, $all);\n            }\n                    /**\n             * Add a union all statement to the query.\n             *\n             * @param \\Illuminate\\Database\\Query\\Builder|\\Closure $query\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @static\n             */            public static function unionAll($query)\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->unionAll($query);\n            }\n                    /**\n             * Lock the selected rows in the table.\n             *\n             * @param string|bool $value\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @static\n             */            public static function lock($value = true)\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->lock($value);\n            }\n                    /**\n             * Lock the selected rows in the table for updating.\n             *\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @static\n             */            public static function lockForUpdate()\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->lockForUpdate();\n            }\n                    /**\n             * Share lock the selected rows in the table.\n             *\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @static\n             */            public static function sharedLock()\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->sharedLock();\n            }\n                    /**\n             * Get the SQL representation of the query.\n             *\n             * @return string\n             * @static\n             */            public static function toSql()\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->toSql();\n            }\n                    /**\n             * Get the count of the total records for the paginator.\n             *\n             * @param array $columns\n             * @return int\n             * @static\n             */            public static function getCountForPagination($columns = [])\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->getCountForPagination($columns);\n            }\n                    /**\n             * Concatenate values of a given column as a string.\n             *\n             * @param string $column\n             * @param string $glue\n             * @return string\n             * @static\n             */            public static function implode($column, $glue = \'\')\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->implode($column, $glue);\n            }\n                    /**\n             * Determine if any rows exist for the current query.\n             *\n             * @return bool\n             * @static\n             */            public static function exists()\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->exists();\n            }\n                    /**\n             * Determine if no rows exist for the current query.\n             *\n             * @return bool\n             * @static\n             */            public static function doesntExist()\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->doesntExist();\n            }\n                    /**\n             * Execute the given callback if no rows exist for the current query.\n             *\n             * @param \\Closure $callback\n             * @return mixed\n             * @static\n             */            public static function existsOr($callback)\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->existsOr($callback);\n            }\n                    /**\n             * Execute the given callback if rows exist for the current query.\n             *\n             * @param \\Closure $callback\n             * @return mixed\n             * @static\n             */            public static function doesntExistOr($callback)\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->doesntExistOr($callback);\n            }\n                    /**\n             * Retrieve the "count" result of the query.\n             *\n             * @param string $columns\n             * @return int\n             * @static\n             */            public static function count($columns = \'*\')\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->count($columns);\n            }\n                    /**\n             * Retrieve the minimum value of a given column.\n             *\n             * @param string $column\n             * @return mixed\n             * @static\n             */            public static function min($column)\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->min($column);\n            }\n                    /**\n             * Retrieve the maximum value of a given column.\n             *\n             * @param string $column\n             * @return mixed\n             * @static\n             */            public static function max($column)\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->max($column);\n            }\n                    /**\n             * Retrieve the sum of the values of a given column.\n             *\n             * @param string $column\n             * @return mixed\n             * @static\n             */            public static function sum($column)\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->sum($column);\n            }\n                    /**\n             * Retrieve the average of the values of a given column.\n             *\n             * @param string $column\n             * @return mixed\n             * @static\n             */            public static function avg($column)\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->avg($column);\n            }\n                    /**\n             * Alias for the "avg" method.\n             *\n             * @param string $column\n             * @return mixed\n             * @static\n             */            public static function average($column)\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->average($column);\n            }\n                    /**\n             * Execute an aggregate function on the database.\n             *\n             * @param string $function\n             * @param array $columns\n             * @return mixed\n             * @static\n             */            public static function aggregate($function, $columns = [])\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->aggregate($function, $columns);\n            }\n                    /**\n             * Execute a numeric aggregate function on the database.\n             *\n             * @param string $function\n             * @param array $columns\n             * @return float|int\n             * @static\n             */            public static function numericAggregate($function, $columns = [])\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->numericAggregate($function, $columns);\n            }\n                    /**\n             * Insert a new record into the database.\n             *\n             * @param array $values\n             * @return bool\n             * @static\n             */            public static function insert($values)\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->insert($values);\n            }\n                    /**\n             * Insert a new record into the database while ignoring errors.\n             *\n             * @param array $values\n             * @return int\n             * @static\n             */            public static function insertOrIgnore($values)\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->insertOrIgnore($values);\n            }\n                    /**\n             * Insert a new record and get the value of the primary key.\n             *\n             * @param array $values\n             * @param string|null $sequence\n             * @return int\n             * @static\n             */            public static function insertGetId($values, $sequence = null)\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->insertGetId($values, $sequence);\n            }\n                    /**\n             * Insert new records into the table using a subquery.\n             *\n             * @param array $columns\n             * @param \\Closure|\\Illuminate\\Database\\Query\\Builder|string $query\n             * @return int\n             * @static\n             */            public static function insertUsing($columns, $query)\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->insertUsing($columns, $query);\n            }\n                    /**\n             * Insert or update a record matching the attributes, and fill it with values.\n             *\n             * @param array $attributes\n             * @param array $values\n             * @return bool\n             * @static\n             */            public static function updateOrInsert($attributes, $values = [])\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->updateOrInsert($attributes, $values);\n            }\n                    /**\n             * Run a truncate statement on the table.\n             *\n             * @return void\n             * @static\n             */            public static function truncate()\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                $instance->truncate();\n            }\n                    /**\n             * Create a raw database expression.\n             *\n             * @param mixed $value\n             * @return \\Illuminate\\Database\\Query\\Expression\n             * @static\n             */            public static function raw($value)\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->raw($value);\n            }\n                    /**\n             * Get the current query value bindings in a flattened array.\n             *\n             * @return array\n             * @static\n             */            public static function getBindings()\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->getBindings();\n            }\n                    /**\n             * Get the raw array of bindings.\n             *\n             * @return array\n             * @static\n             */            public static function getRawBindings()\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->getRawBindings();\n            }\n                    /**\n             * Set the bindings on the query builder.\n             *\n             * @param array $bindings\n             * @param string $type\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @throws \\InvalidArgumentException\n             * @static\n             */            public static function setBindings($bindings, $type = \'where\')\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->setBindings($bindings, $type);\n            }\n                    /**\n             * Add a binding to the query.\n             *\n             * @param mixed $value\n             * @param string $type\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @throws \\InvalidArgumentException\n             * @static\n             */            public static function addBinding($value, $type = \'where\')\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->addBinding($value, $type);\n            }\n                    /**\n             * Merge an array of bindings into our bindings.\n             *\n             * @param \\Illuminate\\Database\\Query\\Builder $query\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @static\n             */            public static function mergeBindings($query)\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->mergeBindings($query);\n            }\n                    /**\n             * Get the database query processor instance.\n             *\n             * @return \\Illuminate\\Database\\Query\\Processors\\Processor\n             * @static\n             */            public static function getProcessor()\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->getProcessor();\n            }\n                    /**\n             * Get the query grammar instance.\n             *\n             * @return \\Illuminate\\Database\\Query\\Grammars\\Grammar\n             * @static\n             */            public static function getGrammar()\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->getGrammar();\n            }\n                    /**\n             * Use the write pdo for query.\n             *\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @static\n             */            public static function useWritePdo()\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->useWritePdo();\n            }\n                    /**\n             * Clone the query without the given properties.\n             *\n             * @param array $properties\n             * @return static\n             * @static\n             */            public static function cloneWithout($properties)\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->cloneWithout($properties);\n            }\n                    /**\n             * Clone the query without the given bindings.\n             *\n             * @param array $except\n             * @return static\n             * @static\n             */            public static function cloneWithoutBindings($except)\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->cloneWithoutBindings($except);\n            }\n                    /**\n             * Dump the current SQL and bindings.\n             *\n             * @return \\Illuminate\\Database\\Query\\Builder\n             * @static\n             */            public static function dump()\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->dump();\n            }\n                    /**\n             * Die and dump the current SQL and bindings.\n             *\n             * @return void\n             * @static\n             */            public static function dd()\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                $instance->dd();\n            }\n                    /**\n             * Register a custom macro.\n             *\n             * @param string $name\n             * @param object|callable $macro\n             * @return void\n             * @static\n             */            public static function macro($name, $macro)\n            {\n                                \\Illuminate\\Database\\Query\\Builder::macro($name, $macro);\n            }\n                    /**\n             * Mix another object into the class.\n             *\n             * @param object $mixin\n             * @param bool $replace\n             * @return void\n             * @throws \\ReflectionException\n             * @static\n             */            public static function mixin($mixin, $replace = true)\n            {\n                                \\Illuminate\\Database\\Query\\Builder::mixin($mixin, $replace);\n            }\n                    /**\n             * Dynamically handle calls to the class.\n             *\n             * @param string $method\n             * @param array $parameters\n             * @return mixed\n             * @throws \\BadMethodCallException\n             * @static\n             */            public static function macroCall($method, $parameters)\n            {\n                                /** @var \\Illuminate\\Database\\Query\\Builder $instance */\n                                return $instance->macroCall($method, $parameters);\n            }\n        }\n\n    class Event extends \\Illuminate\\Support\\Facades\\Event {}\n\n    class File extends \\Illuminate\\Support\\Facades\\File {}\n\n    class Gate extends \\Illuminate\\Support\\Facades\\Gate {}\n\n    class Hash extends \\Illuminate\\Support\\Facades\\Hash {}\n\n    class Http extends \\Illuminate\\Support\\Facades\\Http {}\n\n    class Lang extends \\Illuminate\\Support\\Facades\\Lang {}\n\n    class Log extends \\Illuminate\\Support\\Facades\\Log {}\n\n    class Mail extends \\Illuminate\\Support\\Facades\\Mail {}\n\n    class Notification extends \\Illuminate\\Support\\Facades\\Notification {}\n\n    class Password extends \\Illuminate\\Support\\Facades\\Password {}\n\n    class Queue extends \\Illuminate\\Support\\Facades\\Queue {}\n\n    class Redirect extends \\Illuminate\\Support\\Facades\\Redirect {}\n\n    class Request extends \\Illuminate\\Support\\Facades\\Request {}\n\n    class Response extends \\Illuminate\\Support\\Facades\\Response {}\n\n    class Route extends \\Illuminate\\Support\\Facades\\Route {}\n\n    class Schema extends \\Illuminate\\Support\\Facades\\Schema {}\n\n    class Session extends \\Illuminate\\Support\\Facades\\Session {}\n\n    class Storage extends \\Illuminate\\Support\\Facades\\Storage {}\n\n    class Str extends \\Illuminate\\Support\\Str {}\n\n    class URL extends \\Illuminate\\Support\\Facades\\URL {}\n\n    class Validator extends \\Illuminate\\Support\\Facades\\Validator {}\n\n    class View extends \\Illuminate\\Support\\Facades\\View {}\n\n    class Debugbar extends \\Barryvdh\\Debugbar\\Facade {}\n\n    class Flare extends \\Facade\\Ignition\\Facades\\Flare {}\n}\n'),a.workspace.applyEdit(this.workspaceEdit).then(()=>{a.window.showInformationMessage("Ide helper file was created!")}),a.workspace.openTextDocument(n).then(n=>{n.save()})}static insertToGitignore(){const n=this.getGitignoreUri();let t=0;a.workspace.openTextDocument(n).then(e=>{e.getText().includes(this.fileName)||(t=e.lineCount-1,this.workspaceEdit.insert(n,new a.Position(t,0),this.fileName),a.workspace.applyEdit(this.workspaceEdit).then(()=>{e.save()}))})}static getFileUri(){return a.Uri.file(this.getIdeHelperPath())}static getGitignoreUri(){return a.Uri.file(o(".gitignore"))}static getIdeHelperPath(){return o(this.fileName)}}I.content=[],I.workspaceEdit=new a.WorkspaceEdit,I.fileName="_ide_helper.php";class _{constructor(){this.elements=null,this.syncConfig()}async provideCompletionItems(n,t){let e=[];if(!new g(n,t).hasConfig())return e;Object(r.isNull)(this.elements)&&await this.syncConfig();for(let i of this.elements){const r=new a.CompletionItem(i,a.CompletionItemKind.Constant);r.range=n.getWordRangeAtPosition(t,/[\w\d\-_\.\:\\\/]+/g),e.push(r)}return e}async syncConfig(){await m.run("$configs = app('config')->all();class ConfigTransformer {protected $items = [];public function __construct(){$this->items = collect();}public function transform($keys, $alias = ''){return collect($keys)->map(function ($keys, $index) use ($alias) {if ($alias) {$alias = $alias .'.';}if (! is_string($index)) {return;}$alias .= $index;if (is_array($keys)) {return $this->transform($keys, $alias);} else {$this->items->push($alias);return $keys;}});}public function all(): array{return $this->items->filter(function ($config, $key) {return strpos($config, 'app.providers') === false && strpos($config, 'filesystems.links') === false && strpos($config, 'app.aliases') === false;})->toArray();}}$config = new ConfigTransformer();$config->transform($configs);echo json_encode($config->all());").then(n=>{n&&(this.elements=Object.values(JSON.parse(n)))})}}class k{constructor(){this.routes=null,this.syncRoutes()}async provideCompletionItems(n,t){let e=[];if(!new g(n,t).hasRoute())return e;Object(r.isNull)(this.routes)&&await this.syncRoutes();for(let i of this.routes){const r=new a.CompletionItem(i,a.CompletionItemKind.Constant);r.range=n.getWordRangeAtPosition(t,/[\w\d\-_\.\:\\\/]+/g),e.push(r)}return e}async syncRoutes(){await m.run("function getRoutes($routers){$routes = [];if (is_array($routers)) {foreach ($routers as $key => $router) {if (array_key_exists('as', $router['action'])) {$routes[] = $router['action']['as'];}}return $routes;}foreach ($routers as $router) {$routes[] = $router->getName();}return $routes;}$routers = app('router')->getRoutes();echo json_encode(array_filter(getRoutes($routers)));").then(n=>{n&&(this.routes=Object.values(JSON.parse(n)))})}}class T{constructor(){this.translations=null,this.syncTranslations()}async provideCompletionItems(n,t){let e=[];if(!new g(n,t).hasTranslation())return e;Object(r.isNull)(this.translations)&&await this.syncTranslations();for(let i of this.translations){const r=new a.CompletionItem(i,a.CompletionItemKind.Constant);r.range=n.getWordRangeAtPosition(t,/[\w\d\-_\.\:\\\/]+/g),e.push(r)}return e}async syncTranslations(){const n=await m.run("$filesystem = (new Illuminate\\Filesystem\\Filesystem);if (! $filesystem->exists(resource_path('lang/en'))) {return;}$files = $filesystem->files(resource_path('lang/en'));$translations = [];foreach ($files as $file) {$fileName = str_replace('.php', '', $file->getFileName());$fields = include($file->getPathName());if (is_array($fields)) {foreach ($fields as $field => $message) {$translations[] = \"{$fileName}.{$field}\";}}}echo json_encode(array_filter($translations));");n&&(this.translations=Object.values(JSON.parse(n)))}}function x(n){i.existsSync(o("artisan"))&&(n.subscriptions.push(a.commands.registerCommand("generate_ide_helper",()=>I.generate())),n.subscriptions.push(a.languages.registerCompletionItemProvider(l,new v,...u)),n.subscriptions.push(a.languages.registerCompletionItemProvider(l,new y,...u)),n.subscriptions.push(a.languages.registerCompletionItemProvider(l,new _,...u)),n.subscriptions.push(a.languages.registerCompletionItemProvider(l,new k,...u)),n.subscriptions.push(a.languages.registerCompletionItemProvider(l,new T,...u)))}function C(){}}]);
//# sourceMappingURL=extension.js.map