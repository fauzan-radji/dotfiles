"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class BaseMessageStream {
    constructor() {
        this.unreadMessages = [];
        this.id = BaseMessageStream.id++;
        let onConnectionClosed;
        this.onClosed = new Promise(resolve => (onConnectionClosed = resolve));
        this.onConnectionClosed = onConnectionClosed;
    }
    /**
     * Call this in derived classes to signal a new message.
     */
    onMessage(message) {
        const hasReadAllQueuedMessages = this.unreadMessages.length === 0;
        if (hasReadAllQueuedMessages && this.onMessageCallback)
            this.onMessageCallback(message);
        else
            this.unreadMessages.push(message);
    }
    /**
     * Sets a callback for incoming messages.
     */
    setReadCallback(callback) {
        this.onMessageCallback = callback;
        if (!callback)
            return;
        while (this.unreadMessages.length > 0) {
            const msg = this.unreadMessages.shift();
            callback(msg);
        }
    }
}
BaseMessageStream.id = 0;
exports.BaseMessageStream = BaseMessageStream;
/**
 * Intercepts a stream for logging.
 */
class StreamLogger {
    constructor(baseStream, logger) {
        this.baseStream = baseStream;
        this.logger = logger;
    }
    get onClosed() {
        return this.baseStream.onClosed;
    }
    setReadCallback(callback) {
        if (callback === undefined) {
            this.baseStream.setReadCallback(undefined);
            return;
        }
        this.baseStream.setReadCallback(readMessage => {
            this.logger.log(this.baseStream, "incoming", readMessage);
            callback(readMessage);
        });
    }
    write(message) {
        this.logger.log(this.baseStream, "outgoing", message);
        return this.baseStream.write(message);
    }
    toString() {
        return `StreamLogger/${this.baseStream.toString()}`;
    }
}
exports.StreamLogger = StreamLogger;
/**
 * Logs messages to a `RpcLogger`.
 */
class RpcStreamLogger extends StreamLogger {
    constructor(baseStream, rpcLogger) {
        super(baseStream, {
            log: (stream, type, message) => {
                const char = type === "incoming" ? "<-" : "->";
                rpcLogger.trace({
                    text: `${char} [${stream.toString()}] ${JSON.stringify(message)}`,
                    message: message,
                });
            },
        });
    }
}
exports.RpcStreamLogger = RpcStreamLogger;
/**
 * Logs messages to `console`.
 */
class ConsoleStreamLogger extends StreamLogger {
    constructor(baseStream) {
        super(baseStream, {
            log: (stream, type, message) => {
                const char = type === "incoming" ? "<-" : "->";
                console.log(`${char} [${stream.toString()}] ${JSON.stringify(message)}`);
            },
        });
    }
}
exports.ConsoleStreamLogger = ConsoleStreamLogger;
//# sourceMappingURL=MessageStream.js.map