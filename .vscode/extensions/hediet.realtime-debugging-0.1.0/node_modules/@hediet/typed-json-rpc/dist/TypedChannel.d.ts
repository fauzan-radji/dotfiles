import * as t from "io-ts";
import { Disposable } from "@hediet/std/disposable";
import { ChannelFactory, RequestObject } from "./Channel";
import { RequestId, ErrorCode, JSONValue, JSONArray, JSONObject } from "./JsonRpcTypes";
import { RpcLogger } from "./Logger";
import { MessageStream } from ".";
export declare type RuntimeJsonType<T> = t.Type<T, JSONValue, unknown>;
export declare type RuntimeJsonTypeArrOrObj<T> = t.Type<T, JSONObject | JSONArray, unknown>;
export declare type Result<TOk, TError> = OkResult<TOk> | ErrorResult<TError>;
export interface OkResult<TOk> {
    ok: TOk;
}
export declare type ErrorResult<TError> = {
    error: TError;
    errorMessage?: string;
    errorCode?: ErrorCode;
} | {
    error?: TError;
    errorMessage: string;
    errorCode?: ErrorCode;
};
export declare type RequestHandlerFunc<TArg, TResult, TError> = (arg: TArg, requestId: RequestId) => Promise<Result<TResult, TError>>;
export declare type NotificationHandlerFunc<TArg> = (arg: TArg) => void;
/**
 * Represents a typed channel.
 * Call `startListen` to create the underlying channel
 * and to start processing all incoming messages.
 * At this point, all request and notification handlers should be registered.
 */
export declare class TypedChannel {
    private readonly channelCtor;
    private readonly logger;
    static fromStream(stream: MessageStream, logger: RpcLogger | undefined): TypedChannel;
    private channel;
    private readonly handler;
    private readonly unknownNotificationHandler;
    private timeout;
    sendExceptionDetails: boolean;
    constructor(channelCtor: ChannelFactory, logger: RpcLogger | undefined);
    private listeningDeferred;
    onListening: Promise<void>;
    /**
     * This method must be called to forward messages from the stream to this channel.
     * This is not done automatically on construction so that this instance
     * can be setup properly before handling messages.
     */
    startListen(): void;
    private checkChannel;
    private handleRequest;
    private handleNotification;
    registerUnknownNotificationHandler(handler: (notification: RequestObject) => void): Disposable;
    registerRequestHandler<TArgs, TResponse, TError>(requestType: RequestType<TArgs, TResponse, TError>, handler: RequestHandlerFunc<TArgs, TResponse, TError>): Disposable;
    registerNotificationHandler<TArgs>(type: NotificationType<TArgs>, handler: NotificationHandlerFunc<TArgs>): Disposable;
    getRegisteredTypes(): Array<RequestType | NotificationType>;
    request<TParams, TResponse>(requestType: RequestType<TParams, TResponse, unknown>, args: TParams): Promise<TResponse>;
    notify<TParams>(notificationType: NotificationType<TParams>, params: TParams): void;
}
/**
 * Is thrown when handling the request raised an error.
 */
export declare class RequestHandlingError<T = any> extends Error {
    readonly data?: T | undefined;
    readonly code: ErrorCode;
    constructor(message: string, data?: T | undefined, code?: ErrorCode);
}
/**
 * Describes a request type.
 */
export declare class RequestType<TParams = unknown, TResponse = unknown, TError = unknown, TMethod = string> {
    readonly method: TMethod;
    readonly paramType: RuntimeJsonTypeArrOrObj<TParams>;
    readonly resultType: RuntimeJsonType<TResponse>;
    readonly errorType: RuntimeJsonType<TError>;
    readonly kind: "request";
    constructor(method: TMethod, paramType: RuntimeJsonTypeArrOrObj<TParams>, resultType: RuntimeJsonType<TResponse>, errorType: RuntimeJsonType<TError>);
    withMethod(method: string): RequestType<TParams, TResponse, TError, string>;
}
/**
 * Describes a notification type.
 */
export declare class NotificationType<TParams = unknown, TMethod = string> {
    readonly method: TMethod;
    readonly paramType: RuntimeJsonTypeArrOrObj<TParams>;
    readonly kind: "notification";
    constructor(method: TMethod, paramType: RuntimeJsonTypeArrOrObj<TParams>);
    withMethod(method: string): NotificationType<TParams, string>;
}
export declare const voidType: t.Type<void, JSONValue, any>;
/**
 * Describes a request type.
 */
export declare function request<TParams extends RuntimeJsonTypeArrOrObj<any> = RuntimeJsonTypeArrOrObj<{}>, TResult extends RuntimeJsonType<any> = RuntimeJsonType<void>, TError extends RuntimeJsonType<any> = RuntimeJsonType<undefined>>(method: string, request: {
    params?: TParams;
    result?: TResult;
    error?: TError;
}): RequestType<TParams["_A"], TResult["_A"], TError["_A"]>;
/**
 * Describes a notification type without static type validation.
 */
export declare function rawNotification(method: string): NotificationType<JSONObject | JSONArray | undefined>;
/**
 * Describes a notification type.
 */
export declare function notification<TParams extends RuntimeJsonTypeArrOrObj<{}>>(method: string, notification: {
    params?: TParams;
}): NotificationType<TParams["_A"]>;
//# sourceMappingURL=TypedChannel.d.ts.map