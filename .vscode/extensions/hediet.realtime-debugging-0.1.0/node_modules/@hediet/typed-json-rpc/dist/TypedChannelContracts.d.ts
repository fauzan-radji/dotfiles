import { RequestType, NotificationType, TypedChannel, RuntimeJsonType, RuntimeJsonTypeArrOrObj, ErrorResult } from "./TypedChannel";
import { RequestId } from "./JsonRpcTypes";
import { MessageStream } from "./MessageStream";
import { RpcLogger } from "./Logger";
import { Disposable } from "@hediet/std/disposable";
/**
 * Describes a request type as part of a `Contract`.
 * The method is inferred from its position in the contract if not provided.
 */
export declare type ContractRequestType<TParams = unknown, TResult = unknown, TError = unknown> = RequestType<TParams, TResult, TError, string | undefined>;
export declare type AnyRequestContract = ContractRequestType<any, any, any>;
export declare type AsRequestContract<T extends AnyRequestContract> = T;
/**
 * Describes a notification type as part of a `Contract`.
 * The method is inferred from its position in the contract if not provided.
 */
export declare type ContractNotificationType<TArgs = unknown> = NotificationType<TArgs, string | undefined>;
export declare type AsNotificationContract<T extends ContractNotificationType> = T;
/**
 * Describes a request type as part of a `Contract`.
 */
export declare function requestContract<TParams extends RuntimeJsonTypeArrOrObj<any> = RuntimeJsonTypeArrOrObj<{}>, TResult extends RuntimeJsonType<any> = RuntimeJsonType<void>, TError extends RuntimeJsonType<any> = RuntimeJsonType<undefined>>(request: {
    method?: string;
    params?: TParams;
    result?: TResult;
    error?: TError;
}): ContractRequestType<TParams["_A"], TResult["_A"], TError["_A"]>;
/**
 * Describes a notification type as part of a `Contract`.
 */
export declare function notificationContract<TParams extends RuntimeJsonTypeArrOrObj<any> = RuntimeJsonTypeArrOrObj<{}>>(notification: {
    method?: string;
    params?: TParams;
}): ContractNotificationType<TParams["_A"]>;
/**
 * Describes one side of a contract.
 */
export declare type OneSideContract = Record<string, AnyRequestContract | ContractNotificationType<any>>;
export declare type AsOneSideContract<T extends OneSideContract> = T;
export declare type ContractToRequest<TRequestMap extends OneSideContract> = {
    [TRequest in keyof TRequestMap]: TRequestMap[TRequest] extends AnyRequestContract ? RequestType<TRequestMap[TRequest]["paramType"]["_A"], TRequestMap[TRequest]["resultType"]["_A"], TRequestMap[TRequest]["errorType"]["_A"]> : NotificationType<TRequestMap[TRequest]["paramType"]["_A"]>;
};
export declare type EmptyObjectToVoid<T> = {} extends T ? (void | T) : T;
export declare type ContractInterfaceOf<TRequestMap extends OneSideContract> = {
    [TRequest in keyof TRequestMap]: TRequestMap[TRequest] extends AnyRequestContract ? (arg: EmptyObjectToVoid<TRequestMap[TRequest]["paramType"]["_A"]>) => Promise<TRequestMap[TRequest]["resultType"]["_A"]> : (arg: EmptyObjectToVoid<TRequestMap[TRequest]["paramType"]["_A"]>) => void;
};
/** Marks a type as error wrapper. */
export declare const IsErrorWrapper: unique symbol;
/**
 * Wraps an error so that it can be distinguished from a successfully returned result.
 */
export declare class ErrorWrapper<TError> {
    readonly error: ErrorResult<TError>;
    static factory: (error: ErrorResult<unknown>) => ErrorWrapper<unknown>;
    [IsErrorWrapper]: true;
    constructor(error: ErrorResult<TError>);
}
export declare type ContractHandlerOf<TRequestMap extends OneSideContract, TCounterPartRequestMap extends OneSideContract, TContext> = {
    [TKey in RequestKeys<TRequestMap>]: TRequestMap[TKey] extends AnyRequestContract ? (arg: TRequestMap[TKey]["paramType"]["_A"], info: RequestHandlerInfo<TRequestMap[TKey]["errorType"]["_A"], ContractInterfaceOf<TCounterPartRequestMap>, TContext>) => Promise<TRequestMap[TKey]["resultType"]["_A"] | ErrorWrapper<TRequestMap[TKey]["errorType"]["_A"]>> : never;
} & {
    [TKey in NotificationKeys<TRequestMap>]?: (arg: TRequestMap[TKey]["paramType"]["_A"], info: HandlerInfo<ContractInterfaceOf<TCounterPartRequestMap>, TContext>) => void;
};
export declare type RequestKeys<TRequestMap extends OneSideContract> = {
    [TRequest in keyof TRequestMap]: TRequestMap[TRequest] extends AnyRequestContract ? TRequest : never;
}[keyof TRequestMap];
export declare type NotificationKeys<TRequestMap extends OneSideContract> = {
    [TRequest in keyof TRequestMap]: TRequestMap[TRequest] extends AnyRequestContract ? never : TRequest;
}[keyof TRequestMap];
/**
 * Describes a contract.
 */
export interface ContractObject {
    server: OneSideContract;
    client: OneSideContract;
}
/**
 * Describes a new contract.
 */
export declare function contract<TContractObject extends ContractObject>(contractObj: TContractObject): Contract<never, TContractObject>;
export declare function contract<TTags extends string, TContractObject extends ContractObject>(tags: TTags[], contractObj: TContractObject): Contract<TTags, TContractObject>;
/**
 * Provides additional information when handling a request or a notification.
 */
export interface HandlerInfo<TCounterPart, TContext = never> {
    context: TContext;
    /**
     * The implementation of the other contract.
     */
    counterpart: TCounterPart;
}
/**
 * Provides additional information when handling a request.
 */
export interface RequestHandlerInfo<TError, TCounterPart, TContext = never> extends HandlerInfo<TCounterPart, TContext> {
    /**
     * Creates a new error object that can be returned in request handlers.
     */
    newErr(error: ErrorResult<TError>): ErrorWrapper<TError>;
    /**
     * The id of the current request.
     */
    requestId: RequestId;
}
export declare abstract class AbstractContract<TTags extends string, TContractObject extends ContractObject> {
    readonly tags: TTags[];
    readonly server: ContractToRequest<TContractObject["server"]>;
    readonly client: ContractToRequest<TContractObject["client"]>;
    protected onlyDesignTime(): Error;
    readonly TContractObject: TContractObject;
    readonly TClientInterface: ContractInterfaceOf<TContractObject["client"]>;
    readonly TServerInterface: ContractInterfaceOf<TContractObject["server"]>;
    readonly TTags: TTags;
    constructor(tags: TTags[], server: ContractToRequest<TContractObject["server"]>, client: ContractToRequest<TContractObject["client"]>);
    protected getInterface<TContext>(typedChannel: TypedChannel, myContract: Record<string, NotificationType<any> | RequestType<any, any, any>>, otherContract: Record<string, NotificationType<any> | RequestType<any, any, any>>, myInterface: Record<string, Function>, context: TContext): {
        counterpart: Record<string, unknown>;
    } & Disposable;
    private buildCounterpart;
    private registerHandlers;
    private createRequestHandler;
}
export declare class Contract<TTags extends string, TContractObject extends ContractObject> extends AbstractContract<TTags, TContractObject> {
    readonly TClientHandler: ContractHandlerOf<TContractObject["client"], TContractObject["server"], undefined>;
    readonly TServerHandler: ContractHandlerOf<TContractObject["server"], TContractObject["client"], undefined>;
    /**
     * Gets a server object directly from a stream by constructing a new `TypedChannel`.
     * It also registers the client implementation to the stream.
     * The channel starts listening immediately.
     */
    getServerFromStream(stream: MessageStream, logger: RpcLogger | undefined, clientImplementation: this["TClientHandler"]): {
        server: ContractInterfaceOf<TContractObject["server"]>;
        channel: TypedChannel;
    };
    /**
     * Gets a client object directly from a stream by constructing a new `TypedChannel`.
     * It also registers the server implementation to the stream.
     * The channel starts listening immediately.
     */
    registerServerToStream(stream: MessageStream, logger: RpcLogger | undefined, serverImplementation: this["TServerHandler"]): {
        client: ContractInterfaceOf<TContractObject["client"]>;
        channel: TypedChannel;
    };
    getServer(typedChannel: TypedChannel, clientImplementation: this["TClientHandler"]): {
        server: ContractInterfaceOf<TContractObject["server"]>;
    } & Disposable;
    registerServer(typedChannel: TypedChannel, serverImplementation: this["TServerHandler"]): {
        client: ContractInterfaceOf<TContractObject["client"]>;
    } & Disposable;
    withContext<TContext>(): ContractWithContext<TTags, TContractObject, TContext>;
}
export declare class ContractWithContext<TTags extends string, TContractObject extends ContractObject, TContext> extends AbstractContract<TTags, TContractObject> {
    readonly TClientHandler: ContractHandlerOf<TContractObject["client"], TContractObject["server"], TContext>;
    readonly TServerHandler: ContractHandlerOf<TContractObject["server"], TContractObject["client"], TContext>;
    getServer(typedChannel: TypedChannel, context: TContext, clientImplementation: this["TClientHandler"]): {
        server: ContractInterfaceOf<TContractObject["server"]>;
    } & Disposable;
    registerServer(typedChannel: TypedChannel, context: TContext, serverImplementation: this["TServerHandler"]): {
        client: ContractInterfaceOf<TContractObject["client"]>;
    } & Disposable;
}
//# sourceMappingURL=TypedChannelContracts.d.ts.map