"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const t = require("io-ts");
const disposable_1 = require("@hediet/std/disposable");
const JsonRpcTypes_1 = require("./JsonRpcTypes");
const _1 = require(".");
const synchronization_1 = require("@hediet/std/synchronization");
const timer_1 = require("@hediet/std/timer");
/**
 * Represents a typed channel.
 * Call `startListen` to create the underlying channel
 * and to start processing all incoming messages.
 * At this point, all request and notification handlers should be registered.
 */
class TypedChannel {
    constructor(channelCtor, logger) {
        this.channelCtor = channelCtor;
        this.logger = logger;
        this.channel = undefined;
        this.handler = new Map();
        this.unknownNotificationHandler = new Set();
        this.sendExceptionDetails = false;
        this.listeningDeferred = new synchronization_1.Deferred();
        this.onListening = this.listeningDeferred.promise;
        if (process.env.NODE_ENV !== "production") {
            this.timeout = timer_1.startTimeout(1000, () => {
                if (!this.channel) {
                    console.warn(`"${this.startListen.name}" has not been called within 1 second after construction of this channel. ` +
                        `Did you forget to call it?`, this);
                }
            });
        }
    }
    static fromStream(stream, logger) {
        const channelFactory = _1.StreamBasedChannel.getFactory(stream, logger);
        return new TypedChannel(channelFactory, logger);
    }
    /**
     * This method must be called to forward messages from the stream to this channel.
     * This is not done automatically on construction so that this instance
     * can be setup properly before handling messages.
     */
    startListen() {
        if (this.channel) {
            throw new Error(`"${this.startListen.name}" can be called only once, but it already has been called.`);
        }
        if (this.timeout) {
            this.timeout.dispose();
            this.timeout = undefined;
        }
        this.channel = this.channelCtor.createChannel({
            handleRequest: (req, id) => this.handleRequest(req, id),
            handleNotification: req => this.handleNotification(req),
        });
        this.listeningDeferred.resolve();
    }
    checkChannel(channel) {
        if (!channel) {
            throw new Error(`"${this.startListen.name}" must be called before any messages can be sent or received.`);
        }
        return true;
    }
    async handleRequest(request, requestId) {
        const handler = this.handler.get(request.method);
        if (!handler) {
            if (this.logger) {
                this.logger.debug({
                    text: `No request handler for "${request.method}".`,
                    data: { requestObject: request },
                });
            }
            return {
                error: {
                    code: JsonRpcTypes_1.ErrorCode.methodNotFound,
                    message: `No request handler for "${request.method}".`,
                    data: { method: request.method },
                },
            };
        }
        if (handler.kind != "request") {
            const message = `"${request.method}" is registered as notification, but was sent as request.`;
            if (this.logger) {
                this.logger.debug({
                    text: message,
                    data: { requestObject: request },
                });
            }
            return {
                error: {
                    code: JsonRpcTypes_1.ErrorCode.invalidRequest,
                    message: message,
                    data: { method: request.method },
                },
            };
        }
        const decodeResult = handler.requestType.paramType.decode(request.params);
        if (decodeResult.isLeft()) {
            const message = `Got invalid params: ${decodeResult.value
                .map(e => e.message)
                .join(", ")}.`;
            if (this.logger) {
                this.logger.debug({
                    text: message,
                    data: {
                        requestObject: request,
                        errors: decodeResult.value,
                    },
                });
            }
            return {
                error: {
                    code: JsonRpcTypes_1.ErrorCode.invalidParams,
                    message,
                    data: {
                        errors: decodeResult.value.map(e => e.message || null),
                    },
                },
            };
        }
        else if (decodeResult.isRight()) {
            const args = decodeResult.value;
            let response;
            try {
                const result = await handler.handler(args, requestId);
                if ("error" in result || "errorMessage" in result) {
                    const errorData = handler.requestType.errorType.encode(result.error);
                    const code = result.errorCode || JsonRpcTypes_1.ErrorCode.genericApplicationError;
                    const message = result.errorMessage || "An error was returned";
                    response = {
                        error: {
                            code,
                            message,
                            data: errorData,
                        },
                    };
                }
                else {
                    const val = handler.requestType.resultType.encode(result.ok);
                    response = { result: val };
                }
            }
            catch (exception) {
                if (this.logger) {
                    this.logger.warn({
                        text: `An exception was thrown while handling a request: ${exception.toString()}.`,
                        exception,
                        data: { requestObject: request },
                    });
                }
                response = {
                    error: {
                        code: JsonRpcTypes_1.ErrorCode.unexpectedServerError,
                        message: this.sendExceptionDetails
                            ? `An exception was thrown while handling a request: ${exception.toString()}.`
                            : "Server has thrown an unexpected exception",
                    },
                };
            }
            return response;
        }
        else {
            throw new Error("Impossible");
        }
    }
    async handleNotification(request) {
        const handler = this.handler.get(request.method);
        if (!handler) {
            for (const h of this.unknownNotificationHandler) {
                h(request);
            }
            if (this.unknownNotificationHandler.size === 0) {
                if (this.logger) {
                    this.logger.debug({
                        text: `Unhandled notification "${request.method}"`,
                        data: { requestObject: request },
                    });
                }
            }
            return;
        }
        if (handler.kind != "notification") {
            if (this.logger) {
                this.logger.debug({
                    text: `"${request.method}" is registered as request, but was sent as notification.`,
                    data: { requestObject: request },
                });
            }
            // dont send a response back as we are handling a notification.
            return;
        }
        const decodeResult = handler.notificationType.paramType.decode(request.params);
        if (decodeResult.isLeft()) {
            if (this.logger) {
                this.logger.debug({
                    text: `Got invalid params: ${decodeResult.value
                        .map(e => e.message)
                        .join(", ")}.`,
                    data: {
                        requestObject: request,
                        errors: decodeResult.value,
                    },
                });
            }
            // dont send a response back as we are handling a notification.
            return;
        }
        const val = decodeResult.value;
        for (const handlerFunc of handler.handlers) {
            try {
                handlerFunc(val);
            }
            catch (exception) {
                if (this.logger) {
                    this.logger.warn({
                        text: `An exception was thrown while handling a notification: ${exception.toString()}.`,
                        exception,
                        data: { requestObject: request },
                    });
                }
            }
        }
        return;
    }
    registerUnknownNotificationHandler(handler) {
        return setAndDeleteOnDispose(this.unknownNotificationHandler, handler);
    }
    registerRequestHandler(requestType, handler) {
        const registeredHandler = this.handler.get(requestType.method);
        if (registeredHandler) {
            throw new Error(`Handler with method "${requestType.method}" already registered.`);
        }
        return setAndDeleteOnDispose(this.handler, requestType.method, {
            kind: "request",
            requestType,
            handler,
        });
    }
    registerNotificationHandler(type, handler) {
        let registeredHandler = this.handler.get(type.method);
        if (!registeredHandler) {
            registeredHandler = {
                kind: "notification",
                notificationType: type,
                handlers: new Set(),
            };
            this.handler.set(type.method, registeredHandler);
        }
        else {
            if (registeredHandler.kind !== "notification") {
                throw new Error(`Method "${type.method}" was already registered as request handler.`);
            }
            if (registeredHandler.notificationType !== type) {
                throw new Error(`Method "${type.method}" was registered for a different type.`);
            }
        }
        return setAndDeleteOnDispose(registeredHandler.handlers, handler);
    }
    getRegisteredTypes() {
        const result = [];
        for (const h of this.handler.values()) {
            if (h.kind === "notification") {
                result.push(h.notificationType);
            }
            else if (h.kind === "request") {
                result.push(h.requestType);
            }
        }
        return result;
    }
    async request(requestType, args) {
        if (!this.checkChannel(this.channel)) {
            throw new Error("Impossible");
        }
        let params = requestType.paramType.encode(args);
        const response = await this.channel.sendRequest({
            method: requestType.method,
            params,
        });
        if ("error" in response) {
            const e = new RequestHandlingError(response.error.message, response.error.data, response.error.code);
            throw e;
        }
        else {
            const result = requestType.resultType.decode(response.result);
            if (result.isLeft()) {
                throw new Error(result.value.map(e => e.message).join(", "));
            }
            else {
                return result.value;
            }
        }
    }
    notify(notificationType, params) {
        if (!this.checkChannel(this.channel)) {
            throw "";
        }
        let encodedParams = notificationType.paramType.encode(params);
        this.channel.sendNotification({
            method: notificationType.method,
            params: encodedParams,
        });
    }
}
exports.TypedChannel = TypedChannel;
/**
 * Is thrown when handling the request raised an error.
 */
class RequestHandlingError extends Error {
    constructor(message, data, code = JsonRpcTypes_1.ErrorCode.genericApplicationError) {
        super(message);
        this.data = data;
        this.code = code;
        Object.setPrototypeOf(this, RequestHandlingError.prototype);
    }
}
exports.RequestHandlingError = RequestHandlingError;
/**
 * Describes a request type.
 */
class RequestType {
    constructor(method, paramType, resultType, errorType) {
        this.method = method;
        this.paramType = paramType;
        this.resultType = resultType;
        this.errorType = errorType;
        this.kind = "request";
    }
    withMethod(method) {
        return new RequestType(method, this.paramType, this.resultType, this.errorType);
    }
}
exports.RequestType = RequestType;
/**
 * Describes a notification type.
 */
class NotificationType {
    constructor(method, paramType) {
        this.method = method;
        this.paramType = paramType;
        this.kind = "notification";
    }
    withMethod(method) {
        return new NotificationType(method, this.paramType);
    }
}
exports.NotificationType = NotificationType;
exports.voidType = new t.Type("void", (u) => u === undefined, (i, context) => {
    if (i === null) {
        return t.success(undefined);
    }
    return t.failure(i, context, "Given value is not 'null'.");
}, (_u) => null);
/**
 * Describes a request type.
 */
function request(method, request) {
    return new RequestType(method, request.params ? request.params : t.type({}), request.error ? request.error : exports.voidType, request.result ? request.result : exports.voidType);
}
exports.request = request;
/**
 * Describes a notification type without static type validation.
 */
function rawNotification(method) {
    return new NotificationType(method, t.any);
}
exports.rawNotification = rawNotification;
/**
 * Describes a notification type.
 */
function notification(method, notification) {
    return new NotificationType(method, notification.params ? notification.params : t.type({}));
}
exports.notification = notification;
function setAndDeleteOnDispose(set, keyOrItem, item) {
    if (set instanceof Set) {
        set.add(keyOrItem);
        return disposable_1.Disposable.create(() => set.delete(keyOrItem));
    }
    else {
        set.set(keyOrItem, item);
        return disposable_1.Disposable.create(() => set.delete(keyOrItem));
    }
}
//# sourceMappingURL=TypedChannel.js.map