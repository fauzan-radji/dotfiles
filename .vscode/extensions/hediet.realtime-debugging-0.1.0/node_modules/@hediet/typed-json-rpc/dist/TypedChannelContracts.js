"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const t = require("io-ts");
const TypedChannel_1 = require("./TypedChannel");
const disposable_1 = require("@hediet/std/disposable");
/**
 * Describes a request type as part of a `Contract`.
 */
function requestContract(request) {
    return new TypedChannel_1.RequestType(request.method, request.params ? request.params : t.type({}), request.result ? request.result : TypedChannel_1.voidType, request.error ? request.error : TypedChannel_1.voidType);
}
exports.requestContract = requestContract;
/**
 * Describes a notification type as part of a `Contract`.
 */
function notificationContract(notification) {
    return new TypedChannel_1.NotificationType(notification.method, notification.params ? notification.params : t.type({}));
}
exports.notificationContract = notificationContract;
/** Marks a type as error wrapper. */
exports.IsErrorWrapper = Symbol();
/**
 * Wraps an error so that it can be distinguished from a successfully returned result.
 */
class ErrorWrapper {
    constructor(error) {
        this.error = error;
    }
}
ErrorWrapper.factory = (error) => {
    return new ErrorWrapper(error);
};
exports.ErrorWrapper = ErrorWrapper;
function contract(...args) {
    let tags = [];
    let contractObj = undefined;
    if (args.length == 2) {
        tags = args[0];
        contractObj = args[1];
    }
    else {
        contractObj = args[0];
    }
    const server = transform(contractObj["server"]);
    const client = transform(contractObj["client"]);
    return new Contract(tags, server, client);
}
exports.contract = contract;
function transform(requestMap) {
    const result = {};
    for (const [key, req] of Object.entries(requestMap)) {
        const method = req.method ? req.method : key;
        result[key] = req.withMethod(method);
    }
    return result;
}
class AbstractContract {
    constructor(tags = [], server, client) {
        this.tags = tags;
        this.server = server;
        this.client = client;
    }
    onlyDesignTime() {
        return new Error("This property is not meant to be accessed at runtime");
    }
    get TContractObject() {
        throw this.onlyDesignTime();
    }
    get TClientInterface() {
        throw this.onlyDesignTime();
    }
    get TServerInterface() {
        throw this.onlyDesignTime();
    }
    get TTags() {
        throw this.onlyDesignTime();
    }
    getInterface(typedChannel, myContract, otherContract, myInterface, context) {
        const counterpart = this.buildCounterpart(typedChannel, otherContract);
        const disposable = this.registerHandlers(typedChannel, myContract, myInterface, context, counterpart);
        return { counterpart, ...disposable };
    }
    buildCounterpart(typedChannel, otherContract) {
        const counterpart = {};
        for (const [key, req] of Object.entries(otherContract)) {
            let method;
            if (req.kind === "request") {
                method = (args) => {
                    if (args === undefined) {
                        args = {};
                    }
                    return typedChannel.request(req, args);
                };
            }
            else {
                method = (args) => {
                    if (args === undefined) {
                        args = {};
                    }
                    return typedChannel.notify(req, args);
                };
            }
            counterpart[key] = method;
        }
        return counterpart;
    }
    registerHandlers(typedChannel, myContract, myInterface, context, counterpart) {
        const disposables = new Array();
        const notificationInfo = {
            context,
            counterpart,
        };
        for (const [key, req] of Object.entries(myContract)) {
            if (req.kind === "request") {
                const method = myInterface[key];
                if (!method) {
                    throw new Error(`No handler for "${key}" given!`);
                }
                const handler = this.createRequestHandler(context, counterpart, method);
                disposables.push(typedChannel.registerRequestHandler(req, handler));
            }
            else {
                const method = myInterface[key];
                if (method) {
                    disposables.push(typedChannel.registerNotificationHandler(req, args => {
                        // TODO maybe await and log errors?
                        method(args, notificationInfo);
                    }));
                }
            }
        }
        return disposable_1.Disposable.create(disposables);
    }
    createRequestHandler(context, counterpart, method) {
        return async (args, requestId) => {
            try {
                const requestInfo = {
                    context,
                    counterpart,
                    newErr: ErrorWrapper.factory,
                    requestId,
                };
                const result = await method(args, requestInfo);
                if (result instanceof ErrorWrapper) {
                    return result.error;
                }
                return { ok: result };
            }
            catch (e) {
                if (e instanceof TypedChannel_1.RequestHandlingError) {
                    return {
                        error: e.data,
                        errorCode: e.code,
                        errorMessage: e.message,
                    };
                }
                else {
                    throw e;
                }
            }
        };
    }
}
exports.AbstractContract = AbstractContract;
class Contract extends AbstractContract {
    get TClientHandler() {
        throw this.onlyDesignTime();
    }
    get TServerHandler() {
        throw this.onlyDesignTime();
    }
    /**
     * Gets a server object directly from a stream by constructing a new `TypedChannel`.
     * It also registers the client implementation to the stream.
     * The channel starts listening immediately.
     */
    getServerFromStream(stream, logger, clientImplementation) {
        const channel = TypedChannel_1.TypedChannel.fromStream(stream, logger);
        const { server } = this.getServer(channel, clientImplementation);
        channel.startListen();
        return { channel, server };
    }
    /**
     * Gets a client object directly from a stream by constructing a new `TypedChannel`.
     * It also registers the server implementation to the stream.
     * The channel starts listening immediately.
     */
    registerServerToStream(stream, logger, serverImplementation) {
        const channel = TypedChannel_1.TypedChannel.fromStream(stream, logger);
        const { client } = this.registerServer(channel, serverImplementation);
        channel.startListen();
        return { channel, client };
    }
    getServer(typedChannel, clientImplementation) {
        const { counterpart, dispose } = this.getInterface(typedChannel, this.client, this.server, clientImplementation, undefined);
        return { server: counterpart, dispose };
    }
    registerServer(typedChannel, serverImplementation) {
        const { counterpart, dispose } = this.getInterface(typedChannel, this.server, this.client, serverImplementation, undefined);
        return { client: counterpart, dispose };
    }
    withContext() {
        return new ContractWithContext(this.tags, this.server, this.client);
    }
}
exports.Contract = Contract;
class ContractWithContext extends AbstractContract {
    get TClientHandler() {
        throw this.onlyDesignTime();
    }
    get TServerHandler() {
        throw this.onlyDesignTime();
    }
    getServer(typedChannel, context, clientImplementation) {
        const { counterpart, dispose } = this.getInterface(typedChannel, this.client, this.server, clientImplementation, context);
        return { server: counterpart, dispose };
    }
    registerServer(typedChannel, context, serverImplementation) {
        const { counterpart, dispose } = this.getInterface(typedChannel, this.server, this.client, serverImplementation, context);
        return { client: counterpart, dispose };
    }
}
exports.ContractWithContext = ContractWithContext;
//# sourceMappingURL=TypedChannelContracts.js.map