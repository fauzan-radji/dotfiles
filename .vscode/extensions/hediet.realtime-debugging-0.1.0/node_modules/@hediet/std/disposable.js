"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
var Disposable;
(function (Disposable) {
    function create(disposable) {
        if (!disposable)
            return Disposable.empty;
        if (disposable instanceof Function)
            return { dispose: disposable };
        if ("dispose" in disposable)
            return disposable;
        else if (disposable instanceof Set)
            return new ArrayDisposer([...disposable]);
        else if (disposable.length > 0)
            return new ArrayDisposer(disposable);
        return Disposable.empty;
    }
    Disposable.create = create;
    Disposable.empty = { dispose: () => { } };
    function normalize(disposable) {
        if (!disposable)
            return [];
        if (disposable instanceof ArrayDisposer)
            return disposable.items;
        if ("dispose" in disposable)
            return [disposable];
        if (disposable instanceof Set)
            return [...disposable];
        else
            return disposable;
    }
    Disposable.normalize = normalize;
    function fn(callback) {
        const d = new Disposer();
        if (callback) {
            callback(disposable => d.track(disposable), disposable => d.untrack(disposable));
        }
        function dispose() {
            d.dispose();
        }
        dispose.track = d.track.bind(d);
        dispose.untrack = d.untrack.bind(d);
        dispose.dispose = d.dispose;
        Object.defineProperty(dispose, "disposed", {
            get() {
                return d.disposed;
            },
        });
        return dispose;
    }
    Disposable.fn = fn;
})(Disposable = exports.Disposable || (exports.Disposable = {}));
class ArrayDisposer {
    constructor(items) {
        this.items = items;
    }
    dispose() {
        dispose(this.items);
    }
}
// See https://github.com/Microsoft/TypeScript/issues/17002
function isArray(item) {
    return Array.isArray(item);
}
function dispose(disposable) {
    if (!disposable)
        return;
    if (isArray(disposable) || disposable instanceof Set) {
        for (var d of disposable) {
            d.dispose();
        }
    }
    else {
        disposable.dispose();
    }
}
exports.dispose = dispose;
class Disposer {
    constructor() {
        this.disposables = new Set();
        this.disposed = false;
        this.dispose = () => {
            this.disposed = true;
            dispose(this.disposables);
            this.disposables.clear();
        };
    }
    track(disposable) {
        for (const d of Disposable.normalize(disposable)) {
            this.disposables.add(d);
        }
        return disposable;
    }
    untrack(disposable) {
        for (const d of Disposable.normalize(disposable)) {
            this.disposables.delete(d);
        }
        return disposable;
    }
}
exports.Disposer = Disposer;
function disposeOnReturn(callback) {
    let wasPromise = false;
    const disposables = new Set();
    try {
        const result = callback(disposable => {
            for (const d of Disposable.normalize(disposable)) {
                disposables.add(d);
            }
            return disposable;
        }, disposable => {
            for (const d of Disposable.normalize(disposable)) {
                disposables.delete(d);
            }
            return disposable;
        });
        if (isPromise(result)) {
            wasPromise = true;
            return (function test() {
                return __awaiter(this, void 0, void 0, function* () {
                    try {
                        return yield result;
                    }
                    finally {
                        dispose(disposables);
                    }
                });
            })();
        }
        return result;
    }
    finally {
        if (!wasPromise) {
            dispose(disposables);
        }
    }
}
exports.disposeOnReturn = disposeOnReturn;
function isPromise(obj) {
    return (!!obj &&
        (typeof obj === "object" || typeof obj === "function") &&
        typeof obj.then === "function");
}
function addAndDeleteOnDispose(set, keyOrItem, item) {
    if (set instanceof Set) {
        set.add(keyOrItem);
        return Disposable.create(() => set.delete(keyOrItem));
    }
    else {
        set.set(keyOrItem, item);
        return Disposable.create(() => set.delete(keyOrItem));
    }
}
exports.addAndDeleteOnDispose = addAndDeleteOnDispose;
//# sourceMappingURL=disposable.js.map