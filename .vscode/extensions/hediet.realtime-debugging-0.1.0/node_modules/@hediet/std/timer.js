"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
//import { CancellationToken, CancellationError } from './cancellation';
const disposable_1 = require("./disposable");
const events_1 = require("./events");
const synchronization_1 = require("./synchronization");
function startIntervalCallImmediately(intervalMs, callback) {
    callback();
    const handle = setInterval(callback, intervalMs);
    return disposable_1.Disposable.create(() => clearInterval(handle));
}
exports.startIntervalCallImmediately = startIntervalCallImmediately;
function startInterval(intervalMs, callback) {
    const handle = setInterval(callback, intervalMs);
    return disposable_1.Disposable.create(() => clearInterval(handle));
}
exports.startInterval = startInterval;
function startTimeout(intervalMs, callback) {
    const handle = setTimeout(callback, intervalMs);
    return disposable_1.Disposable.create(() => clearTimeout(handle));
}
exports.startTimeout = startTimeout;
class EventTimer {
    constructor(intervalMs, initialState) {
        this.intervalMs = intervalMs;
        this.emitter = new events_1.EventEmitter();
        this.onTick = this.emitter.asEvent();
        if (initialState === "started") {
            this.start();
        }
    }
    get state() {
        if (this.activeInterval) {
            return "started";
        }
        else {
            return "stopped";
        }
    }
    startImmediate() {
        if (this.start()) {
            this.emitter.emit(undefined, this);
            return true;
        }
        return false;
    }
    start() {
        if (!this.activeInterval) {
            this.activeInterval = startInterval(this.intervalMs, () => this.emitter.emit(undefined, this));
            return true;
        }
        return false;
    }
    stop() {
        if (this.activeInterval) {
            this.activeInterval.dispose();
            this.activeInterval = undefined;
            return true;
        }
        return false;
    }
    dispose() {
        stop();
    }
}
exports.EventTimer = EventTimer;
class ResettableTimeout {
    constructor(timeoutMs) {
        this.timeoutMs = timeoutMs;
        this.source = new synchronization_1.Barrier();
        this.onTimeout = this.source.onUnlocked;
        this.startOrRestartTimeout(timeoutMs);
    }
    get timedOut() {
        return this.source.state !== "none";
    }
    startOrRestartTimeout(timeoutMs) {
        if (this.timeout) {
            this.timeout.dispose();
            this.timeout = undefined;
        }
        this.timeout = startTimeout(timeoutMs, () => this.source.unlock());
    }
    reset(newTimeoutMs) {
        this.startOrRestartTimeout(newTimeoutMs || this.timeoutMs);
    }
}
exports.ResettableTimeout = ResettableTimeout;
function wait(intervalMs) {
    return new Promise(resolve => {
        setTimeout(() => resolve(), intervalMs);
    });
}
exports.wait = wait;
/*
export function wait(
    intervalMs: number, cancellationToken?: CancellationToken, rejectOnCancel: boolean = false
): Promise<void> {
    return new Promise<void>((resolve, reject) => {
        let cancelSub: DisposableLike = undefined;
        const handle = setTimeout(() => {
            dispose(cancelSub);
            if (!cancellationToken || !cancellationToken.isCancelled) {
                resolve();
            }
        }, intervalMs);

        
        if (cancellationToken) {
            cancelSub = cancellationToken.onCancel(() => {
                clearTimeout(handle);
                if (rejectOnCancel) {
                    reject(new CancellationError());
                } else {
                    resolve();
                }
            });
        }
        
    });
}
*/
//# sourceMappingURL=timer.js.map