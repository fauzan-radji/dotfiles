"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const HotReloadService_1 = require("./HotReloadService");
const defaultHotMethodOptions = {
//restartOnReload: true
};
/**
 * Marks a class as hot reloadable.
 * This marks each method with `@hotMethod` and tracks new methods.
 */
function hotClass(module, options = defaultHotMethodOptions) {
    return function (target) {
        if (!HotReloadService_1.HotReloadService.instance) {
            return;
        }
        for (const key of Object.getOwnPropertyNames(target.prototype)) {
            const d = Object.getOwnPropertyDescriptor(target.prototype, key);
            if (d && typeof d.value === "function" && !d.value.isHot) {
                hotMethod(module, options)(target.prototype, key, d);
                Object.defineProperty(target.prototype, key, d);
            }
        }
        // Update existing only after all hot-wrappers have been installed.
        FunctionStore.instance.addPrototypeAndUpdateExisting(module, target.name, target.prototype);
    };
}
exports.hotClass = hotClass;
/**
 * Marks a method as hot reloadable.
 * If the method changes while it is executed, it will be restarted.
 * However, if an hot caller changes, it throws a `ModuleChangedError` exception.
 * This triggers the topmost changed caller to restart.
 * The decorator does nothing, if hot reloading has not been enabled.
 * Warning: This decorator might have an performance impact when hot reloading is enabled.
 */
function hotMethod(module, options = defaultHotMethodOptions) {
    return function (target, propertyKey, descriptor) {
        if (!HotReloadService_1.HotReloadService.instance) {
            return;
        }
        const func = descriptor.value;
        const className = target.constructor.name;
        FunctionStore.instance.setFunc(module, className, propertyKey, func);
        descriptor.value = getNewFunc(module, className, propertyKey);
    };
}
exports.hotMethod = hotMethod;
class ModuleChangedError {
    constructor(frameToRestart) {
        this.frameToRestart = frameToRestart;
    }
}
exports.ModuleChangedError = ModuleChangedError;
/**
 * Checks whether any hot method has been changed.
 * If so, throws a `ModuleChangedError` exception that triggers a restart.
 */
function restartOnReload() {
    if (!HotStack.instance.current || !HotReloadService_1.HotReloadService.instance) {
        return;
    }
    if (HotReloadService_1.HotReloadService.instance.handleFileMightHaveChanged(HotStack.instance.current.module.filename)) {
        const b = HotStack.instance.findFrameToRestart();
        if (b) {
            throw new ModuleChangedError(b.frameToRestart);
        }
    }
}
exports.restartOnReload = restartOnReload;
function getNewFunc(module, className, methodName) {
    const fnName = methodName === "constructor"
        ? `${className}`
        : `${methodName}@hot-wrapper`;
    const obj = {
        [fnName](...args) {
            let result;
            while (true) {
                const entry = getMostRecentFuncAndPushOnStack(module, className, methodName);
                try {
                    restartOnReload();
                    result = entry.fn.apply(this, args);
                    restartOnReload();
                    break;
                }
                catch (e) {
                    if (handleError(e, args, entry).continue) {
                        continue;
                    }
                    throw e;
                }
                finally {
                    HotStack.instance.pop();
                }
            }
            return result;
        },
    };
    obj[fnName].isHot = true;
    return obj[fnName];
}
function handleError(e, args, entry) {
    if (e instanceof ModuleChangedError) {
        if (e.frameToRestart === entry) {
            HotReloadService_1.HotReloadService.instance.log(`Restarting ${e.frameToRestart.className}::${e.frameToRestart.methodName}(${args}).`, args);
            return { continue: true };
        }
        else {
            HotReloadService_1.HotReloadService.instance.log(`Interrupting ${entry.className}::${entry.methodName}(${args}) because a caller changed.`);
        }
    }
    return { continue: false };
}
function getMostRecentFuncAndPushOnStack(module, className, methodName) {
    const mostRecentFunc = FunctionStore.instance.getFunc(module, className, methodName);
    const entry = {
        module,
        className,
        methodName,
        fn: mostRecentFunc,
    };
    HotStack.instance.push(entry);
    return entry;
}
class FunctionStore {
    constructor() {
        this.prototypes = new Map();
        this.map = new Map();
    }
    getKey(module, className, methodName) {
        return JSON.stringify({ mod: module.filename, className, methodName });
    }
    addPrototypeAndUpdateExisting(module, className, newProto) {
        const key = JSON.stringify({ mod: module.filename, className });
        let oldProtos = this.prototypes.get(key);
        if (!oldProtos) {
            oldProtos = [];
            this.prototypes.set(key, oldProtos);
        }
        for (const oldProto of oldProtos) {
            for (const propName of Object.getOwnPropertyNames(newProto)) {
                if (!(propName in oldProto)) {
                    oldProto[propName] = newProto[propName];
                }
            }
        }
        oldProtos.push(newProto);
    }
    setFunc(module, className, methodName, fn) {
        const key = this.getKey(module, className, methodName);
        this.map.set(key, fn);
    }
    getFunc(module, className, methodName) {
        const key = this.getKey(module, className, methodName);
        return this.map.get(key);
    }
}
FunctionStore.instance = new FunctionStore();
class HotStack {
    constructor() {
        this.hotStack = new Array();
    }
    push(entry) {
        this.hotStack.push(entry);
    }
    pop() {
        this.hotStack.pop();
    }
    get current() {
        if (this.hotStack.length === 0) {
            return undefined;
        }
        return this.hotStack[this.hotStack.length - 1];
    }
    findFrameToRestart() {
        for (const entry of this.hotStack) {
            const newFn = FunctionStore.instance.getFunc(entry.module, entry.className, entry.methodName);
            if (!newFn) {
                throw new Error("Cannot happen");
            }
            if (newFn.toString() !== entry.fn.toString()) {
                return { frameToRestart: entry };
            }
        }
        return undefined;
    }
}
HotStack.instance = new HotStack();
//# sourceMappingURL=hotMethod.js.map