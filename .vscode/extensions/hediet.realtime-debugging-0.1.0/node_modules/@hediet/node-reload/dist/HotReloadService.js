"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const chokidar_1 = require("chokidar");
const path_1 = require("path");
const fs_1 = require("fs");
const Module = require("module");
const Reconciler_1 = require("./Reconciler");
const chalk_1 = require("chalk");
const disposable_1 = require("@hediet/std/disposable");
class HotReloadService {
    constructor(loggingEnabled, shouldTrackModule) {
        this.loggingEnabled = loggingEnabled;
        this.shouldTrackModule = shouldTrackModule;
        this.watcher = chokidar_1.watch([], { disableGlobbing: true });
        this.trackedModules = new Map();
        this.level = 0;
        this.originalModule = {
            load: Module.prototype.load,
            require: Module.prototype.require,
        };
        this.watcher.on("change", (file) => {
            // Deferring guards against safe write or file truncation before writing.
            setTimeout(() => {
                this.handleFileMightHaveChanged(file);
            }, 200);
        });
        const service = this;
        Module.prototype.require = function (request) {
            return service.require(this, request);
        };
        Module.prototype.load = function (filename) {
            service.handleBeforeModuleLoaded(this, filename);
            const result = service.originalModule.load.call(this, filename);
            return result;
        };
    }
    log(message, ...args) {
        if (this.loggingEnabled) {
            let padding = "";
            for (let i = 0; i < this.level; i++) {
                padding += "| ";
            }
            console.log(chalk_1.default.gray(padding + message), ...args);
        }
    }
    indentLog() {
        this.level++;
        return disposable_1.Disposable.create(() => {
            this.level--;
        });
    }
    dispose() {
        this.watcher.close();
    }
    require(caller, request, callerTrackedModule) {
        const moduleExports = this.originalModule.require.call(caller, request);
        let modulePath;
        try {
            modulePath = Module._resolveFilename(request, caller);
        }
        catch (e) {
            this.log(`Error while resolving module "${request}" from "${caller.filename}"`);
            return moduleExports;
        }
        try {
            const requiredModule = require.cache[modulePath];
            if (requiredModule) {
                if (!callerTrackedModule) {
                    callerTrackedModule = this.trackedModules.get(caller.filename);
                }
                this.handleAfterModuleRequired(callerTrackedModule, requiredModule);
            }
        }
        catch (e) {
            this.log(`Error while requiring "${request}" from "${caller.filename}": `, e);
        }
        return moduleExports;
    }
    trackEntryModule(mod) {
        if (this.trackedModules.get(mod.filename)) {
            return;
        }
        this.handleBeforeModuleLoaded(mod, mod.filename);
        this.handleAfterModuleRequired(undefined, mod);
    }
    handleBeforeModuleLoaded(requiredModule, filename) {
        if (!this.shouldTrackModule(filename)) {
            return;
        }
        const source = fs_1.readFileSync(filename, {
            encoding: "utf8",
        });
        Reconciler_1.nodeModuleSourceProperty.set(requiredModule, source);
        const trackedModule = new ReconcilableNodeModule(requiredModule, this);
        const oldTrackedModule = this.trackedModules.get(filename);
        if (oldTrackedModule) {
            if (oldTrackedModule.prepareNewModule) {
                oldTrackedModule.prepareNewModule(requiredModule);
            }
            this.log(`Existing module for file "${filename}" was overridden.`);
        }
        this.trackedModules.set(filename, trackedModule);
    }
    handleAfterModuleRequired(dependant, dependency) {
        let requiredTrackedModule = this.trackedModules.get(dependency.filename);
        if (!requiredTrackedModule) {
            this.log(`Required untracked module "${dependency.filename}"`);
        }
        else {
            if (dependant) {
                requiredTrackedModule.dependants.add(dependant);
                dependant.dependencies.add(requiredTrackedModule);
            }
            this.watcher.add(dependency.filename);
        }
    }
    handleFileMightHaveChanged(filename) {
        const changedModule = this.trackedModules.get(filename);
        if (!changedModule) {
            return false;
        }
        const now = new Date();
        if (now.getTime() - changedModule.lastFileChangeCheck.getTime() < 100) {
            // As reading the file is quite expensive,
            // this limits checking whether the content has changed to once per 100ms.
            return false;
        }
        changedModule.lastFileChangeCheck = now;
        const newSource = fs_1.readFileSync(changedModule.module.filename, {
            encoding: "utf8",
        });
        const oldSource = Reconciler_1.nodeModuleSourceProperty.get(changedModule.module);
        if (newSource === oldSource) {
            return false;
        }
        this.log(`File changed: "${path_1.relative(process.cwd(), changedModule.module.filename)}"`);
        Reconciler_1.nodeModuleSourceProperty.set(changedModule.module, newSource);
        const mightNeedReconcilation = this.getModulesThatMightNeedReconcilation(changedModule);
        const processedDeps = new Map();
        const queue = [changedModule];
        while (queue.length > 0) {
            const curMod = queue.shift();
            if (processedDeps.has(curMod)) {
                continue;
            }
            const possibleChangedDeps = [
                ...curMod.dependencies.values(),
            ].filter(d => mightNeedReconcilation.has(d));
            if (!possibleChangedDeps.every(d => processedDeps.has(d))) {
                // Process after all relevant deps have been processed.
                continue;
            }
            const notReconciledDeps = possibleChangedDeps.filter(d => !processedDeps.get(d).reconciled);
            const reason = this.getReason(curMod, { newSource, oldSource }, changedModule, notReconciledDeps, processedDeps);
            const reconciled = this.tryToReconcile(reason, curMod);
            processedDeps.set(curMod, { reason, reconciled });
            for (const dependant of curMod.dependants) {
                queue.push(dependant);
            }
        }
        return true;
    }
    getReason(curMod, curModChangeReason, changedModule, notReconciledDeps, processedDeps) {
        const reason = {
            dependencyUpdates: new Map(),
        };
        if (curMod === changedModule) {
            reason.moduleUpdates = curModChangeReason;
        }
        for (const d of notReconciledDeps) {
            reason.dependencyUpdates.set(d.id, processedDeps.get(d).reason);
        }
        return reason;
    }
    tryToReconcile(reason, curMod) {
        if (reason.moduleUpdates || reason.dependencyUpdates.size > 0) {
            // something changed for this module
            this.log(`Reconciling "${curMod.id}"`);
            const d = this.indentLog();
            try {
                if (curMod.tryToReconcile(reason)) {
                    this.log(`succeeded.`);
                    return true;
                }
                else {
                    if (curMod.dependants.size === 0) {
                        this.log(`failed.`);
                    }
                    return false;
                }
            }
            finally {
                d.dispose();
            }
        }
        return false;
    }
    getModulesThatMightNeedReconcilation(changedModule) {
        const mightNeedReconcilation = new Set();
        const queue = [changedModule];
        while (queue.length > 0) {
            const curMod = queue.shift();
            mightNeedReconcilation.add(curMod);
            for (const dependant of curMod.dependants) {
                if (mightNeedReconcilation.has(dependant)) {
                    continue;
                }
                queue.push(dependant);
            }
        }
        return mightNeedReconcilation;
    }
}
exports.HotReloadService = HotReloadService;
class ReconcilableModule {
    constructor() {
        this.dependencies = new Set();
        this.dependants = new Set();
    }
}
class ReconcilableNodeModule extends ReconcilableModule {
    constructor(module, service) {
        super();
        this.module = module;
        this.service = service;
        this.prepareNewModule = undefined;
        this.lastFileChangeCheck = new Date();
    }
    get id() {
        return this.module.id;
    }
    tryToReconcile(reason) {
        let reloaded = false;
        const clearOldCache = () => {
            if (!reloaded) {
                this.service.log(`clearing cache`);
                delete require.cache[this.module.filename];
            }
            reloaded = true;
        };
        const reloadModule = prepareNewModule => {
            clearOldCache();
            this.service.log("requiring new module");
            this.prepareNewModule = prepareNewModule;
            const newExports = disposable_1.disposeOnReturn(track => {
                track(this.service.indentLog());
                // don't track this dependency to ourself
                return this.service.originalModule.require.call(this.module, this.module.filename);
            });
            this.prepareNewModule = undefined;
            const requiredModule = require.cache[this.module.filename];
            return { newExports, newModule: requiredModule };
        };
        const reconciled = this.reconcile({
            ...reason,
            reloadModule,
        });
        if (!reconciled) {
            clearOldCache();
        }
        return reconciled;
    }
    reconcile(context) {
        const r = Reconciler_1.getModuleReconciler(this.module);
        if (r) {
            return r(context);
        }
        return false;
    }
}
class DelegateModule extends ReconcilableModule {
    constructor(idPrefix, _reconciler) {
        super();
        this.idPrefix = idPrefix;
        this._reconciler = _reconciler;
        this._id = DelegateModule.idCounter++;
    }
    get id() {
        return `${this.idPrefix}#${this._id}`;
    }
    tryToReconcile(reason) {
        return this._reconciler(reason);
    }
}
DelegateModule.idCounter = 0;
exports.DelegateModule = DelegateModule;
//# sourceMappingURL=HotReloadService.js.map