"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("@hediet/std/events");
const utils_1 = require("./utils");
class StepExecutionController {
    constructor() {
        this.lastRanStepIdx = -1;
        this.currentSteps = new Array();
        this.stepStatesChangedEmitter = new events_1.EventEmitter();
        this.onStepStatesChanged = this.stepStatesChangedEmitter.asEvent();
    }
    getStepStates() {
        return this.currentSteps.map(s => ({ id: s.step.id, state: s.state }));
    }
    async applyNewSteps(steps) {
        const { unchangedCountStart, unchangedCountEnd } = this.compare(steps);
        await this.rewindBefore(unchangedCountStart);
        this.currentSteps = steps.steps.map((step, i) => ({
            step,
            state: i < unchangedCountStart
                ? this.currentSteps[i].state
                : { kind: "notRun" },
        }));
        this.stepDataChanged();
        await this.runAfter(this.currentSteps.length - 1 - unchangedCountEnd);
    }
    async moveTo(stepId) {
        const idx = this.currentSteps.findIndex(s => s.step.id === stepId);
        if (idx < 0) {
            return;
        }
        await this.rewindBefore(idx);
        await this.runAfter(idx);
    }
    async runAfter(stepIdx) {
        while (this.lastRanStepIdx < stepIdx) {
            const nextStep = this.currentSteps[this.lastRanStepIdx + 1];
            let arg = undefined;
            if (this.lastRanStepIdx >= 0) {
                const state = this.currentSteps[this.lastRanStepIdx].state;
                if (state.kind !== "ran") {
                    throw new Error("Impossible");
                }
                arg = state.result;
            }
            nextStep.state = { kind: "running" };
            this.stepDataChanged();
            const undos = new Array();
            const result = await nextStep.step.run(arg, {
                onRewind: fn => undos.push(fn),
            });
            nextStep.state = { kind: "ran", result, undos };
            this.stepDataChanged();
            this.lastRanStepIdx++;
        }
    }
    async rewindBefore(stepIdx) {
        while (this.lastRanStepIdx >= stepIdx) {
            const stepData = this.currentSteps[this.lastRanStepIdx];
            const state = stepData.state;
            if (state.kind !== "ran") {
                throw new Error("Should not happen");
            }
            stepData.state = { kind: "undoing" };
            this.stepDataChanged();
            state.undos.reverse();
            for (const undo of state.undos) {
                await undo();
            }
            stepData.state = { kind: "undone" };
            this.stepDataChanged();
            this.lastRanStepIdx--;
        }
    }
    stepDataChanged() {
        this.stepStatesChangedEmitter.emit(this.getStepStates(), this);
    }
    compare(steps) {
        const areEqual = (s1, s2) => {
            if (s1 === s2) {
                return true;
            }
            if (!s1 || !s2) {
                return false;
            }
            return utils_1.areEqualConsideringFunctionSource(s1.step, s2);
        };
        let unchangedCountStart = 0;
        for (let i = 0; i < steps.steps.length; i++) {
            if (!areEqual(this.currentSteps[i], steps.steps[i])) {
                break;
            }
            unchangedCountStart++;
        }
        let unchangedCountEnd = 0;
        for (let i = 1; i <= steps.steps.length; i++) {
            const curStep = this.currentSteps[this.currentSteps.length - i];
            const newStep = steps.steps[steps.steps.length - i];
            if (!areEqual(curStep, newStep)) {
                break;
            }
            unchangedCountEnd++;
        }
        return { unchangedCountStart, unchangedCountEnd };
    }
}
exports.StepExecutionController = StepExecutionController;
//# sourceMappingURL=StepExecutionController.js.map