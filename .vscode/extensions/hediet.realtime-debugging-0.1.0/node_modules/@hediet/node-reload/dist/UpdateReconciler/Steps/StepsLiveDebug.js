"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const io_ts_1 = require("io-ts");
const typed_json_rpc_1 = require("@hediet/typed-json-rpc");
const disposable_1 = require("@hediet/std/disposable");
const live_debug_1 = require("@hediet/live-debug");
const stepState = io_ts_1.type({
    id: io_ts_1.string,
    state: io_ts_1.union([
        io_ts_1.literal("notRun"),
        io_ts_1.literal("running"),
        io_ts_1.literal("ran"),
        io_ts_1.literal("undoing"),
        io_ts_1.literal("undone"),
    ]),
});
exports.StepsLiveDebugContract = typed_json_rpc_1.contract({
    server: {
        updateState: typed_json_rpc_1.notificationContract({
            params: io_ts_1.type({
                controllerId: io_ts_1.Integer,
                newState: io_ts_1.array(stepState),
            }),
        }),
    },
    client: {
        requestUpdate: typed_json_rpc_1.notificationContract({}),
        runToStepIncluding: typed_json_rpc_1.notificationContract({
            params: io_ts_1.type({
                stepId: io_ts_1.string,
            }),
        }),
    },
});
class StepsLiveDebug {
    constructor() {
        this.controllerId = 0;
        this.controllers = new Map();
        this.servers = new Set();
        live_debug_1.registerLiveDebug((channel, onClosed) => {
            const { server } = exports.StepsLiveDebugContract.getServer(channel, {
                runToStepIncluding: ({ stepId }) => {
                    this.runToStepIncluding(stepId);
                },
                requestUpdate: () => {
                    for (const [id, c] of this.controllers) {
                        this.publishData(c.getStepStates(), id);
                    }
                },
            });
            const info = { server };
            channel.onListening.then(async () => {
                this.servers.add(info);
                await onClosed;
                this.servers.delete(info);
            });
        });
    }
    registerController(controller) {
        return disposable_1.Disposable.fn(track => {
            const controllerId = this.controllerId++;
            this.controllers.set(controllerId, controller);
            track({
                dispose: () => {
                    this.controllers.delete(controllerId);
                },
            });
            track(controller.onStepStatesChanged.sub(state => this.publishData(state, controllerId)));
        });
    }
    publishData(state, controllerId) {
        for (const server of this.servers) {
            server.server.updateState({
                controllerId,
                newState: state.map(s => ({
                    id: s.id,
                    state: s.state.kind,
                })),
            });
        }
    }
    runToStepIncluding(stepId, controllerId) {
        for (const [id, c] of this.controllers) {
            if (controllerId !== undefined && id !== controllerId) {
                continue;
            }
            c.moveTo(stepId);
        }
    }
}
StepsLiveDebug.instance = new StepsLiveDebug();
exports.StepsLiveDebug = StepsLiveDebug;
//# sourceMappingURL=StepsLiveDebug.js.map