"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const disposable_1 = require("@hediet/std/disposable");
const extensibility_1 = require("@hediet/std/extensibility");
const Reconciler_1 = require("../Reconciler");
const HotReloadService_1 = require("../HotReloadService");
const moduleInfoProperty = new extensibility_1.AttachedProperty(() => undefined);
/**
 * Registers the `UpdateReconciler` for the given module.
 * If the module changes after registration,
 * it disposes all disposables registered by `disposeOnReload`
 * and updates all `hotRequireExportedFn`-handlers.
 */
function registerUpdateReconciler(module) {
    if (!moduleInfoProperty.get(module)) {
        moduleInfoProperty.set(module, {
            reloadCount: 0,
            updaters: new Set(),
            disposables: [],
        });
    }
    Reconciler_1.setModuleReconciler(module, context => {
        HotReloadService_1.HotReloadService.instance.log("Reconciling with updateReconciler.");
        const info = moduleInfoProperty.get(module);
        if (!info) {
            throw new Error("Impossible");
        }
        const curUpdaters = [...info.updaters];
        disposable_1.dispose(info.disposables);
        const { newExports } = context.reloadModule(newModule => {
            if (moduleInfoProperty.get(newModule)) {
                throw new Error("Impossible");
            }
            const newInfo = {
                reloadCount: info.reloadCount + 1,
                updaters: info.updaters,
                disposables: [],
            };
            moduleInfoProperty.set(newModule, newInfo);
        });
        for (const updater of curUpdaters) {
            const newFn = newExports[updater.exportName];
            if (!updater.hasFnChanged(newFn, updater.lastFn)) {
                continue;
            }
            HotReloadService_1.HotReloadService.instance.log(`Exported item "${updater.exportName}" is marked as changed`);
            try {
                disposable_1.dispose(updater.lastDisposable);
            }
            catch (e) {
                HotReloadService_1.HotReloadService.instance.log(`Could not dispose stale disposables: `, e);
                throw e;
            }
            try {
                updater.lastDisposable = updater.update(newFn, updater.lastFn);
            }
            catch (e) {
                HotReloadService_1.HotReloadService.instance.log(`Could not apply update: `, e);
                throw e;
            }
            updater.lastFn = newFn;
        }
        return true;
    });
}
exports.registerUpdateReconciler = registerUpdateReconciler;
/**
 * Gets the count of how often the given module was reconciled using the `UpdateReconciler`.
 */
function getReloadCount(module) {
    const info = moduleInfoProperty.get(module);
    if (!info) {
        throw new Error(`'registerUpdateReconciler' must be called first.`);
    }
    return info.reloadCount;
}
exports.getReloadCount = getReloadCount;
/**
 * Disposes `disposable` when `module` is reconciled by the `UpdateReconciler`.
 */
function disposeOnReload(module, disposable) {
    const info = moduleInfoProperty.get(module);
    if (!info) {
        throw new Error(`'registerUpdateReconciler' must be called first.`);
    }
    info.disposables.push(...disposable_1.Disposable.normalize(disposable));
}
exports.disposeOnReload = disposeOnReload;
function hotRequireExportedFn(module, exportedFn, updateOrOptions, optionalUpdate) {
    let options = {};
    let update;
    if (typeof updateOrOptions === "function") {
        update = updateOrOptions;
    }
    else {
        options = updateOrOptions;
        update = optionalUpdate;
    }
    const info = moduleInfoProperty.get(module);
    if (!info) {
        throw new Error(`'registerUpdateReconciler' must be called first.`);
    }
    /*
    // Don't throw as exports might be set later on initial load!
    if (module.exports[exportedFn.name] !== exportedFn) {
        throw new Error(
            `Given function is not exported at "module.exports.${
                exportedFn.name
            }"!`
        );
    }
    */
    let hasFnChanged = () => true;
    if (options) {
        if (options.hasFnChanged === "useSource") {
            hasFnChanged = (newFn, lastFn) => newFn.toString() !== lastFn.toString();
        }
        else if (typeof options.hasFnChanged === "function") {
            hasFnChanged = options.hasFnChanged;
        }
    }
    const updater = {
        exportName: exportedFn.name,
        lastDisposable: update(exportedFn, undefined),
        lastFn: exportedFn,
        hasFnChanged,
        update,
    };
    info.updaters.add(updater);
    return disposable_1.Disposable.create(() => {
        info.updaters.delete(updater);
        disposable_1.dispose(updater.lastDisposable);
    });
}
exports.hotRequireExportedFn = hotRequireExportedFn;
function hotCallExportedFunction(module, exportedFn, ...args) {
    let result = undefined;
    const d = hotRequireExportedFn(module, exportedFn, exportedFn => {
        result = exportedFn(...args);
    });
    while (true) {
        if (HotReloadService_1.HotReloadService.instance) {
            if (HotReloadService_1.HotReloadService.instance.handleFileMightHaveChanged(module.filename)) {
                continue;
            }
        }
        break;
    }
    d.dispose();
    return result;
}
exports.hotCallExportedFunction = hotCallExportedFunction;
//# sourceMappingURL=updateReconciler.js.map