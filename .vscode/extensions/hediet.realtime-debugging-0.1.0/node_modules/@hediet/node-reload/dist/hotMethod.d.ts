/// <reference types="node" />
interface HotMethodOptions {
}
/**
 * Marks a class as hot reloadable.
 * This marks each method with `@hotMethod` and tracks new methods.
 */
export declare function hotClass(module: NodeModule, options?: HotMethodOptions): (target: any) => void;
/**
 * Marks a method as hot reloadable.
 * If the method changes while it is executed, it will be restarted.
 * However, if an hot caller changes, it throws a `ModuleChangedError` exception.
 * This triggers the topmost changed caller to restart.
 * The decorator does nothing, if hot reloading has not been enabled.
 * Warning: This decorator might have an performance impact when hot reloading is enabled.
 */
export declare function hotMethod(module: NodeModule, options?: HotMethodOptions): (target: any, propertyKey: string, descriptor: PropertyDescriptor) => void;
export declare class ModuleChangedError {
    readonly frameToRestart: HotStackFrame;
    constructor(frameToRestart: HotStackFrame);
}
/**
 * Checks whether any hot method has been changed.
 * If so, throws a `ModuleChangedError` exception that triggers a restart.
 */
export declare function restartOnReload(): void;
interface HotStackFrame {
    module: NodeModule;
    className: string;
    methodName: string;
    fn: Function;
}
export {};
//# sourceMappingURL=hotMethod.d.ts.map