"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const _1 = require(".");
const typed_json_rpc_1 = require("@hediet/typed-json-rpc");
const io_ts_1 = require("io-ts");
const StackTracey = require("stacktracey");
exports.liveLogContract = typed_json_rpc_1.contract({
    server: {
        logExpression: typed_json_rpc_1.notificationContract({
            params: io_ts_1.type({
                filename: io_ts_1.string,
                lineNumber: io_ts_1.Integer,
                value: io_ts_1.string,
            }),
        }),
        logExpressionById: typed_json_rpc_1.notificationContract({
            params: io_ts_1.type({
                id: io_ts_1.string,
                value: io_ts_1.string,
            }),
        }),
    },
    client: {},
});
const servers = new Set();
_1.registerLiveDebug((channel, onClose) => {
    const { server } = exports.liveLogContract.getServer(channel, {});
    channel.onListening.then(async () => {
        servers.add(server);
        await onClose;
        servers.delete(server);
    });
});
/**
 * Logs an expression and tracks the source using source maps.
 * Does only work well on NodeJS.
 */
async function liveLog(expression) {
    StackTracey.resetCache();
    const tracey = new StackTracey();
    const parentFrame = tracey.withSources[1];
    const filename = parentFrame.file;
    const lineNumber = parentFrame.line - 1;
    for (const s of servers) {
        s.logExpression({
            filename,
            lineNumber,
            value: expression.toString(),
        });
    }
}
exports.liveLog = liveLog;
/**
 * Logs an expression and tracks the source using an unique id.
 */
async function liveLogId(id, expression) {
    for (const s of servers) {
        s.logExpressionById({ id, value: expression.toString() });
    }
}
exports.liveLogId = liveLogId;
//# sourceMappingURL=liveLog.js.map