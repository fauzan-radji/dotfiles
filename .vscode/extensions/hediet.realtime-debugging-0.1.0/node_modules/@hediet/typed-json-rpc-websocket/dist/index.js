"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const typed_json_rpc_1 = require("@hediet/typed-json-rpc");
const WebSocket = require("isomorphic-ws");
/**
 * Normalizes the given options to `NormalizedWebSocketOptions`.
 * It builds the address from a given host and port.
 */
function normalizeWebSocketOptions(options) {
    if ("host" in options) {
        const useTls = options.forceTls;
        return {
            address: `${useTls ? "wss" : "ws"}://${options.host}:${options.port}`,
        };
    }
    else {
        return options;
    }
}
exports.normalizeWebSocketOptions = normalizeWebSocketOptions;
/**
 * Represents a stream through a web socket.
 * Use the static `connectTo` method to get a stream to a web socket server.
 */
class WebSocketStream extends typed_json_rpc_1.BaseMessageStream {
    constructor(socket) {
        super();
        this.socket = socket;
        socket.onmessage = msg => {
            const data = msg.data;
            if (typeof data === "string") {
                const json = JSON.parse(data);
                // TODO check type of json
                this.onMessage(json);
            }
            else {
                throw new Error("Not supported"); // TODO test
            }
        };
        socket.onclose = _event => {
            this.onConnectionClosed();
        };
    }
    static connectTo(options) {
        const normalizedOptions = normalizeWebSocketOptions(options);
        const ws = new WebSocket(normalizedOptions.address);
        return new Promise((res, rej) => {
            // don't use `on` as it does not exist for browsers
            ws.onerror = err => {
                rej(err);
            };
            ws.onopen = () => {
                res(new WebSocketStream(ws));
            };
        });
    }
    /**
     * Closes the underlying socket.
     */
    close() {
        this.socket.close();
    }
    /**
     * Same as `close`.
     */
    dispose() {
        this.close();
    }
    write(message) {
        const str = JSON.stringify(message);
        return new Promise((res, rej) => {
            this.socket.send(str, err => {
                if (err) {
                    rej(err);
                }
                else {
                    res();
                }
            });
        });
    }
    toString() {
        return `${this.id}@${this.socket.url}`;
    }
}
exports.WebSocketStream = WebSocketStream;
//# sourceMappingURL=index.js.map